"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Date custom scalar type"""
scalar Date

enum IsoCountryCode {
  EU
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BA
  BW
  BV
  BR
  IO
  VG
  BN
  BG
  BF
  BI
  KH
  CM
  CA
  CV
  BQ
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UM
  VI
  UG
  UA
  AE
  GB
  US
  UY
  UZ
  VU
  VA
  VE
  VN
  WF
  EH
  YE
  ZM
  ZW
}

enum DataCategoryType {
  FINANCIAL
  HEALTH
  CONTACT
  LOCATION
  DEMOGRAPHIC
  ID
  ONLINE_ACTIVITY
  USER_PROFILE
  SOCIAL_MEDIA
  CONNECTION
  TRACKING
  DEVICE
  SURVEY
  OTHER
  UNSPECIFIED
  NOT_PERSONAL_DATA
  INTEGRATION_IDENTIFIER
}

enum ProcessingPurpose {
  ESSENTIAL
  ADDITIONAL_FUNCTIONALITY
  ADVERTISING
  MARKETING
  ANALYTICS
  PERSONALIZATION
  OPERATION_SECURITY
  LEGAL
  TRANSFER
  SALE
  HR
  OTHER
  UNSPECIFIED
}

enum IntegrationQueueType {
  RequestEnricher
  RequestDataSilo
  ProfileDataPoint
  requestFile
  plugin
  lookupProcess
}

enum RequestAction {
  AUTOMATED_DECISION_MAKING_OPT_OUT
  USE_OF_SENSITIVE_INFORMATION_OPT_OUT
  CONTACT_OPT_OUT
  SALE_OPT_OUT
  TRACKING_OPT_OUT
  CUSTOM_OPT_OUT
  AUTOMATED_DECISION_MAKING_OPT_IN
  USE_OF_SENSITIVE_INFORMATION_OPT_IN
  SALE_OPT_IN
  TRACKING_OPT_IN
  CONTACT_OPT_IN
  CUSTOM_OPT_IN
  ACCESS
  ERASURE
  RECTIFICATION
  RESTRICTION
  BUSINESS_PURPOSE
  PLACE_ON_LEGAL_HOLD
  REMOVE_FROM_LEGAL_HOLD
}

enum RequestActionOptOut {
  AUTOMATED_DECISION_MAKING_OPT_OUT
  USE_OF_SENSITIVE_INFORMATION_OPT_OUT
  CONTACT_OPT_OUT
  SALE_OPT_OUT
  TRACKING_OPT_OUT
  CUSTOM_OPT_OUT
}

enum HttpMethod {
  GET
  POST
  DELETE
  PUT
  PATCH
}

enum ScopeName {
  readOnly
  fullAdmin
  viewAllActionItems
  manageAllActionItems
  makeDataSubjectRequest
  connectDataSilos
  deployPrivacyCenter
  manageConsentManager
  viewConsentManager
  manageConsentManagerDisplaySettings
  manageConsentManagerDeveloperSettings
  manageDataFlow
  deployConsentManager
  deployTestConsentManager
  viewCustomerDataDataMapping
  viewCustomerDataPrivacyRequests
  manageAccessControl
  manageApiKeys
  manageBilling
  manageDataMap
  managedAssignedIntegrations
  managedAssignedDataInventory
  managedAssignedConsentManager
  managedAssignedRequests
  viewAssignedIntegrations
  viewAssignedDataInventory
  viewAssignedConsentManager
  viewAssignedRequests
  manageDataSubjectRequestSettings
  manageEmailTemplates
  manageOrganizationInfo
  managePrivacyCenter
  viewPrivacyCenter
  manageLegalHold
  manageRequestCompilation
  manageRequestIdentities
  manageRequestSecurity
  manageSombraRootKeys
  manageSSO
  manageEmailDomains
  requestApproval
  viewApiKeys
  viewDataFlow
  viewDataMap
  viewLegalHold
  viewDataSubjectRequestSettings
  viewEmailTemplates
  viewEmailDomains
  viewRequestCompilation
  viewRequestIdentitySettings
  viewRequests
  viewScopes
  viewSSO
  viewEmployees
  viewDataInventory
  manageDataInventory
  manageGlobalAttributes
  viewGlobalAttributes
  viewAssessments
  manageAssessments
  viewAssignedAssessments
  manageAssignedAssessments
  approveAssessments
  managePrompts
  managePromptRuns
  executePrompt
  viewPromptRuns
  viewPrompts
  approvePrompts
  manageAuditor
  executeAuditor
  viewCodeScanning
  manageCodeScanning
  viewPathfinder
  managePathfinder
  viewContractScanning
  manageContractScanning
  viewAuditorRuns
  viewAuditEvents
  manageActionItemCollections
  viewManagedConsentDatabaseAdminApi
  manageStoredPreferences
  managePreferenceStoreSettings
  viewPreferenceStoreSettings
  managePolicies
  viewPolicies
  manageIntlMessages
  viewIntlMessages
  llmLogTransfer
  manageWorkflows
}

enum ScopeType {
  MODIFY
  VIEW
}

enum FormFormat {
  DATE
  DATE_TIME
  EMAIL
  PASSWORD
  PHONE_NUMBER
  TIME
}

enum OrderDirection {
  ASC
  DESC
}

enum SombraHostedMethod {
  MULTI_TENANT
  SINGLE_TENANT
  ON_PREMISE
}

enum SombraStandardScopes {
  preferenceManagement
  dsrAutomation
}

enum IdentifierType {
  email
  phone
  coreIdentifier
  custom
  gaid
  idfa
  idfv
  browserId
  microsoftAdvertisingId
  amazonFireAdvertisingId
  rida
  filestackHandle
  stripeId
  braintreeCustomerId
  chargebeeId
  thriveTrmContactId
  talkableUUID
  recurlyId
  customerIoId
  sprigVisitorId
  linkedInURL
  advertisingId
  personaReferenceId
  streamUserId
  plaidProcessorToken
  onfidoApplicantId
  veroUserId
  adobeAdvertisingCloudId
  adobeAudienceManagerId
  adobeExperienceCloudId
  adobeTargetId
}

enum CompletedRequestStatus {
  FAILED_VERIFICATION
  COMPLETED
  CANCELED
  SECONDARY_COMPLETED
  REVOKED
}

enum AllowedEnricherTransition {
  CANCELED
  ON_HOLD
  FAILED_VERIFICATION
  COMPILING
}

enum FormAutoComplete {
  NAME
  HONORIFIC_PREFIX
  GIVEN_NAME
  ADDITIONAL_NAME
  ADDITIONAL_NAME_INITIAL
  FAMILY_NAME
  HONORIFIC_SUFFIX
  NICKNAME
  STREET_ADDRESS
  ADDRESS_LINE1
  ADDRESS_LINE2
  ADDRESS_LINE3
  LOCALITY
  CITY
  ADMINISTRATIVE_AREA
  STATE
  PROVINCE
  REGION
  POSTAL_CODE
  COUNTRY_NAME
  EMAIL
  TEL
  TEL_COUNTRY_CODE
  TEL_NATIONAL
  TEL_AREA_CODE
  TEL_LOCAL
  TEL_LOCAL_PREFIX
  TEL_LOCAL_SUFFIX
  TEL_EXTENSION
  FAX
  FAX_country_code
  FAX_NATIONAL
  FAX_AREA_CODE
  FAX_LOCAL
  FAX_LOCAL_PREFIX
  FAX_LOCAL_SUFFIX
  FAX_EXTENSION
  CC_NAME
  CC_GIVEN_NAME
  CC_ADDITIONAL_NAME
  CC_FAMILY_NAME
  CC_NUMBER
  CC_EXP_MONTH
  CC_EXP_YEAR
  CC_EXP
  CC_CSC
  BDAY
  BDAY_YEAR
  BDAY_MONTH
  BDAY_DAY
  ORG
  ORGANIZATION_TITLE
  SEX
  GENDER_IDENTITY
  URL
  PHOTO
  NEW_PASSWORD
  CURRENT_PASSWORD
}

enum ViewState {
  QuickOptions
  QuickOptions3
  AcceptAll
  AcceptAllRejectAllToggle
  AcceptAllOrMoreChoices
  AcceptOrRejectAll
  AcceptOrRejectAllOrMoreChoices
  AcceptOrRejectAnalytics
  AcceptOrRejectAdvertising
  NoticeAndDoNotSell
  DoNotSellExplainer
  CompleteOptionsToggles
  PrivacyPolicyNotice
  PrivacyPolicyNoticeWithCloseButton
  CompleteOptions
  CompleteOptionsInverted
  Hidden
  TCF_EU
  DoNotSellDisclosure
  OptOutDisclosure
  LanguageOptions
  Collapsed
  Closed
}

enum ConsentTrackerSource {
  MANUAL
  SCAN
  TELEMETRY
}

enum ConsentTrackerStatus {
  LIVE
  NEEDS_REVIEW
}

enum PrivacyRegimeEnum {
  Unknown
  CPRA
  GDPR
  LGPD
  CDPA
  CPA
  NEVADA_SB220
  nFADP
  US_DNSS
}

enum PluginType {
  DATA_SILO_DISCOVERY
  SCHEMA_DISCOVERY
  CONTENT_CLASSIFICATION
  LOOKUP_PROCESS
  CREATE_LOOKUP_PROCESS
  UNSTRUCTURED_DATA_DISCOVERY
  UNSTRUCTURED_DATA_SAMPLING
}

enum DatabaseModelName {
  migration
  migrationLock
  ActionItemAttributeValue
  ActionItemCollectionActionItem
  AgentApplication
  AgentAppUser
  ApplicationAppUser
  ApplicationPrompt
  AgentAgentFile
  AgentAgentFunction
  AgentTeam
  AgentUser
  ApplicationTeam
  ApplicationUser
  ActionItemTeam
  ActionItemUser
  AirgapCookieUser
  AirgapCookieTeam
  AirgapDataFlowUser
  AirgapDataFlowTeam
  RequestUser
  RequestTeam
  SubjectUser
  SubjectTeam
  ApiKeyScope
  CatalogSaaSCategory
  DataPointLevelUser
  SubDataPointSubject
  DataPointUser
  DataSiloApiKey
  DataSiloAttributeValue
  DataSiloSaaSCategory
  AirgapCookieAttributeValue
  AirgapDataFlowAttributeValue
  AirgapDataFlowPurpose
  AirgapCookiePurpose
  ContractScanContract
  ContractScanPrompt
  DataSiloPlugin
  DataSiloUser
  OrganizationSombra
  DataSiloTeam
  DataSiloDataSilo
  DataSiloDataSubCategory
  DataSiloProcessingPurposeSubCategory
  DataPointTeam
  DataPointLevelTeam
  ProcessingPurposeSubCategoryTeam
  DataSubCategoryTeam
  ProcessingPurposeSubCategoryUser
  DataSubCategoryUser
  VendorUser
  VendorTeam
  RiskCategoryUser
  RiskCategoryTeam
  DataSiloSubjectDeny
  DataPointAction
  DataPointAttributeValue
  DataSiloDependentDataSilo
  EnricherIdentifier
  EnricherAction
  EnricherCrossReferenceIdentifier
  EnricherSubject
  IdentifierSubject
  IdentifierDataSilo
  IdentifierAction
  ProcessingActivityAttributeValue
  ProcessingActivityDataSilo
  ProcessingActivityDataSubCategory
  ProcessingActivityProcessingPurposeSubCategory
  ProcessingActivitySaaSCategory
  ProcessingActivitySubDataPoint
  ProcessingActivitySubject
  ProcessingActivityTeam
  ProcessingActivityUser
  ProfileDataPoint
  RepositoryUser
  RepositoryTeam
  PullRequestUser
  CodePackageUser
  CodePackageTeam
  RequestAttributeValue
  RequestDataSilo
  RequestDataSiloCommunication
  RequestDataSiloRequestIdentifier
  RequestEnricher
  RequestEnricherRequestIdentifier
  RequestIdentifier
  RequestIdentifierProfile
  SubDataPointDataSubCategory
  SubDataPointDataSubCategoryGuess
  SubDataPointProcessingPurposeSubCategory
  SubDataPointAttributeValue
  VendorAttributeValue
  BusinessEntityTeam
  BusinessEntityAttributeValue
  BusinessEntityUser
  DataSubCategoryAttributeValue
  PathfinderPathfinderPolicy
  PathfinderLargeLanguageModel
  PathfinderPolicyDataSubCategory
  PathfinderApplication
  ProcessingPurposeSubCategoryAttributeValue
  SubjectAction
  TeamScope
  UserScope
  UserTeam
  ConsentSdkPurpose
  ExperiencePurpose
  TcfVendorPurpose
  TcfVendorFlexiblePurpose
  TcfVendorLegIntPurpose
  TcfVendorSpecialPurpose
  TcfVendorFeature
  TcfVendorSpecialFeature
  TcfVendorDataCategory
  TcfPurposeStack
  TcfSpecialFeatureStack
  AirgapBundleTcfStack
  PurposeOrgTcfPurpose
  PurposeOrgTcfSpecialFeature
  PromptAppUser
  PromptGroupPrompt
  PromptTeam
  PromptUser
  PromptGroupTeam
  PromptGroupUser
  PromptPartialTeam
  PromptPartialUser
  PromptLargeLanguageModel
  AssessmentFormAssignee
  AssessmentSectionAssignee
  AssessmentQuestionAnswer
  AssessmentFormReviewer
  AssessmentFormTeam
  AssessmentGroupReviewer
  AssessmentEmailSetTemplate
  AssessmentTriggerUser
  PromptAttributeValue
  PromptGroupAttributeValue
  PromptRunAttributeValue
  PromptRunMessageDataSubCategory
  CodePackageSoftwareDevelopmentKit
  SoftwareDevelopmentKitUser
  SoftwareDevelopmentKitTeam
  ScannedObjectAction
  ScannedObjectAttributeValue
  ScannedObjectPathAttributeValue
  ScannedObjectTeam
  ScannedObjectUser
  ScannedObjectPathTeam
  ScannedObjectPathUser
  ContractAttributeValue
  UserAttributeValue
  TeamAttributeValue
  ScopeAttributeValue
  AgentAttributeValue
  ApplicationAttributeValue
  CodePackageAttributeValue
  PathfinderPolicyAttributeValue
  PathfinderAttributeValue
  LargeLanguageModelAttributeValue
  AgentFunctionAttributeValue
  ConsentApplicationAttributeValue
  ConsentServiceAttributeValue
  ConsentSdkAttributeValue
  SoftwareDevelopmentKitAttributeValue
  PullRequestAttributeValue
  RepositoryAttributeValue
  AgentFileAttributeValue
  AppUserAttributeValue
  PathfinderAgent
  LargeLanguageModelRepository
  LargeLanguageModelCodePackage
  PromptCodePackage
  PromptRepository
  DataSiloBusinessEntity
  ConsentWorkflowTriggerDataSilo
  PurposeRequest
  DataPointAirgapPartition
  PreferenceTopicOptionValue
  DataPointLevelAttributeValue
  AssessmentGroupAttributeValue
  AssessmentFormAttributeValue
  LegalHoldAttributeValue
  LegalMatterAttributeValue
  IdentifierAttributeValue
  SubjectAttributeValue
  EnricherAttributeValue
  AuditorRunAttributeValue
  AuditorScheduleAttributeValue
  WorkflowConfigDataSilo
  WorkflowConfigIdentifier
  WorkflowConfigDataPoint
  WorkflowConfigCommunication
  WorkflowConfigEnricher
  WorkflowJobWorkflowJob
  PrivacyCenterChildOrganization
  DataSubCategorySensitiveCategory
  action
  actionItem
  actionItemCollection
  actionItemSubscription
  actionItemRunLock
  application
  appUser
  agent
  agentFile
  agentFunction
  attributeKey
  activity
  airgapBundle
  airgapBundleModule
  airgapBundleConfiguration
  airgapPartition
  consentService
  consentApplication
  consentSdk
  sdk
  softwareDevelopmentKit
  airgapBundleVersion
  airgapCookie
  airgapCookieDomain
  airgapCustomDomain
  airgapDataFlow
  airgapTheme
  airgapSyncEndpoint
  apiKey
  assetFile
  attributeValue
  auditorFinding
  auditorRun
  auditorSchedule
  auditorRunDataFlow
  auditorRunCookie
  backendCache
  configAuditEvent
  catalog
  certificate
  codePackage
  communication
  contract
  contractScan
  cloudfront
  customFunction
  customFunctionVersion
  daemonRun
  databaseIntegrationQuery
  dataPointLevel
  dataSubCategory
  dataCollection
  dataSilo
  dataPoint
  subDataPoint
  unstructuredSubDataPointRecommendation
  scannedObject
  dataReport
  demo
  assessmentAnswer
  assessmentQuestion
  assessmentSection
  assessmentEmailSet
  assessmentFormTemplate
  assessmentFormComment
  assessmentFormExternalAssignee
  assessmentSectionExternalAssignee
  assessmentQuestionComment
  assessmentSectionComment
  assessmentGroup
  assessmentForm
  preference
  assessmentEvent
  assessmentFile
  assessmentTrigger
  assessmentLogic
  assessmentRule
  assessmentRuleOperand
  assessmentTriggerExternalUser
  discoClassScan
  discoClassScanConfig
  emailDomain
  emailLogin
  emailSenderAddress
  EmailSenderAddressAttributeValue
  EmailSenderAddressPrivacyCenter
  enricher
  EnricherDependentEnricher
  FailedLoginAttempt
  featureSet
  featureDefinition
  feature
  formItem
  identifier
  legalHold
  legalMatter
  LegalMatterLegalHold
  lookupProcess
  message
  oauthSession
  organization
  password
  plugin
  policy
  policyVersion
  privacyCenter
  privacyCenterVersion
  profile
  prompt
  promptThread
  promptRun
  promptRunMessage
  pullRequest
  largeLanguageModel
  pathfinder
  pathfinderPolicy
  processingActivity
  promptPartial
  promptGroup
  purpose
  processingPurposeSubCategory
  repository
  request
  requestFile
  saaSCategory
  saaSVendor
  savingsConfiguration
  scanColor
  scope
  seedEnricher
  Session
  signupCode
  scanCookiePurpose
  scanCookieHostPurpose
  scanDomainPurpose
  sombra
  sombraApiKey
  sombraAuditLog
  sombraKey
  subject
  ssoProvider
  ssoProviderDomain
  tcfVendorListVersion
  tcfFeature
  tcfPurpose
  tcfSpecialFeature
  tcfSpecialPurpose
  tcfVendor
  team
  template
  token
  theme
  user
  vendor
  businessEntity
  sitescan
  experience
  consentManagerUi
  shopifyAccessToken
  externalOAuthToken
  tcfVendorUrl
  tcfDataCategory
  tcfStack
  orgTcfPurpose
  orgTcfSpecialFeature
  scannedObjectPath
  requestsProcessedStatsSetting
  retentionSchedule
  consentWorkflowTrigger
  consentWorkflowTriggerPurpose
  workflowConfig
  workflowInstance
  workflowJob
  riskFramework
  riskLevel
  riskCategory
  riskMatrixRow
  riskMatrixColumn
  RiskLevelRiskMatrixRowRiskMatrixColumn
  AssessmentQuestionRiskCategory
  preferenceTopic
  preferenceOptionValue
  sensitiveCategory
  sensitiveObjectCount
  consentSite
}

enum RequestStatus {
  REQUEST_MADE
  FAILED_VERIFICATION
  ENRICHING
  ON_HOLD
  WAITING
  COMPILING
  APPROVING
  DELAYED
  COMPLETED
  DOWNLOADABLE
  VIEW_CATEGORIES
  CANCELED
  SECONDARY
  SECONDARY_COMPLETED
  SECONDARY_APPROVING
  REVOKED
}

enum RegionDetectionMethod {
  DISABLED
  AUTO
  FORM
}

enum RequestDataSiloStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  SKIPPED_DUE_TO_EXCEPTION
}

enum SombraDataSubjectAuthMethod {
  session
  jwt
  oauth
  transcend
  noAuth
}

enum PreflightRequestStatus {
  CANCELED
  ON_HOLD
}

enum UnknownRequestPolicy {
  ALLOW
  REQUIRE_FULL_CONSENT
  BLOCK
}

enum TelemetryPartitionStrategy {
  origin
  path
  url
}

enum ConsentBundleType {
  PRODUCTION
  TEST
}

enum AttributeKeyType {
  MULTI_SELECT
  SINGLE_SELECT
  TEXT
  EMAIL
  TELEPHONE
  URL
  ASSESSMENT
}

enum AttributeSupportedResourceType {
  actionItem
  airgapCookie
  airgapDataFlow
  assessmentForm
  assessmentGroup
  auditorRun
  auditorSchedule
  businessEntity
  dataSubCategory
  dataPoint
  dataPointLevel
  dataSilo
  enricher
  identifier
  legalHold
  legalMatter
  processingActivity
  processingPurposeSubCategory
  prompt
  promptGroup
  promptRun
  request
  scannedObject
  scannedObjectPath
  subject
  subDataPoint
  vendor
}

enum RequestOrigin {
  PRIVACY_CENTER
  ADMIN_DASHBOARD
  API
  SHOPIFY
}

enum InitialViewState {
  QuickOptions
  QuickOptions3
  AcceptAll
  AcceptAllRejectAllToggle
  AcceptAllOrMoreChoices
  AcceptOrRejectAll
  AcceptOrRejectAllOrMoreChoices
  AcceptOrRejectAnalytics
  AcceptOrRejectAdvertising
  NoticeAndDoNotSell
  DoNotSellExplainer
  CompleteOptionsToggles
  PrivacyPolicyNotice
  PrivacyPolicyNoticeWithCloseButton
  CompleteOptions
  CompleteOptionsInverted
  Hidden
  TCF_EU
}

enum DataFlowScope {
  HOST
  PATH
  QUERY_PARAM
  REGEX
  CSP
}

enum PromptFilePurpose {
  ASSISTANTS
  FINE_TUNE
  FINE_TUNE_RESULTS
  ASSISTANTS_OUTPUT
}

enum EnricherType {
  SOMBRA
  email
  phone
  SERVER
  PERSON
  LEGAL_HOLD
  AUTO_APPROVE
  REGEX_MATCH
  REGION_MATCH
  DATABASE
  LOOKER
  WAIT_PERIOD
  GOVERNMENT_ID
  CUSTOM_FUNCTION
}

enum CspOption {
  Strict
  Lax
  On
  Off
}

enum UspapiOption {
  on
  off
}

enum SignedIabAgreementOption {
  yes
  no
  unknown
}

enum RequestEnricherStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  WAITING_ON_DEPENDENCIES
  POLLING
}

enum RegionsOperator {
  IN
  NOT_IN
}

enum RequestActionObjectResolver {
  ACCESS
  ERASURE
  RECTIFICATION
  RESTRICTION
  BUSINESS_PURPOSE
  PLACE_ON_LEGAL_HOLD
  REMOVE_FROM_LEGAL_HOLD
  AUTOMATED_DECISION_MAKING_OPT_OUT
  USE_OF_SENSITIVE_INFORMATION_OPT_OUT
  CONTACT_OPT_OUT
  SALE_OPT_OUT
  TRACKING_OPT_OUT
  CUSTOM_OPT_OUT
  AUTOMATED_DECISION_MAKING_OPT_IN
  USE_OF_SENSITIVE_INFORMATION_OPT_IN
  SALE_OPT_IN
  TRACKING_OPT_IN
  CONTACT_OPT_IN
  CUSTOM_OPT_IN
}

enum SombraEmployeeAuthMethod {
  session
  saml
  transcend
}

enum QueueStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
}

enum Purpose {
  Unknown
  Essential
  Advertising
  Analytics
  Functional
  SaleOfInfo
}

enum ConfigurablePurpose {
  Advertising
  Analytics
  Functional
  SaleOfInfo
}

enum PromptStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  CHANGES_REQUESTED
  REJECTED
  APPROVED
}

enum AssessmentFormStatus {
  DRAFT
  SHARED
  IN_PROGRESS
  IN_REVIEW
  CHANGES_REQUESTED
  REJECTED
  APPROVED
}

enum AssessmentFormTemplateStatus {
  DRAFT
  PUBLISHED
}

enum SubDataPointDataSubCategoryGuessStatus {
  APPROVED
  PENDING
  REJECTED
}

enum TranscendProduct {
  DSR_AUTOMATION
  DATA_INVENTORY
  CONSENT_MANAGEMENT
  PRIVACY_CENTER
  ADMINISTRATION
  ASSESSMENTS
  PATHFINDER
  PREFERENCE_MANAGEMENT
  PROMPT_MANAGER
  CONTRACT_SCANNING
  WEB_AUDITOR
  SOMBRA
  SILO_DISCOVERY
  STRUCTURED_DISCOVERY
  UNSTRUCTURED_DISCOVERY
  DATA_LINEAGE
}

enum PromptRunProductArea {
  assessments
  contractScanning
  promptManager
  unstructuredDiscovery
  dataInventory
  pathfinder
}

enum ConfidenceLabel {
  HIGH
  MEDIUM
  LOW
}

enum PromptResponseFormat {
  text
  json_object
  json_schema
}

enum CodePackageType {
  PACKAGE_JSON
  REQUIREMENTS_TXT
  GRADLE
  COCOA_PODS
  SWIFT
  PUBSPEC
  GEMFILE
  COMPOSER_JSON
}

enum PromptAVendorEmailCompletionLinkType {
  LOGGED_IN_USER
  UNAUTHENTICATED_EXTERNAL_USER
  NO_LINK_MARK_DATAPOINT_AS_RESOLVED
}

enum PromptAVendorEmailSendType {
  PER_DSR
  CROSS_DSR
}

enum LargeLanguageModelClient {
  openai
  claude
  llama
}

enum ActionItemPriorityOverride {
  WONT_DO
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum StaticTeamType {
  ENGINEERING
  DSR_MANAGEMENT
  READ_ONLY
  PRIVACY_CENTER_MANAGEMENT
  ACCESS_CONTROL_MANAGEMENT
  DESIGN
  LEGAL_PRIVACY_OPS
  IT_INFO_SEC
  DATABASE_ADMIN_DATA_ENGINEERING
  CLOUD_INFRA_ARCHITECTURE
  PROJECT_MANAGERS
  MARKETING
  SYSTEM_OWNERS
  FRONTEND_DEVELOPER
}

enum ActionItemCode {
  ACTION_MISSING_SILOS
  API_KEY_STALE
  ASSESSMENT_FORM_ASSIGNED
  ASSESSMENT_FORM_NEEDS_REVIEW
  REQUEST_DATA_SILO_MARKED_ACTIONABLE
  REQUEST_DATA_SILO_FILES_NEED_REVIEW
  COMMUNICATION_UNREAD
  DATA_SILO_COMMUNICATION_UNREAD
  DATA_POINT
  DATA_POINT_MISSING_FIELDS
  DATA_SILO_NEEDS_RECONNECT
  DATA_SILO_NEEDS_RECONNECT_ASSIGNED
  DATA_SILO_NOT_CONFIGURED
  DATA_SILO_NOT_CONFIGURED_ASSIGNED
  DATA_SILO_MISSING_IDENTIFIERS
  LOOKUP_PROCESSES_WITH_ERRORS
  DATA_SILOS_NEEDING_MANUAL_ENTRY
  PROFILE_DATA_POINT_STATUS
  REQUEST_EXPIRY
  REQUEST_DATA_SILO_ERROR
  REQUEST_ENRICHER_ERROR
  REQUEST_IDENTIFIER_NEEDS_VERIFICATION
  REQUEST_ENRICHER_PERSON_NEEDS_MANUAL_ENTRY
  REQUEST_ACTIONABLE_STATUS
  REQUEST_ON_HOLD
  USER_AWAITING_NOTIFICATION
  USER_NEEDS_CONFIGURATION
  SOMBRA_VERSION_UPGRADE
  SOMBRA_NEEDS_KEY_ROTATION
  DATA_FLOW_NEEDS_REVIEW
  DATA_FLOW_ASSIGNED_FOR_REVIEW
  COOKIE_NEEDS_REVIEW
  COOKIE_ASSIGNED_FOR_REVIEW
  CONSENT_MANAGER_VERSION_UPGRADE
  PLUGINS_WITH_ERRORS
  ONBOARDING
  REQUEST_ASSIGNED_TO_USER
  DATA_SILO_NEEDS_TRAINING
  BUSINESS_ENTITY_NEEDS_DOCUMENTATION
  DATA_POINT_DATABASE_QUERY_NEEDS_APPROVAL
}

enum ChatCompletionRole {
  system
  user
  assistant
}

enum CommunicationMessage {
  CANCELATION_SENT
  CONTINUATION_SENT
  REMINDER_SENT
  PROVISIONED_ROLE
  PRIVACY_CENTER_LOGIN
  AUTOMATED_VENDOR_COORDINATION
  REPORT_SENT
  SECONDARY_REPORT_SENT
  IDENTIFIER_VERIFICATION_SENT
  FAILED_VERIFICATION_SENT
  REVOKED_SENT
  RECEIPT_SENT
  ADDITIONAL_TIME_SENT
  ORGANIZATION_TO_DATA_SUBJECT_SENT
  DATA_SUBJECT_TO_ORGANIZATION_SENT
  WAITING_ON_REMOTE_SAAS_RESPONSE
  FAILED_TO_SEND_TO_REMOTE_SAAS
  REPLY_TO_REQUEST_EMAIL
  ACTION_ITEM_REPORT_SENT
  AUTOMATED_VENDOR_COORDINATION_TOKEN_SENT
  PASSWORD_RESET_SENT
  REVIEW_ROPA
  PHONE_MESSAGE_ACCESS
  GOVERNMENT_ID_MESSAGE_ACCESS
  ASSESSMENT_EMAIL
}

enum RetentionScheduleType {
  REQUESTS_CREATED_AT
  ASSESSMENT_FORM_COMPLETED_AT
}

enum RetentionScheduleOperation {
  FULL_DELETE
  PARTIAL_DELETE
  NONE
}

enum BackendSyncOption {
  on
  off
}

enum SombraKMSKeyType {
  JWT_ECDSA_KEY
  KEY_ENCRYPTION_BASE
  HMAC_NONCE_KEY
  HMAC_DATA_SUBJECT_SESSION_KEY
  HMAC_EMPLOYEE_SESSION_KEY
  ECDH_PRIVATE_KEY
  INTERNAL_KEY_HASH
  CONSENT_IDENTIFIER_ENCRYPTION_KEY
  JWT_ECDSA_PUBLIC_KEY
  ECDH_PUBLIC_KEY
  JWT_AUTHENTICATION_PUBLIC_KEY
}

enum AssessmentFormTemplateSource {
  MANUAL
  DATA_INVENTORY
  IMPORT
}

enum SombraKMSProvider {
  local
  AWS
}

enum PreferenceStoreAuthLevel {
  REQUIRED
  OPTIONAL
  ALLOW_OPT_OUT
}

enum UserPrivacySignalEnum {
  GPC
  DNT
}

enum DefaultConsentOption {
  off
  Auto
}

enum SombraKMSKeySource {
  AWS
  SOMBRA
  VAULT
}

enum SombraKMSCanaryValueType {
  HASH
  JWT
  ENCRYPTED_VALUE
}

enum OnPremiseSombraCreationMethod {
  REVERSE_TUNNEL
  DIRECT_CONNECTION
}

enum CustomizableText {
  fontFamilyHeader
  fontFamilyBody
}

enum CustomizableComponent {
  h1
  h2
  h3
  body
  sideMenuText
  primaryButton
  secondaryButton
  emailButton
  emailContainer
  hero
  heroBackground
  takeControlConfirmation
}

enum ColumnEncryptionType {
  ENCRYPTED_APPLICATION_SIDE
  ENCRYPTED_DATA_AT_REST
}

enum AssessmentQuestionSubType {
  NONE
  CUSTOM
  USER
  TEAM
  DATA_SUB_CATEGORY
  PROCESSING_PURPOSE_SUB_CATEGORY
  PROCESSING_ACTIVITY
  VENDOR
  REGION
  BUSINESS_ENTITY
  SAA_S_CATEGORY
  DATA_PROCESSING_AGREEMENT_STATUS
  DEPRECATION_STATE
  IDENTIFIER
  DATA_SILO
  RECOMMENDED_FOR_CONSENT
  RECOMMENDED_FOR_PRIVACY
  SUBJECT
  RETENTION_TYPE
  CONTROLLERSHIP
  HAS_PERSONAL_DATA
  ATTRIBUTE_KEY
}

enum AssessmentQuestionType {
  LONG_ANSWER_TEXT
  SHORT_ANSWER_TEXT
  SINGLE_SELECT
  MULTI_SELECT
  FILE
  DESCRIPTION
}

enum AssessmentSyncColumn {
  TITLE
  SLUG
  DESCRIPTION
  HEADQUARTER_COUNTRY
  CONNECTION_STATE
  CONNECT_START_TIME
  CONTACT_EMAIL
  CONTACT_NAME
  COUNTRY
  COUNTRY_SUB_DIVISION
  CREDENTIALS_REFRESH_SCHEDULED_AT
  DATA_PROCESSING_AGREEMENT_LINK
  DATA_PROCESSING_AGREEMENT_STATUS
  DATA_RETENTION_NOTE
  DEFAULT_ACCESS_REQUEST_VISIBILITY
  DELETED_AT
  DEPRECATION_STATE
  EMAIL_SENDING_LOCK
  EXPIRED_AT
  EXTERNAL_ID
  HAS_PERSONAL_DATA
  HEADERS
  IS_LIVE
  LAST_CONNECTED_AT
  LAST_ENABLED_AT
  LAST_LOOKUP_PROCESS_CREATION_TIME
  MANUAL_WORK_RETRY_FREQUENCY
  MANUAL_WORK_RETRY_START_AT
  NOTES
  NOTIFY_EMAIL_ADDRESS
  NOTIFY_WEBHOOK_URL
  OUTER_TYPE
  PLAINTEXT_CONTEXT
  PROMPT_A_VENDOR_EMAIL_COMPLETION_LINK_TYPE
  PROMPT_A_VENDOR_EMAIL_INCLUDE_IDENTIFIERS_ATTACHMENT
  PROMPT_A_VENDOR_EMAIL_SCHEDULED_AT
  PROMPT_A_VENDOR_EMAIL_SEND_FREQUENCY
  PROMPT_A_VENDOR_EMAIL_SEND_TYPE
  PROMPT_A_VENDOR_EMAIL_START_AT
  RECOMMENDED_FOR_CONSENT
  RECOMMENDED_FOR_PRIVACY
  RECONNECT_FORM_ITEMS
  SAAS_CONTEXT
  SECRET_HEADERS
  SUBDOMAIN
  TYPE
  URL
  WEBSITE_URL
  TRANSFER_REGIONS
  CONTROLLERSHIPS
  NAME
  DATA_POINT_ID
  ENCRYPTED_SAMPLES_S3_KEY
  ACCESS_REQUESTED_VISIBILITY_ENABLED
  ENSURE_REQUEST_REDACTION_ENABLED
  LAST_CLASSIFIED_AT
  LAST_RUN_AT
  ERROR
  ERROR_COUNT
  CONTEXT
  CONTENT_CLASSIFICATION_STATUS
  NON_NULL_CHECK_COMPLETED
  CONTROLLERSHIP
  RETENTION_TYPE
  RETENTION_PERIOD
  SCAN_RUN_ID
  CONTACT_PHONE
  ADDRESS
  HEADQUARTER_SUB_DIVISION
  PRIVACY_POLICY_URL
  CATEGORY
  IS_DEFAULT
  REGEX
  PURPOSE
  DATA_PROTECTION_OFFICER_EMAIL
  DATA_PROTECTION_OFFICER_NAME
  DATA_TYPE
  ENCRYPTION
  IS_PRIMARY_KEY
  CUSTOM_SILO_CONNECTION_STRATEGY
  SECURITY_MEASURE_DETAILS
  STORAGE_REGIONS
  DATA_PROTECTION_IMPACT_ASSESSMENT_LINK
  DATA_PROTECTION_IMPACT_ASSESSMENT_STATUS
}

enum AssessmentSyncModel {
  dataSilo
  subDataPoint
  vendor
  dataSubCategory
  processingPurposeSubCategory
  businessEntity
  processingActivity
}

enum PreferenceTopicType {
  SELECT
  MULTI_SELECT
  BOOLEAN
}

enum ComparisonOperator {
  IS_EQUAL_TO
  IS_NOT_EQUAL_TO
  IS_ONE_OF
  IS_NOT_ONE_OF
  CONTAINS
  IS_SHOWN
  IS_NOT_SHOWN
}

enum AssessmentsDisplayLogicAction {
  SHOW
  SKIP
}

enum LogicOperator {
  AND
  OR
}

enum TableEncryptionType {
  UNENCRYPTED
  ENCRYPTED_APPLICATION_SIDE
  ENCRYPTED_DATA_AT_REST
}

enum AirgapBundleType {
  DEPLOYED
  DEPLOY_PENDING
  PREVIEW
  ROLLBACK_PENDING
  ERROR
  TEST_ERROR
}

enum IabAgreement {
  LSPA
  MSPA
}

enum IABSignal {
  GPP_USP
}

enum ModuleKind {
  ui
  plugin
  policies
}

enum ConsentExpiryBehavior {
  Prompt
  ResetOptIns
  Reset
}

enum TrackerOverrideModule {
  FacebookLDU
  GoogleAdsRDP
  GoogleConsentMode
  VimeoDNT
  WistiaDNT
  YouTubePrivacyEnhancedMode
}

enum CodePackageOrderField {
  name
  createdAt
  updatedAt
}

enum PullRequestOrderField {
  title
  createdAt
  updatedAt
}

enum RepositoryOrderField {
  name
  createdAt
  updatedAt
}

enum SoftwareDevelopmentKitOrderField {
  name
  createdAt
  updatedAt
}

enum AttributeKeyOrderField {
  name
  createdAt
  updatedAt
  isCustom
}

enum AssessmentSecondaryType {
  URL
  ASSESSMENT
  STATUS
}

enum AssessmentAttributeStatus {
  NOT_NEEDED
  NEEDED
}

enum AttributeValueOrderField {
  name
  createdAt
  updatedAt
}

enum AgentOrderField {
  name
  createdAt
  updatedAt
}

enum AgentFileOrderField {
  name
  purpose
  createdAt
  updatedAt
}

enum AgentFunctionOrderField {
  name
  createdAt
  updatedAt
}

enum ApplicationOrderField {
  name
  createdAt
  updatedAt
}

enum ApplicationUserOrderField {
  name
  coreIdentifier
  createdAt
  updatedAt
}

enum LargeLanguageModelOrderField {
  name
  client
  isTranscendHosted
  createdAt
  updatedAt
}

enum PathfinderOrderField {
  name
  url
  createdAt
  updatedAt
}

enum PathfinderPolicyType {
  REJECT
  ANONYMIZE
}

enum PathfinderPolicyOrderField {
  name
  type
  createdAt
  updatedAt
}

enum PromptOrderField {
  title
  createdAt
  updatedAt
}

enum PromptGroupOrderField {
  title
  createdAt
  updatedAt
}

enum PromptPartialOrderField {
  title
  createdAt
  updatedAt
}

enum PromptRunOrderField {
  name
  createdAt
  updatedAt
}

enum PromptThreadOrderField {
  threadId
  createdAt
  updatedAt
}

enum ContractOrderField {
  name
  createdAt
  updatedAt
}

enum ContractScanStatus {
  ERROR
  IN_PROGRESS
  DONE
}

enum ContractScanOrderField {
  name
  createdAt
  updatedAt
}

enum OnConsentExpiry {
  Prompt
  ResetAll
  ResetOptIns
}

enum ConsentPrecedenceOption {
  user
  signal
}

enum BundleDeployStatus {
  DEPLOYED
  DEPLOY_PENDING
  PREVIEW
  ROLLBACK_PENDING
  ERROR
  TEST_ERROR
}

enum AirgapCdn {
  CLOUDFLARE
  CLOUDFRONT
}

enum AirgapIssueSeverityGQL {
  MODERATE
  HIGH
}

enum CustomDomainStatus {
  ACTIVE
  DEACTIVATED
  DELETED
}

enum CookieOrderField {
  name
  createdAt
  updatedAt
}

enum DataFlowType {
  URL
  QUERY_PARAM
  REGEX
}

enum DataFlowOrderField {
  value
  createdAt
  updatedAt
  occurrences
  service
}

enum DateRange {
  SevenDays
  ThirtyDays
  OneYear
}

enum ExperienceOrderField {
  isActive
  name
  createdAt
  updatedAt
  displayPriority
}

enum TranscendConsentManagerUI {
  ui
  tcfUi
}

enum TranscendConsentManagerScript {
  ui
  tcfUi
  gpp
}

enum CommunicationType {
  EMAIL
  PHONE
  PUSH
}

enum SupportedConditionals {
  Or
  And
}

enum PreferenceStoreCategoryType {
  PURPOSE
  IDENTIFIER
}

enum InvertedPreferenceStoreCategoryType {
  Purpose
  Identifier
}

enum PurposeOrderField {
  isActive
  name
  createdAt
  updatedAt
}

enum ConsentEvent {
  CONSENT_CHANGED
}

enum TrafficEvent {
  OUTGOING_REQUEST
  COOKIE_MUTATION
  COOKIE_MATCHER_MUTATION
  PATH_MATCHER_REQUEST
  PATH_REQUEST
  PAGE_VIEWS
  SITE_SESSIONS
  BOUNCES
  TELEMETRY_REQUESTS
  INITIAL_SITE_SESSION_CONSENT
}

enum RegimeEvent {
  REGIME_DETECTED
}

enum SignalEvent {
  SIGNAL_DETECTED
  INITIAL_SESSION_SIGNAL
}

enum TrackingPurposeStatsEvent {
  TRACKING_PURPOSE_STATS
}

enum AnalyticsEvent {
  CONSENT_CHANGED
  OUTGOING_REQUEST
  COOKIE_MUTATION
  COOKIE_MATCHER_MUTATION
  PATH_MATCHER_REQUEST
  PATH_REQUEST
  PAGE_VIEWS
  SITE_SESSIONS
  BOUNCES
  TELEMETRY_REQUESTS
  INITIAL_SITE_SESSION_CONSENT
  REGIME_DETECTED
  SIGNAL_DETECTED
  INITIAL_SESSION_SIGNAL
  TRACKING_PURPOSE_STATS
}

enum AnalyticsDimension {
  REGIME
  SIGNAL
  SIGNAL_GPC
  SIGNAL_DNT
  COOKIE
  HOST
  PATH
  PURPOSE
  PURPOSE_DEFAULT_CONSENT_VALUE
  PURPOSE_CURRENT_CONSENT_VALUE
  NEW_VALUE
  WAS_ALLOWED
  CONSENT_MANAGER_ID
  ENCOUNTERED_AT
  MOBILE_APP_ID
  REGEX
  MAX_AGE
  SAMPLING_RATE
  CLIENT_SAMPLING_RATE
  BACKEND_SAMPLING_MULTIPLIER
}

enum ClassificationMethod {
  CUSTOM_REGEX_CLASSIFY
  TRANSCEND_LLM_CLASSIFY
  VECTORIZED_ML_CLASSIFY
  PROPERTY_NAME_MATCH
  LLM_API
}

enum SombraClassificationMethod {
  CUSTOM_REGEX_CLASSIFY
  TRANSCEND_LLM_CLASSIFY
}

enum UnstructuredClassificationMethod {
  CUSTOM_REGEX_CLASSIFY
  TRANSCEND_LLM_CLASSIFY
  MANUAL
}

enum UnstructuredSubDataPointRecommendationStatus {
  MANUALLY_ADDED
  CORRECTED
  VALIDATED
  CLASSIFIED
  REJECTED
}

enum ActionOrderField {
  createdAt
  updatedAt
  type
}

enum PostCompileStatus {
  VIEW_CATEGORIES
  DOWNLOADABLE
}

enum AssessmentQuestionFileType {
  json
  pdf
  xml
  rtf
  jpeg
  csv
  png
  txt
  html
  docx
}

enum StaticAssessmentQuestionSubType {
  REGION
  DATA_PROCESSING_AGREEMENT_STATUS
  DEPRECATION_STATE
  RECOMMENDED_FOR_CONSENT
  RECOMMENDED_FOR_PRIVACY
  RETENTION_TYPE
  CONTROLLERSHIP
  HAS_PERSONAL_DATA
}

enum DynamicAssessmentQuestionSubType {
  BUSINESS_ENTITY
  DATA_SILO
  DATA_SUB_CATEGORY
  IDENTIFIER
  PROCESSING_PURPOSE_SUB_CATEGORY
  SUBJECT
  SAA_S_CATEGORY
  TEAM
  USER
  VENDOR
  ATTRIBUTE_KEY
  PROCESSING_ACTIVITY
}

enum AssessmentTriggerAction {
  SEND_TARGET_ASSESSMENT
}

enum AssessmentTriggerEvent {
  ON_SUBMISSION
  ON_APPROVAL
}

enum BusinessEntityOrderField {
  title
  createdAt
  updatedAt
}

enum IntegrationStatus {
  BETA
  ONLINE
}

enum PlaintextReasonStaticType {
  RETRIEVE_QUERY_METADATA
  SEEDING
  TESTING
  ERROR_HANDLING
  RESOLVE_IDENTIFIERS
  PAGINATION
  CONFIRM_SUCCESS
  REFRESH_ACCESS_TOKEN
  DISCO_IDENTIFIERS
  DISCO_METADATA
  SCHEMA_DISCOVERY_METADATA
  UNSTRUCTURED_DATA_DISCOVERY_METADATA
  UNSTRUCTURED_DATA_SAMPLING_METADATA
}

enum PrivacyRequestConnectionStatus {
  CONNECTED
  PENDING_CONNECTION
  VERY_LIKELY
  LIKELY
  POSSIBLE
  NOT_RECOMMENDED
  UNDETERMINED
}

enum ConsentManagerConnectionStatus {
  REGULATED
  PARTIALLY_REGULATED
  DETECTED
  PENDING_REGULATION
  VERY_LIKELY
  POSSIBLE
  NOT_RECOMMENDED
  UNDETERMINED
}

enum HasPersonalDataStatus {
  YES
  LIKELY
  UNLIKELY
  NO
  UNSPECIFIED
}

enum ConnectorType {
  AVC
  API
}

enum CatalogOrderField {
  title
  createdAt
  updatedAt
  integrationName
}

enum DataCollectionStaticType {
  APP_USAGE
  CALL_HISTORY
  CONTACT_INFO
  CONNECTION
  DEMOGRAPHIC
  DEVICE_INFORMATION
  FINANCIAL
  INTERESTS
  IP_ADDRESS
  LOCATION
  HEALTH
  MESSAGES
  ONLINE_ACTIVITY
  PROFILE_PICTURE
  PERSONAL_IDENTIFIER
  SOCIAL_MEDIA
  SEARCH_HISTORY
  SURVEY
  SITES
  STORE_VISITS
  TRACKING
  USER_PROFILE
  UNASSIGNED
}

enum ErasureRedactionMethod {
  REQUIRED_REVIEW
  AUTO_REDACT_IDENTIFIERS_ONLY
  AUTO_REDACT_ENTIRE_MESSAGE
}

enum DataPointExportMode {
  FULL_DATA
  COUNTS_ONLY
  REDACTED
}

enum DataPointOrderField {
  createdAt
  updatedAt
  title
  name
}

enum DataPointCreatedBy {
  SCHEMA_DISCOVERY
  MANUAL
  HARD_CODED
}

enum ContentClassificationDataPointOrderField {
  totalSubDataPointsCount
  confirmedSubDataPointsPercent
  name
}

enum DataReportExportableTables {
  DATA_INVENTORY_DATA_SILOS
  DATA_INVENTORY_DATA_POINTS
  DATA_INVENTORY_VENDORS
  DATA_INVENTORY_DATA_CATEGORIES
  DATA_INVENTORY_PURPOSES
  DATA_INVENTORY_BUSINESS_ENTITIES
}

enum DataReportRawOrderField {
  title
}

enum DisconnectedSiloState {
  EXPIRED
  NOT_CONFIGURED
}

enum NotDisconnectedSiloState {
  CONNECTED
  PERMISSIONS_UPDATED
  PARTIAL
  INDEXING
}

enum DataSiloConnectionState {
  EXPIRED
  NOT_CONFIGURED
  CONNECTED
  PERMISSIONS_UPDATED
  PARTIAL
  INDEXING
}

enum DataSiloDiscoPluginRecommendationStatus {
  PENDING
  IGNORED
}

enum DataSiloBulkPreviewOrderField {
  title
  createdAt
  updatedAt
  totalObjects
  sensitiveObjects
}

enum DataSiloDeprecationState {
  IN_USE
  DEPRECATED
  IMPLEMENTATION
}

enum DataSiloNullableFilters {
  OWNERS
}

enum CustomSiloConnectionStrategy {
  WEBHOOK
  CUSTOM_FUNCTION
}

enum SimplifiedPluginStatus {
  ACTIVE
  DISCONNECTED
  DISABLED
  NOT_CONFIGURED
  ERROR
}

enum DataSubjectClass {
  END_USER
  EMPLOYEE
  BUSINESS_CONTACT
  OTHER
}

enum DiscoClassScanType {
  SCHEMA_ONLY
  FULL_SCAN
  CLASSIFICATION_ONLY
}

enum DiscoClassScanStatus {
  IN_PROGRESS
  PAUSED
  COMPLETE
  DISCONNECTED
  ERROR
  STOPPED
}

enum DiscoClassScanAction {
  START
  PAUSE
  RESUME
  STOP
}

enum EnricherOrderField {
  title
  createdAt
  updatedAt
}

enum FormType {
  boolean
  group
  string
  array
  select
  textArea
  password
  SelectApiKeys
  SelectUsers
  SelectTeams
  SelectTemplate
}

enum SiloFormType {
  OAUTH
  STANDARD
}

enum SnippetLanguage {
  js
  json
}

enum ModeOption {
  tags
  multiple
  combobox
}

enum IdentifierOrderField {
  name
  createdAt
  updatedAt
}

enum IncludeNotPersonalData {
  YES
  NO
}

enum IntegrationCategory {
  ADVERTISING_AND_MARKETING
  ANALYTICS_AND_BUSINESS_INTELLIGENCE
  COLLABORATION_AND_PRODUCTIVITY
  COMPUTING_INFRASTRUCTURE
  CONTENT_AND_MEDIA
  CUSTOMER_SUPPORT_AND_EXPERIENCE
  DATABASES_AND_STORAGE
  ECOMMERCE_AND_RETAIL
  FINANCE_AND_PAYMENTS
  HR_AND_WORKFORCE
  SALES_AND_CRM
  SECURITY_AND_COMPLIANCE
  SOFTWARE_DEVELOPMENT_AND_DEVOPS
  TRANSCEND_CUSTOM
  OTHER
}

enum LookupProcessOrderField {
  name
  createdAt
  updatedAt
  processConfigName
  indexedThrough
}

enum LookupProcessStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  INACTIVE
}

enum LookupProcessStatusSuccess {
  RESOLVED
  SKIPPED
}

enum LookupProcessAlgorithm {
  CHRONOLOGICAL
  REVERSE_CHRONOLOGICAL
}

enum PluginQueueStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
}

enum PluginQueueStatusSuccess {
  RESOLVED
  SKIPPED
}

enum ContentClassificationStatus {
  UNCLASSIFIED
  REFETCH_SAMPLES
  REFETCH_SAMPLES_FILTER_NOT_NULL
  ERROR
  NON_RETRYABLE_ERROR
  REMOTE_PROCESSING
  NO_SAMPLE_DATA
  CLASSIFIED
}

enum UnstructuredDataSamplingStatus {
  UNSAMPLED
  REFETCH_SAMPLES
  ERROR
  NON_RETRYABLE_ERROR
  REMOTE_PROCESSING
  NO_SAMPLE_DATA
  SAMPLED
  SKIP_SAMPLING
  NOT_SUPPORTED
}

enum StructuredDiscoveryPluginType {
  SCHEMA_DISCOVERY
  CONTENT_CLASSIFICATION
}

enum UnstructuredDiscoveryPluginType {
  UNSTRUCTURED_DATA_DISCOVERY
  UNSTRUCTURED_DATA_SAMPLING
}

enum ClassificationPluginType {
  CONTENT_CLASSIFICATION
  UNSTRUCTURED_DATA_SAMPLING
}

enum MetadataDiscoveryPluginType {
  SCHEMA_DISCOVERY
  UNSTRUCTURED_DATA_DISCOVERY
}

enum DataSiloScanType {
  STRUCTURED_DISCOVERY
  UNSTRUCTURED_DISCOVERY
}

enum DiscoClassPluginType {
  CONTENT_CLASSIFICATION
  UNSTRUCTURED_DATA_SAMPLING
  SCHEMA_DISCOVERY
  UNSTRUCTURED_DATA_DISCOVERY
}

enum ScanType {
  FULL_SCAN
  DELTA_UPDATE_SCAN
  TARGETED_SCAN
}

enum ScanLambdaStatus {
  RETRY
  SUCCESS
  ERROR
  SILO_CREDENTIALS_EXPIRED
  SILO_PERMISSIONS_UPDATED
  SKIPPED
  IN_PROGRESS
}

enum DataPointTypeDisplayName {
  ATTRIBUTE
  BUCKET
  CATALOG
  COLLECTION
  COLLECTION_FIELD
  COLUMN
  CONTACT
  CUSTOM_AUDIENCE
  DATA_POINT
  DATA_SOURCE
  DATABASE
  DATASET
  ENVIRONMENT
  FIELD
  FORM
  ISSUE_TYPE
  ISSUE_FIELD
  KEY
  LIST
  OBJECT
  ORGANIZATION
  PROFILE
  PROJECT
  PROPERTY
  QUESTION
  RECORD
  RESOURCE
  SEGMENT
  SCHEMA
  SUB_DATA_POINT
  TABLE
  TABLE_ATTRIBUTE
  USER_LIST
}

enum ScanObject {
  CATALOG
  COLLECTION
  DATABASE
  DATASET
  DATA_SOURCE
  ISSUE_TYPE
  KEY
  PROJECT
  RECORD_TYPE
  SCHEMA
  TABLE
}

enum ProcessingActivityOrderField {
  title
  createdAt
  updatedAt
}

enum DataProtectionImpactAssessmentStatus {
  LINK
  NOT_REQUIRED
  MISSING
}

enum SaaSCategoryOrderField {
  title
  createdAt
  updatedAt
}

enum SdkOrderField {
  name
  createdAt
  updatedAt
}

enum StepStatus {
  wait
  process
  finish
  error
}

enum RefetchSampleMethod {
  DEFAULT
  FILTER_NON_NULL
}

enum Controllership {
  CONTROLLER
  PROCESSOR
  JOINT_CONTROLLER
}

enum RetentionType {
  STATED_PERIOD
  LIMITED
  INDEFINITE
  OTHER
  UNSPECIFIED
}

enum SubDataPointClassificationStatus {
  CONFIRMED
  UNCONFIRMED
  UNCATEGORIZED
}

enum SubDataPointSubCategorySource {
  UNKNOWN
  MANUAL
  AUTO_APPROVED
  CONTENTFUL
}

enum DefaultTemplateType {
  receiptTemplate
  notFoundTemplate
  additionalTimeTemplate
  revokedTemplate
  cancelationTemplate
  emailLoginTemplate
  externalBulkRequestVendorCoordination
  governmentIdMessageTemplate
}

enum TemplateOrderField {
  title
  createdAt
  updatedAt
}

enum TemplateType {
  EMAIL
  TEXT
}

enum TemplateProduct {
  DSR
  ASSESSMENT
}

enum AssessmentActionType {
  FORM_ASSIGNED
  SECTIONS_ASSIGNED
  IN_REVIEW
  APPROVED
  REJECTED
  FORM_CHANGES_REQUESTED
  SECTIONS_CHANGES_REQUESTED
}

enum UnstructuredSubDataPointRecommendationOrderField {
  name
}

enum VendorOrderField {
  title
  createdAt
  updatedAt
}

enum DataProcessingAgreementStatus {
  ONLINE_DPA
  CUSTOM_DPA
  REQUIRES_UPDATE
  NOT_REQUIRED
  MISSING
}

enum ActivityCode {
  REQUEST_DATA_SILO_ERROR
  REQUEST_DATA_SILO_ACTION_REQUIRED
  REQUEST_DATA_SILO_WAITING
  REQUEST_DATA_SILO_QUEUED
  REQUEST_DATA_SILO_REMOTE_PROCESSING
  REQUEST_DATA_SILO_RESOLVED
  REQUEST_DATA_SILO_SKIPPED
  REQUEST_DATA_SILO_SKIPPED_DUE_TO_EXCEPTION
  REQUEST_FILE_ARCHIVED
  REQUEST_FILE_ENCRYPTED_MODIFIED
  REQUEST_FILE_ENCRYPTED_COPY
  REQUEST_FILE_QUEUED
  REQUEST_FILE_REMOTE_PROCESSING
  REQUEST_FILE_WAITING
  REQUEST_FILE_ERROR
  REQUEST_FILE_RESOLVED
  REQUEST_FILE_SKIPPED
  REQUEST_FILE_POLLING
  REQUEST_FILE_ACTION_REQUIRED
  PROFILE_DATA_POINT_QUEUED
  PROFILE_DATA_POINT_ACTION_REQUIRED
  PROFILE_DATA_POINT_REMOTE_PROCESSING
  PROFILE_DATA_POINT_WAITING
  PROFILE_DATA_POINT_WAITING_ON_DELETION_DEPENDENCIES
  PROFILE_DATA_POINT_WAITING_ON_OTHER_REQUESTS
  PROFILE_DATA_POINT_ERROR
  PROFILE_DATA_POINT_RESOLVED
  PROFILE_DATA_POINT_POLLING
  PROFILE_DATA_POINT_FINISHED
  PROFILE_DATA_POINT_SKIPPED
  PROFILE_DATA_POINT_MANUAL
  PROFILE_DATA_POINT_SKIPPED_DUE_TO_EXCEPTION
  REQUEST_ENRICHER_CREATED
  REQUEST_ENRICHER_POLLING
  REQUEST_ENRICHER_QUEUED
  REQUEST_ENRICHER_ACTION_REQUIRED
  REQUEST_ENRICHER_WAITING
  REQUEST_ENRICHER_WAITING_ON_DEPENDENCIES
  REQUEST_ENRICHER_ERROR
  REQUEST_ENRICHER_RESOLVED
  REQUEST_ENRICHER_SKIPPED
  REQUEST_ENRICHER_REMOTE_PROCESSING
  REQUEST_IDENTIFIER_CREATED
  REQUEST_IDENTIFIER_VERIFIED
  REQUEST_IDENTIFIER_INVALIDATED
  REQUEST_IDENTIFIER_EXPIRED
  REQUEST_IDENTIFIER_EXPLICITLY_INVALIDATED
  REQUEST_ENRICHER_RESOLVED_REQUEST_IDENTIFIER
  COMMUNICATION_MESSAGE_SENT
  COMMUNICATION_MESSAGE_RECEIVED
  LOOKUP_PROCESS_QUEUED
  LOOKUP_PROCESS_ACTION_REQUIRED
  LOOKUP_PROCESS_WAITING
  LOOKUP_PROCESS_ERROR
  LOOKUP_PROCESS_RESOLVED
  LOOKUP_PROCESS_SKIPPED
  LOOKUP_PROCESS_INACTIVE
  LOOKUP_PROCESS_REMOTE_PROCESSING
  PROFILE_CREATED
  PROFILES_DESTROYED
  REQUEST_REQUEST_MADE
  REQUEST_FAILED_VERIFICATION
  REQUEST_ENRICHING
  REQUEST_ON_HOLD
  REQUEST_WAITING
  REQUEST_COMPILING
  REQUEST_APPROVING
  REQUEST_DELAYED
  REQUEST_DOWNLOADABLE
  REQUEST_VIEW_CATEGORIES
  REQUEST_COMPLETED
  REQUEST_CANCELED
  REQUEST_SECONDARY
  REQUEST_SECONDARY_APPROVING
  REQUEST_SECONDARY_COMPLETED
  REQUEST_REVOKED
  REQUEST_ARCHIVED
  REPORT_OPENED
  REPORT_DOWNLOADED
}

enum ActivityOrderField {
  createdAt
  updatedAt
}

enum LegalHoldOrderField {
  value
  createdAt
  updatedAt
}

enum LegalMatterOrderField {
  title
  createdAt
  updatedAt
}

enum MockDataSubjectClass {
  END_USER
  EMPLOYEE
  BUSINESS_CONTACT
  OTHER
}

enum ProfileDataPointStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  MANUAL
  WAITING_ON_DELETION_DEPENDENCIES
  POLLING
  WAITING_ON_OTHER_REQUESTS
  SKIPPED_DUE_TO_EXCEPTION
  FINISHED
}

enum ProfileDataPointStatusSuccess {
  RESOLVED
  FINISHED
  SKIPPED
  SKIPPED_DUE_TO_EXCEPTION
}

enum CustomFunctionStatus {
  CUSTOM_FUNCTION_RETURNED
}

enum ProfileDataPointQueueType {
  PRIMARY
  SECONDARY
}

enum ProfileDataPointOrderField {
  createdAt
  updatedAt
}

enum RequestOrderField {
  createdAt
  updatedAt
  id
  timeRemaining
}

enum RequestHistoryOrderField {
  createdAt
  updatedAt
}

enum RequestDataSiloStatusSuccess {
  RESOLVED
  SKIPPED
  SKIPPED_DUE_TO_EXCEPTION
}

enum VisualRequestDataSiloStatus {
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  SKIPPED_DUE_TO_EXCEPTION
  WAITING_ON_DEPENDENCIES
  WAITING_ON_OTHER_REQUESTS
  DATA_SILO_DISCONNECTED
  REQUEST_PENDING
  REQUEST_CANCELED
  MANUAL
}

enum UpdateRequestDataSiloStatus {
  WAITING
  RESOLVED
  ACTION_REQUIRED
  SKIPPED
  SKIPPED_DUE_TO_EXCEPTION
}

enum RequestDataSiloQueueType {
  PRIMARY
  PRIMARY_WITH_WIPE
}

enum RequestDataSiloOrderField {
  createdAt
  updatedAt
  title
}

enum RequestDataSiloSortAssociation {
  dataSilo
}

enum RequestDataSiloConnectionStatus {
  DIRECTLY_CONNECTED
  CHILD_CONNECTED
  CAN_CONNECT
  SHOULD_CONNECT
  NO_CONNECTION
}

enum RequestEnricherStatusSuccess {
  RESOLVED
  SKIPPED
}

enum RequestEnricherOrderField {
  createdAt
  updatedAt
  title
  status
}

enum RequestEnricherSortAssociation {
  enricher
}

enum RequestFileStatus {
  ENCRYPTED_COPY
  MANUAL
  QUEUED
  WAITING
  SKIPPED
  ERROR
  RESOLVED
  ACTION_REQUIRED
  REMOTE_PROCESSING
  POLLING
}

enum RequestFileStatusSuccess {
  RESOLVED
  ENCRYPTED_COPY
  SKIPPED
}

enum RequestFileQueueType {
  SECONDARY
  REDACT
  DISCLUDE
}

enum RequestFileOrderField {
  createdAt
  updatedAt
  size
  status
  id
}

enum DownloadFileOrderField {
  createdAt
  updatedAt
  size
}

enum RequestIdentifierOrderField {
  name
  createdAt
  updatedAt
}

enum RequestIdentifierSource {
  INPUT
  ENRICHER
  DATA_SILO
}

enum CollectDataSubjectRegions {
  DO_NOT_COLLECT
  AUTO_DETECT
  COLLECT
}

enum MissingIdBehavior {
  SKIP
  CANCEL
  NOTIFY
}

enum WorkflowCommunicationMethod {
  EMAIL
}

enum WorkflowCommunicationTemplateType {
  ACTIONS_RECEIPT
  ACTIONS_SUCCESS
  ACTIONS_NOT_FOUND
  ACTIONS_SECONDARY
  OTHER
}

enum WorkflowConfigStatus {
  ENABLED
  DISABLED
}

enum WorkflowInstanceStatus {
  INITIALIZED
  IN_PROGRESS
  WAITING_FOR_NEXT_PHASE
  CANCELED
  AWAITING_INTERACTION
  PAUSED
  IN_PROGRESS_WITH_ERRORS
  COMPLETED_SUCCESSFULLY
  COMPLETED_WITH_ERRORS
}

enum WorkflowJobDestinationModelName {
  RequestEnricher
  ProfileDataPoint
  RequestDataSilo
}

enum WorkflowJobStatus {
  WAITING
  QUEUED
  SUCCESS
  ERROR
  SENT_TO_SECONDARY_QUEUE
  AWAITING_EXTERNAL_RESPONSE
  AWAITING_INTERACTION
  SKIPPED
  POLLING
}

enum WorkflowPhase {
  INITIALIZATION
  VERIFICATION
  ENRICHMENT
  DATAPOINT_ACTION
  JOBS_COMPLETED
}

enum WorkflowPhasesWithJobs {
  VERIFICATION
  ENRICHMENT
  DATAPOINT_ACTION
}

enum WorkflowStepCompletionState {
  COMPLETED
  NOT_COMPLETED
}

enum WorkflowTrigger {
  REQUEST
}

enum AssetFileOrderField {
  createdAt
  updatedAt
  size
}

enum CertificateStatus {
  PENDING_VALIDATION
  ISSUED
  INACTIVE
  EXPIRED
  VALIDATION_TIMED_OUT
  REVOKED
  FAILED
}

enum PageType {
  MANAGE_YOUR_PRIVACY
  COMMUNICATIONS_PREFERENCES
  DATA_PRACTICES
  POLICIES
  TRACKING_TECHNOLOGIES
  REQUESTS_PROCESSED_REPORTING
  SALE_OF_INFO
}

enum PolicyType {
  PRIVACY_POLICY
  COOKIE_POLICY
  CUSTOM
}

enum PrivacyCenterType {
  DEPLOYED
  PREVIEW
}

enum PrivacyCenterAssetName {
  logo
  favicon
  logoOnSolid
  hero
  widgetBg
}

enum PrivacyCenterEmailLoginState {
  SALES_OPT_OUT
}

enum RequestsProcessedDisclosureStatsTableHeaders {
  received
  processed
  denied
  medianNumberOfDays
}

enum SkipLinkIds {
  navigation
  sidebar
  main
}

enum ScanDomainPurposeOrderField {
  domain
}

enum ScanCookiePurposeOrderField {
  cookie
}

enum SitescanStatus {
  STARTED
  DONE
}

enum ActionItemSubscriptionNotificationMethod {
  EMAIL
  SLACK
}

enum ApiKeyOrderField {
  title
  createdAt
  updatedAt
  lastUsedAt
}

enum ApiKeyStatus {
  fresh
  warning
  stale
}

enum EmailDomainVerificationStatus {
  Success
  Failed
  Pending
  TemporaryFailure
  NotStarted
}

enum ExternalOauthServiceCode {
  SLACK_NOTIFICATIONS
}

enum FeatureStatus {
  BETA
  ALPHA
  GENERAL_AVAILABILITY
}

enum FeatureType {
  BOOLEAN
  FEATURE_GATE
  NUMBER
  STRING_LIST
  SUPPORT_TIER
}

enum FeatureDefinitionName {
  ACTION_ITEM_CHECKLISTS
  AIRGAP_ALLOWED_VERSION_TAGS
  ALLOW_PRIVATE_DOCKER_REGISTRY_ACCESS
  ASSESSMENTS
  AUDITOR_MONTHLY_USAGE_LIMIT
  CONSENT_WORKFLOWS
  CONTRACT_SCANNING
  CUSTOM_DOMAIN_UI
  DATA_LINEAGE
  DISABLED_PRIVACY_CENTER_ABOUT_TRANSCEND
  DISCO_CLASS_SCAN
  DSR_AUTOMATION
  IS_SANDBOX
  LLM_CLASSIFIER
  LLM_UNSTRUCTURED
  MAX_SYNC_DOMAIN_COUNT
  MOBILE_CONSENT_APPS
  PATHFINDER
  PREFERENCE_STORE
  PRIVACY_CENTER
  PROMPTS
  SELF_HOSTED_SOMBRA
  SILO_DISCOVERY
  STRUCTURED_DATA_DISCOVERY
  SUPPORT_TIER
  TRANSCEND_HOSTED_PROMPT_MANAGER_MONTHLY_USAGE_LIMIT
  UNSTRUCTURED_DATA_DISCOVERY
  WEB_CONSENT
  WHITE_LABEL_PRIVACY_CENTER
  WHITE_LABEL_PRIVACY_REQUEST_EMAILS
  WORKFLOWS_V2
}

enum FeatureGate {
  ALLOWED
  TRIAL_EXPIRING
  BLOCKED
}

enum FeatureName {
  webConsent
  dataMapping
}

enum SupportTier {
  ESSENTIAL
  PRO
  PREMIER
}

enum OAuthEntityType {
  User
  Organization
  DataSilo
}

enum ConsentManagerOnboardingStatus {
  STARTED
  AWAITING_TELEMETRY
  READY_TO_LAUNCH
  DONE
}

enum OrganizationTier {
  FREE
  PAID
  PARTNERSHIPS
  INTERNAL
}

enum TestEmailFailurePoint {
  INITIAL_BACKEND
  SOMBRA
  SOMBRA_INTERNAL
  EMAIL_SENDER
  FINAL_BACKEND
}

enum TableId {
  DATA_INVENTORY_DATA_SILOS
  DATA_INVENTORY_DATA_POINTS
  DATA_INVENTORY_VENDORS
  DATA_INVENTORY_DATA_CATEGORIES
  DATA_INVENTORY_PROCESSING_ACTIVITIES
  DATA_INVENTORY_PURPOSES
  DATA_INVENTORY_BUSINESS_ENTITIES
  CONSENT_DATA_FLOWS_TRIAGE
  CONSENT_DATA_FLOWS_APPROVED
  CONSENT_DATA_FLOWS_JUNK
  CONSENT_COOKIES_TRIAGE
  CONSENT_COOKIES_APPROVED
  CONSENT_COOKIES_JUNK
  DATA_MAP_BROWSE_LIST
  INTEGRATIONS_MANAGE_DATA_POINTS
  CONSENT_USER_PREFERENCES
  RISK_INTELLIGENCE_ASSESSMENTS
  DSR_AUTOMATION_INCOMING_REQUESTS
  DATA_INVENTORY_SENSITIVE_CATEGORIES
}

enum DataSilosColumnName {
  businessEntities
  connectedActions
  consentDoNotSellIntegration
  contactEmail
  contactName
  controllerships
  cookieCountApproved
  cookieCountTriage
  country
  dataFlowCountApproved
  dataFlowCountTriage
  dataProcessingAgreementLink
  dataProcessingAgreementStatus
  dataRetentionNote
  dataSubCategories
  deprecationState
  description
  discoveredBy
  hasPersonalData
  hasUspApiSupport
  identifiers
  integrationDocs
  isLive
  manualWorkRetryFrequency
  notes
  notifyEmailAddress
  notifyWebhookUrl
  owners
  privacyRequestIntegrationType
  processingActivities
  processingPurposeSubCategories
  promptAVendorEmailCompletionLinkType
  promptAVendorEmailIncludeIdentifiersAttachment
  promptAVendorEmailSendFrequency
  promptAVendorEmailSendType
  promptEmailTemplate
  receiverDataSilos
  recipients
  recommendedForConsent
  recommendedForPrivacy
  silosDiscovered
  subDataPointCount
  subjectBlocklist
  superCategories
  teams
  title
  transferRegions
  vendor
  websiteUrl
  sensitiveCategories
}

enum SubDataPointsColumnName {
  accessRequestVisibilityEnabled
  categories
  column
  contentClassificationStatus
  controllership
  createdAt
  dataPointOwners
  dataPointTeams
  dataPointTitle
  dataSilo
  dataSiloOwners
  dataSiloTeams
  dataSiloVendor
  description
  erasureRequestRedactionEnabled
  name
  processingActivities
  purposes
  table
  subjects
  retentionType
}

enum DataCategoriesColumnName {
  catalogRecipients
  category
  dataPointCount
  dataSiloRegions
  dataSilos
  description
  owners
  identifier
  subDataPointRetentionSchedules
  teams
  vendorHeadquarterLocations
  regex
  sensitiveCategories
}

enum PurposesColumnName {
  businessEntities
  catalogRecipients
  controllerships
  dataSilos
  dataSiloDataSubjects
  dataSiloOwners
  dataSiloRegions
  dataSubCategories
  description
  owners
  purpose
  subDataPointCount
  subDataPointRetentionSchedules
  superCategories
  teams
  vendors
  vendorHeadquarterLocations
  vendorOwners
  sensitiveCategories
}

enum VendorsColumnName {
  address
  businessEntity
  catalogRecipients
  contactEmail
  contactName
  contactPhone
  controllerships
  dataProcessingAgreementLink
  dataProcessingAgreementStatus
  dataSiloRegions
  dataSilos
  dataSubCategories
  description
  headquarterCountry
  owners
  processingPurposeSubCategories
  subDataPointCount
  teams
  title
  websiteUrl
}

enum BusinessEntitiesColumnName {
  address
  catalogRecipients
  dataProtectionOfficerEmail
  dataProtectionOfficerName
  dataSilos
  dataSubCategories
  description
  headquarterCountry
  processingPurposeSubCategories
  title
  vendors
  teams
  owners
}

enum CookiesColumnName {
  activity
  consentDoNotSellIntegration
  domains
  encounters
  hasUspApiSupport
  isRegex
  createdAt
  lastDiscoveredAt
  name
  notes
  owners
  purpose
  serviceCategoriesOfRecipients
  serviceDescription
  serviceName
  serviceWebsite
  status
  teams
  occurrences
  maxAge
}

enum DataFlowsColumnName {
  actions
  activity
  connectionsMadeTo
  consentDoNotSellIntegration
  encounters
  hasUspApiSupport
  createdAt
  lastDiscoveredAt
  notes
  owners
  purpose
  serviceCategoriesOfRecipients
  serviceDescription
  serviceName
  serviceWebsite
  status
  teams
  type
  occurrences
}

enum AssessmentFormTemplatesColumnName {
  creator
  description
  lastEditor
  source
  status
  title
  updatedAt
}

enum AssessmentFormsColumnName {
  assessmentGroup
  assignees
  sectionAssignees
  createdAt
  assignedAt
  submittedAt
  approvedAt
  rejectedAt
  dueDate
  resources
  reviewers
  status
  syncedRows
  title
  titleIsInternal
  triggeredForms
}

enum AssessmentGroupsColumnName {
  createdAt
  description
  dueDate
  creator
  lastEditor
  status
  id
  assessmentFormTemplate
  title
  updatedAt
}

enum ConsentUserPreferencesColumnName {
  partitionType
  partitionName
  decryptionStatus
  timestamp
}

enum DsrIncomingRequestColumnName {
  email
  coreIdentifier
  daysRemaining
  id
  status
  isOpened
  isArchived
  isSilent
  isTest
  type
  origin
  subjectType
  locale
  updatedAt
  lastTransitionTime
  createdAt
  attributeValues
  country
  owners
  teams
  partition
  purpose
  enrichedPreferences
  successfullyCompletedAt
}

enum ProcessingActivitiesColumnName {
  title
  description
  teams
  owners
  businessEntities
  dataSilos
  vendors
  securityMeasureDetails
  controllerships
  storageRegions
  transferRegions
  retentionType
  dataProtectionImpactAssessmentLink
  dataProtectionImpactAssessmentStatus
  dataSubjects
  processingPurposeSubCategories
  dataSubCategories
  saaSCategories
}

enum SensitiveCategoriesColumnName {
  title
  description
}

enum ProductArea {
  ADMINISTRATION
  DATA_MAPPING
  CONSENT
  DSR_AUTOMATION
  PRIVACY_CENTER
  ASSESSMENTS
}

enum ResourceType {
  dataSilo
  dataPoint
}

enum ScopeOrderField {
  name
  createdAt
  updatedAt
}

enum SombraOrderField {
  hostedMethod
  title
  url
  publicUrl
  createdAt
  updatedAt
}

enum TeamOrderField {
  name
  createdAt
  updatedAt
}

enum UserOrderField {
  name
  createdAt
  updatedAt
}

enum UserLoginMethod {
  LOCAL
  SSO
  ROLE
}

enum AuditEventCode {
  ACTION_ITEM
  AIRGAP_BUNDLE
  AIRGAP_BUNDLE_VERSION
  AIRGAP_BUNDLE_DEPLOYMENT
  AIRGAP_COOKIE
  AIRGAP_DATA_FLOW
  AIRGAP_COOKIE_OWNER
  AIRGAP_COOKIE_TEAM
  AIRGAP_DATA_FLOW_OWNER
  AIRGAP_DATA_FLOW_TEAM
  AIRGAP_THEME
  ASSESSMENT_ANSWER
  ASSESSMENT_FORM
  ASSESSMENT_FORM_ASSIGNEE
  ASSESSMENT_FORM_COMMENT
  ASSESSMENT_FORM_REVIEWER
  ASSESSMENT_FORM_TEMPLATE
  ASSESSMENT_GROUP
  ASSESSMENT_QUESTION
  ASSESSMENT_QUESTION_COMMENT
  ASSESSMENT_SECTION_COMMENT
  ASSESSMENT_SECTION
  ASSESSMENT_SECTION_ASSIGNEE
  ASSESSMENT_EMAIL_SET
  CUSTOM_FUNCTION_CODE
  CUSTOM_FUNCTION_CODE_CONTEXT
  CUSTOM_FUNCTION_RUN
  DATA_POINT
  DATA_POINT_ACTION
  DATA_POINT_LEVEL_DESCRIPTION
  DATA_POINT_LEVEL_OWNER
  DATA_POINT_LEVEL_TEAM
  DATA_POINT_OWNER
  DATA_POINT_TEAM
  DATA_REPORT
  DATA_SILO
  DATA_SILO_API_KEY
  DATA_SILO_ATTRIBUTE
  AIRGAP_COOKIE_ATTRIBUTE
  AIRGAP_DATA_FLOW_ATTRIBUTE
  AIRGAP_COOKIE_PURPOSE
  AIRGAP_DATA_FLOW_PURPOSE
  DATA_SILO_OWNER
  DATA_SILO_PLUGIN
  DATA_SILO_DATA_SUB_CATEGORY
  DATA_SILO_PROCESSING_ACTIVITY
  DATA_SILO_PROCESSING_PURPOSE_SUB_CATEGORY
  DATA_SILO_SAAS_CATEGORY
  DATA_SILO_SUBJECT_BLOCKLIST
  DATA_SILO_TEAM
  DATA_SILO_DATA_SILO
  DATA_SILO_VENDOR
  DATA_SILO_BUSINESS_ENTITY
  DATA_SILO_DEPENDENT_DATA_SILO
  BUSINESS_ENTITY
  BUSINESS_ENTITY_ATTRIBUTE
  BUSINESS_ENTITY_TEAM
  BUSINESS_ENTITY_OWNER
  VENDOR
  VENDOR_OWNER
  VENDOR_TEAM
  VENDOR_BUSINESS_ENTITY
  VENDOR_ATTRIBUTE
  DATA_SUB_CATEGORY
  IDENTIFIER
  IDENTIFIER_ACTION
  IDENTIFIER_DATA_SILO
  IDENTIFIER_SUBJECT
  PROCESSING_ACTIVITY
  PROCESSING_ACTIVITY_ATTRIBUTE
  PROCESSING_ACTIVITY_DATA_SILO
  PROCESSING_PURPOSE_SUB_CATEGORY
  PROCESSING_PURPOSE_SUB_CATEGORY_OWNER
  PROCESSING_PURPOSE_SUB_CATEGORY_TEAM
  DATA_SUB_CATEGORY_OWNER
  DATA_SUB_CATEGORY_TEAM
  PROCESSING_PURPOSE_SUB_CATEGORY_ATTRIBUTE
  DATA_SUB_CATEGORY_ATTRIBUTE
  SUB_DATA_POINT
  SUB_DATA_POINT_ATTRIBUTE
  SUB_DATA_POINT_DATA_SUB_CATEGORY
  SUB_DATA_POINT_PROCESSING_ACTIVITY
  SUB_DATA_POINT_PROCESSING_PURPOSE_SUB_CATEGORY
  SUB_DATA_POINT_SUBJECT
  MESSAGE
  PRIVACY_CENTER
  PRIVACY_CENTER_EMAIL_SENDER_ADDRESS
  EMAIL_SENDER_ADDRESS
  EMAIL_SENDER_ADDRESS_ATTRIBUTE_VALUE
  THEME
  DATA_COLLECTION
  ASSET_FILE
  POLICY
  POLICY_VERSION
  EXPERIENCE
  EXPERIENCE_PURPOSE
  TRACKING_PURPOSE
  PREFERENCE
  SCANNED_OBJECT
  UNSTRUCTURED_SUB_DATA_POINT_RECOMMENDATION
  SOMBRA
  SOMBRA_API_KEY
  ORG_TCF_PURPOSE
  ORG_TCF_SPECIAL_FEATURE
  ORG_TCF_PURPOSE_PURPOSE
  ORG_TCF_SPECIAL_FEATURE_PURPOSE
  CONSENT_SERVICE
  CONSENT_SITE
  AIRGAP_BUNDLE_TCF_STACK
  AIRGAP_PARTITION
  RISK_FRAMEWORK
  RISK_LEVEL
  RISK_CATEGORY
  RISK_CATEGORY_OWNER
  RISK_CATEGORY_TEAM
  RISK_MATRIX_COLUMN
  RISK_MATRIX_ROW
  PREFERENCE_OPTION
  PREFERENCE_TOPIC
  CONSENT_WORKFLOW_TRIGGER
}

enum AuditEventBaseModelCode {
  ACTION_ITEM
  ASSESSMENT_ANSWER
  ASSESSMENT_FORM
  ASSESSMENT_FORM_COMMENT
  ASSESSMENT_FORM_TEMPLATE
  ASSESSMENT_GROUP
  ASSESSMENT_QUESTION
  ASSESSMENT_QUESTION_COMMENT
  ASSESSMENT_SECTION_COMMENT
  ASSESSMENT_SECTION
  ASSESSMENT_EMAIL_SET
  CUSTOM_FUNCTION
  DATA_POINT
  DATA_POINT_LEVEL
  DATA_REPORT
  DATA_SILO
  DATA_SILO_PLUGIN
  AIRGAP_BUNDLE
  AIRGAP_BUNDLE_DEPLOYMENT
  AIRGAP_COOKIE
  AIRGAP_DATA_FLOW
  AIRGAP_THEME
  VENDOR
  BUSINESS_ENTITY
  DATA_SUB_CATEGORY
  IDENTIFIER
  PROCESSING_ACTIVITY
  PROCESSING_PURPOSE_SUB_CATEGORY
  SUB_DATA_POINT
  MESSAGE
  PRIVACY_CENTER
  EMAIL_SENDER_ADDRESS
  THEME
  DATA_COLLECTION
  ASSET_FILE
  POLICY
  EXPERIENCE
  TRACKING_PURPOSE
  PREFERENCE
  SCANNED_OBJECT
  UNSTRUCTURED_SUB_DATA_POINT_RECOMMENDATION
  SOMBRA
  ORG_TCF_PURPOSE
  ORG_TCF_SPECIAL_FEATURE
  CONSENT_SERVICE
  CONSENT_SITE
  AIRGAP_BUNDLE_TCF_STACK
  AIRGAP_PARTITION
  RISK_FRAMEWORK
  RISK_LEVEL
  RISK_CATEGORY
  RISK_MATRIX_COLUMN
  RISK_MATRIX_ROW
  PREFERENCE_OPTION
  PREFERENCE_TOPIC
  CONSENT_WORKFLOW_TRIGGER
}

enum CONSENT_AUDIT_EVENTS {
  AIRGAP_BUNDLE
  AIRGAP_BUNDLE_DEPLOYMENT
  AIRGAP_THEME
  AIRGAP_COOKIE
  AIRGAP_COOKIE_PURPOSE
  AIRGAP_COOKIE_OWNER
  AIRGAP_COOKIE_TEAM
  AIRGAP_COOKIE_ATTRIBUTE
  AIRGAP_DATA_FLOW
  AIRGAP_DATA_FLOW_ATTRIBUTE
  AIRGAP_DATA_FLOW_OWNER
  AIRGAP_DATA_FLOW_PURPOSE
  AIRGAP_DATA_FLOW_TEAM
  AIRGAP_PARTITION
  CONSENT_SERVICE
  EXPERIENCE
  EXPERIENCE_PURPOSE
  AIRGAP_BUNDLE_VERSION
  ORG_TCF_PURPOSE
  ORG_TCF_SPECIAL_FEATURE
  ORG_TCF_PURPOSE_PURPOSE
  ORG_TCF_SPECIAL_FEATURE_PURPOSE
  AIRGAP_BUNDLE_TCF_STACK
  MESSAGE
}

enum PREFERENCE_STORE_AUDIT_EVENTS {
  PREFERENCE_OPTION
  PREFERENCE_TOPIC
  CONSENT_WORKFLOW_TRIGGER
}

enum MessageProperties {
  dataCollectionId
  dataPointId
  dataSiloId
  privacyCenterId
  identifierId
  subjectId
  policyId
}

enum AnalyticsDataSource {
  SILOS_BY_TEAM
  SUB_DATA_POINTS_BY_PROCESSING_PURPOSES
  SUB_DATA_POINTS_BY_CLASSIFICATION_STATUS
  SUB_DATA_POINTS_BY_CLASSIFICATION_PROCESSING_STATUS
  SUB_DATA_POINTS_BY_DATA_SUB_CATEGORIES
  SILOS_BY_HAS_PERSONAL_DATA
  SILOS_BY_RECOMMENDED_FOR_PRIVACY
  SILOS_BY_RECOMMENDED_FOR_CONSENT
  SILOS_BY_SAAS_CATEGORY
  SILOS_BY_SILO_DISCO_RECOMMENDATION_STATUS
  SILOS_BY_CREATED_AT_AND_DISCO_STATUS
  SILO_REQUEST_VOLUME
  CONSENT_HTTP_REQUESTS_BY_PURPOSE
  REQUESTS_BY_STATUS
  REQUESTS_BY_TYPE
  REQUESTS_BY_SUBJECT
  REQUEST_FULFILLMENTS_OVER_TIME
  REQUEST_FULFILLMENT_BY_TYPE
  REQUEST_VOLUME_OVER_TIME
  PRIVACY_RISKS
  HISTORICAL_REQUESTS_BY_STATUS
  VISITOR_CHOICES
  CONSENT_SIGNALS
  CONSENT_SESSIONS_BY_REGIME
  CONSENT_CHANGES_TIMESERIES
  PRIVACY_SIGNAL_TIMESERIES
  AUDITOR_REQUESTS_BY_PURPOSE
  AUDITOR_COOKIES_BY_PURPOSE
  AUDITOR_REQUESTS_REGULATED_BY_AIRGAP
  AUDITOR_COOKIES_REGULATED_BY_AIRGAP
  AUDITOR_FINDINGS_BY_SEVERITY
  GLOBAL_CONSENT_STATUSES_BY_PURPOSE
  SENSITIVE_OBJECTS_COUNT_BY_DATA_SILOS
  SENSITIVE_OBJECTS_COUNT_BY_DATA_CATEGORIES
}

enum AnalyticsGroupBy {
  ATTRIBUTE_VALUE
  REQUEST_TYPE
  LOCALE
}

enum BaseCacheKey {
  ANALYTICS
  GEO_ANALYTICS
  AIRGAP_TIMESERIES_ANALYTICS
  AIRGAP_AGGREGATE_ANALYTICS
  DATA_SILO_ACTIVITY
  AIRGAP_VERSION
}

enum FindingClass {
  AirgapNotFound
  UnexpectedCookieStored
  UnexpectedDataFlow
  UnregulatedCookieStored
  UnregulatedNetworkRequestMade
  CookieMisclassified
  DataFlowMisclassified
  FacebookLDU
  GoogleRDP
  MicrosoftAdvertising
  PinterestAds
  TikTokPixel
  TwitterAds
  Other
}

enum FindingSeverity {
  Informational
  Low
  Medium
  High
  Critical
}

enum AuditorGQLRegionEnum {
  California
  Ireland
}

enum AuditorRunStatus {
  Queued
  Processing
  Skipped
  Error
  Complete
}

enum SameSite {
  Strict
  Lax
  None
}

enum ColorScheme {
  light
  dark
}

enum PrivacyCenterIntlMessageType {
  ACTION_SECONDARY_DESCRIPTION
  ACTION_SUBJECT_TITLE
  ACTION_DESCRIPTION
  ACTION_FORM_ITEM
  DATA_SUBJECT_LOGIN_INSTRUCTIONS
  DATA_SUBJECT_DISABLED_INSTRUCTIONS
  IDENTIFIER_TITLE
  IDENTIFIER_DESCRIPTION
  DATA_SUBJECT_TITLE
  DATA_SUBJECT_REDIRECT_URL
  POLICY_TITLE
  POLICY_CONTENT
  ASSET_FILE_ALT
  TEMPLATE_SUBJECT
  TEMPLATE_TEMPLATE
  DATA_COLLECTION_TITLE
  DATA_CATEGORY_TITLE
  DATA_APPLICATION_TITLE
  DATA_APPLICATION_DESCRIPTION
  DATA_COLLECTION_DESCRIPTION
  DATA_POINT_TITLE
  DATA_POINT_DESCRIPTION
  LOOSE_MESSAGE
  PRIVACY_CENTER_HOME_URL
  WORKFLOW_TITLE
  WORKFLOW_SUBTITLE
  WORKFLOW_DESCRIPTION
  CONSENT_PURPOSE_TITLE
  PREFERENCE_TOPIC_TITLE
  PREFERENCE_TOPIC_DESCRIPTION
  PREFERENCE_OPTION_TITLE
  SUB_DATA_POINT_TITLE
}

enum ConsentManagerIntlMessageType {
  CONSENT_MANAGER_MESSAGE
  CONSENT_PURPOSE_TITLE
  CONSENT_PURPOSE_DESCRIPTION
  CONSENT_MANAGER_TCF_MESSAGE
}

enum IntlMessageType {
  ACTION_SECONDARY_DESCRIPTION
  ACTION_SUBJECT_TITLE
  ACTION_DESCRIPTION
  ACTION_FORM_ITEM
  DATA_SUBJECT_LOGIN_INSTRUCTIONS
  DATA_SUBJECT_DISABLED_INSTRUCTIONS
  IDENTIFIER_TITLE
  IDENTIFIER_DESCRIPTION
  DATA_SUBJECT_TITLE
  DATA_SUBJECT_REDIRECT_URL
  POLICY_TITLE
  POLICY_CONTENT
  ASSET_FILE_ALT
  TEMPLATE_SUBJECT
  TEMPLATE_TEMPLATE
  DATA_COLLECTION_TITLE
  DATA_CATEGORY_TITLE
  DATA_APPLICATION_TITLE
  DATA_APPLICATION_DESCRIPTION
  DATA_COLLECTION_DESCRIPTION
  DATA_POINT_TITLE
  DATA_POINT_DESCRIPTION
  LOOSE_MESSAGE
  PRIVACY_CENTER_HOME_URL
  WORKFLOW_TITLE
  WORKFLOW_SUBTITLE
  WORKFLOW_DESCRIPTION
  CONSENT_PURPOSE_TITLE
  PREFERENCE_TOPIC_TITLE
  PREFERENCE_TOPIC_DESCRIPTION
  PREFERENCE_OPTION_TITLE
  SUB_DATA_POINT_TITLE
  CONSENT_MANAGER_MESSAGE
  CONSENT_PURPOSE_DESCRIPTION
  CONSENT_MANAGER_TCF_MESSAGE
}

type Query {
  """Action item run locks"""
  actionItemRunLocks(input: ActionItemRunLocksInput!): ActionItemRunLocksPayload!

  """Get a users action item subscriptions"""
  actionItemSubscriptions(input: QueryActionItemSubscriptionInput!): [ActionItemSubscription!]!

  """A paginated list of preview actions"""
  actions(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ActionFiltersInput, orderBy: [ActionOrder!]): ActionsPayload!

  """The audit trail for data subject request resolution"""
  activities(first: Int, offset: Int = 0, last: Int, filterBy: ActivityFiltersInput!, orderBy: [ActivityOrder!]): ActivitiesPayload!

  """List of agentFiles registered in the instance"""
  agentFiles(first: Int, offset: Int = 0, last: Int, filterBy: AgentFileFiltersInput, orderBy: [AgentFileOrder!]): AgentFilesPayload!

  """List of agent functions registered in the instance"""
  agentFunctions(first: Int, offset: Int = 0, last: Int, filterBy: AgentFunctionFiltersInput, orderBy: [AgentFunctionOrder!]): AgentFunctionsPayload!

  """List the agents"""
  agents(first: Int, offset: Int = 0, last: Int, filterBy: AgentFiltersInput, orderBy: [AgentOrder!]): AgentsPayload!

  """The aggregate analytics data for an airgap bundle"""
  airgapBundleAggregateAnalytics(id: ID!, input: AirgapBundleAggregateAnalyticsInput!): AirgapBundleAggregateAnalyticsResult!

  """The timeseries analytics data for an airgap bundle"""
  airgapBundleTimeseriesAnalytics(id: ID!, input: AirgapBundleTimeseriesAnalyticsInput!): AirgapBundleTimeseriesAnalyticsResult!

  """List the versions of an airgap bundle, ordered by most recent first"""
  airgapBundleVersions(first: Int, offset: Int = 0, last: Int, id: ID!, input: AirgapBundleVersionsInput!): AirgapBundleVersionsPayload!

  """List all the available airgap versions (max 100)"""
  airgapVersions(input: AirgapVersionsInput!): AirgapVersionsPayload!

  """Fetch data from an analytics source"""
  analyticsData(input: AnalyticsInput!): AnalyticsResult!

  """Grab an API key"""
  apiKey(id: ID!): ApiKey!

  """The API keys in the organization"""
  apiKeys(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ApiKeyFiltersInput, orderBy: [ApiKeyOrder!]): ApiKeysPayload!

  """List of applications registered in the instance"""
  applications(first: Int, offset: Int = 0, last: Int, filterBy: ApplicationFiltersInput, orderBy: [ApplicationOrder!]): ApplicationsPayload!

  """List of users that were registered to applications within the instance"""
  applicationUsers(first: Int, offset: Int = 0, last: Int, filterBy: ApplicationUserFiltersInput, orderBy: [ApplicationUserOrder!]): ApplicationUsersPayload!

  """List the assessmentEmailSets"""
  assessmentEmailSets(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentEmailSetFiltersInput): AssessmentEmailSetsPayload!

  """Get a list of assessment files"""
  assessmentFiles(filterBy: AssessmentFileFiltersInput): AssessmentFilesPayload!

  """List the assessmentFormComments"""
  assessmentFormComments(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentFormCommentFiltersInput): AssessmentFormCommentsPayload!

  """List the assessmentForms"""
  assessmentForms(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentFormFiltersInput): AssessmentFormsPayload!

  """List the assessmentFormTemplates"""
  assessmentFormTemplates(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentFormTemplateFiltersInput): AssessmentFormTemplatesPayload!

  """
  Get the assessment form to be filled out by an external user via a magic link token
  """
  assessmentFormToken(input: TokenInput!): AssessmentFormTokenPayload!

  """List the assessmentGroups"""
  assessmentGroups(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentGroupFiltersInput): AssessmentGroupsPayload!

  """Get the assessment group via a magic link token"""
  assessmentGroupToken(input: TokenInput!): AssessmentGroupTokenPayload!

  """List the assessmentQuestionComments"""
  assessmentQuestionComments(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentQuestionCommentFiltersInput): AssessmentQuestionCommentsPayload!

  """List the assessmentQuestions"""
  assessmentQuestions(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentQuestionFiltersInput): AssessmentQuestionsPayload!

  """
  Get the options for assessment select-type questions whose subtype requires dynamic values
  """
  assessmentQuestionSelectOptions(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentQuestionSelectOptionsFiltersInput): AssessmentQuestionSelectOptionsPayload!

  """
  Get the options for assessment select-type questions whose subtype requires dynamic values for an external user
  """
  assessmentQuestionSelectOptionsToken(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, input: TokenInput!, filterBy: AssessmentQuestionSelectOptionsTokenFiltersInput): AssessmentQuestionSelectOptionsTokenPayload!

  """List the assessmentSectionComments"""
  assessmentSectionComments(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AssessmentSectionCommentFiltersInput): AssessmentSectionCommentsPayload!

  """
  Paginate over the list of asset files associated with the organization.
  """
  assetFiles(first: Int, offset: Int = 0, last: Int, orderBy: [AssetFileOrder!]): AssetFilesPayload!

  """Queries the backend for the sombra associated with an email reply"""
  associateReplyWithSombra(input: AssociateReplyWithSombraInput!): AssociateReplyWithSombraResponse!

  """An attribute key"""
  attributeKey(id: ID!): AttributeKey!

  """
  List all of the attributeKeys an organization uses to house attributeValues
  """
  attributeKeys(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AttributeKeysFiltersInput, orderBy: [AttributeKeyOrder!]): AttributeKeysPayload!

  """
  List all of the attributeValues an organization uses to label resources
  """
  attributeValues(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: AttributeValuesFiltersInput, orderBy: [AttributeValueOrder!]): AttributeValuesPayload!

  """
  Audit logs for user-generated activities and automations in the Transcend platform
  """
  auditEvents(first: Int, offset: Int = 0, last: Int, filterBy: AuditEventFiltersInput): AuditEventsPayload!

  """Retrieves a temporary link to download an auditor file"""
  auditorFileLink(input: AuditorFileInput!): AuditorFileLinkPayload!

  """Number of findings by finding class type for a given auditor run"""
  auditorFindingClassCounts(id: ID!, filterBy: AuditorFindingClassCountsFiltersInput): AuditorFindingClassCountsPayload!

  """The findings for a given auditor run"""
  auditorFindings(first: Int, offset: Int = 0, last: Int, filterBy: AuditorFindingFiltersInput!): AuditorFindingsPayload!

  """A single auditor run"""
  auditorRun(id: ID!): AuditorRunPayload!

  """The cookies for a given auditor run"""
  auditorRunCookies(first: Int, offset: Int = 0, last: Int, filterBy: AuditorRunCookiesFiltersInput!): AuditorRunCookiesPayload!

  """The data flows for a given auditor run"""
  auditorRunDataFlows(first: Int, offset: Int = 0, last: Int, filterBy: AuditorRunDataFlowsFiltersInput!): AuditorRunDataFlowsPayload!

  """All the historic auditor runs"""
  auditorRuns(first: Int, offset: Int = 0, last: Int, filterBy: AuditorRunFiltersInput): AuditorRunsPayload!

  """All the active auditor schedules"""
  auditorSchedules(first: Int, offset: Int = 0, last: Int, filterBy: AuditorSchedulesFiltersInput): AuditorSchedulesPayload!

  """Query for all IAB TCF stacks with metadata for a given Consent bundle"""
  bundleTcfStacks(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: TCFStackFilterInput): BundleTcfStacksPayload!

  """Query for all TCF vendors for a given Consent bundle"""
  bundleTcfVendors(first: Int, offset: Int = 0, last: Int, input: BundleTCFVendorInput!): BundleTcfVendorsPayload!

  """List the internal business entities in the datamap"""
  businessEntities(first: Int, offset: Int = 0, last: Int, filterBy: BusinessEntitiesFiltersInput, orderBy: [BusinessEntityOrder!], useMaster: Boolean, isExportCsv: Boolean): BusinessEntitiesPayload!

  """Get the metadata for a single catalog in our registry"""
  catalog(input: CatalogInput!): CatalogPayload!

  """Return a paginated view of our catalog"""
  catalogs(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: CatalogFiltersInput!, orderBy: [CatalogOrder!]): CatalogsPayload!

  """Check whether a reset token is still valid"""
  checkResetPasswordToken(input: TokenInput!): ChangePasswordResult!

  """
  The list of data silos with classification plugins available (content classification and unstructured discovery)
  """
  classificationDataSilos(first: Int, offset: Int = 0, last: Int, filterBy: ContentClassificationDataSiloFiltersInput, orderBy: [DataSiloBulkPreviewOrder!]): ClassificationDataSilosPayload!

  """Get summary statistics for classification data silos"""
  classificationDataSiloSummaryStatistics: ClassificationDataSiloSummaryStatistics!

  """List of code packages registered in the instance"""
  codePackages(first: Int, offset: Int = 0, last: Int, filterBy: CodePackageFiltersInput, orderBy: [CodePackageOrder!]): CodePackagesPayload!

  """Query for all native applications being governed by Transcend Consent"""
  consentApplications(first: Int, offset: Int = 0, last: Int, filterBy: ConsentApplicationFiltersInput): ConsentApplicationsPayload!

  """
  The configuration and metadata associated with a given consent manager.
  """
  consentManager: ConsentManagerPayload!

  """The configuration associated with a given consent manager."""
  consentManagerConfigurationJson(id: ID!): ConsentManagerConfigurationJsonPayload!

  """Get the UI configuration associated with a given consent manager"""
  consentManagerTheme(input: AirgapBundleInput!): ConsentManagerThemePayload!

  """Consent Manager UIs for Airgap Bundle"""
  consentManagerUIs(first: Int, offset: Int = 0, last: Int): ConsentManagerUIsPayload!

  """
  List the consent partitions defined for this organization (parent orgs only)
  """
  consentPartitions(first: Int, offset: Int = 0, last: Int, filterBy: ConsentPartitionFiltersInput): ConsentPartitionsPayload!

  """Query for all consent SDKs being governed by Transcend Consent"""
  consentSdks(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: ConsentSdkFiltersInput): ConsentSdksPayload!

  """Query for all consent services for a given Consent bundle"""
  consentServices(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: FilterConsentServicesInput): ConsentServicesPayload!

  """Query for all consent sites for an organization"""
  consentSites(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: FilterConsentSiteInput): ConsentSitesPayload!

  """Query for all consent workflow triggers setup for a given Organization"""
  consentWorkflowTriggers(first: Int, offset: Int = 0, last: Int, filterBy: ConsentWorkflowTriggersFilterInput): ConsentWorkflowTriggersPayload!

  """
  List datapoints that are part of a data silo with the classification plugin enabled
  """
  contentClassificationDataPoints(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ContentClassificationDataPointsFiltersInput, orderBy: [ContentClassificationDataPointOrder!]): ContentClassificationDataPointsPayload!

  """The list of data silos with content classification plugin available"""
  contentClassificationSilos(first: Int, offset: Int = 0, last: Int, filterBy: ContentClassificationDataSiloFiltersInput, orderBy: [DataSiloBulkPreviewOrder!]): ContentClassificationSilosPayload!

  """List of contracts registered in the instance"""
  contracts(first: Int, offset: Int = 0, last: Int, filterBy: ContractFiltersInput, orderBy: [ContractOrder!]): ContractsPayload!

  """The instances of scanning contracts"""
  contractScans(first: Int, offset: Int = 0, last: Int, filterBy: ContractScanFiltersInput, orderBy: [ContractScanOrder!]): ContractScansPayload!

  """The cookies for an organization"""
  cookies(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: CookiesFiltersInput, orderBy: [CookieOrder!], useMaster: Boolean, isExportCsv: Boolean): CookiesPayload!

  """Aggregate statistics about managed cookies for an org"""
  cookieStats(input: AirgapBundleInput!): CookieStatsPayload!

  """List the email domains for the current org"""
  currentEmailDomains: [EmailDomain!]!

  """List the email sender addresses for a privacy center"""
  currentEmailSenderAddresses(input: CurrentEmailSenderAddressesInput!): CurrentEmailSenderAddressesPayload!

  """List custom functions"""
  customFunctions(first: Int, offset: Int = 0, last: Int, filterBy: CustomFunctionFilterInput!): CustomFunctionsPayload!

  """List all the configured sync endpoints for a given consent manager"""
  customSyncEndpoints(id: ID!): CustomSyncEndpointsPayload!

  """Get the data categories for an organization"""
  dataCategories(first: Int, offset: Int = 0, last: Int, filterBy: DataCategoryFiltersInput): DataCategoriesPayload!

  """List the data collections in an organization"""
  dataCollections: [DataCollection!]!

  """
  The number of request files for each data collection for a given request
  """
  dataCollectionsRequestFileCount(input: DataCollectionsRequestFileCountInput!, dhEncrypted: String, lookup: PrivacyCenterLookupInput): DataCollectionsRequestFileCountPayload!

  """The data flows for an organization"""
  dataFlows(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: DataFlowsFiltersInput, orderBy: [DataFlowOrder!], useMaster: Boolean, isExportCsv: Boolean): DataFlowsPayload!

  """The services for which data flows are configured"""
  dataFlowServices(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: DataFlowServicesFiltersInput): DataFlowServicesPayload!

  """Aggregate statistics about managed data flows for an org"""
  dataFlowStats(input: AirgapBundleInput!): DataFlowStatsPayload!

  """List the datapoints for a silo at a given level in the hierarchy"""
  dataPointHierarchy(first: Int, offset: Int = 0, last: Int, filterBy: DataPointHierarchyFiltersInput!): DataPointHierarchyPayload!

  """List the path segments at a given level in the hierarchy"""
  dataPointHierarchyPath(filterBy: DataPointHierarchyPathFiltersInput): DataPointHierarchyPathPayload!

  """List the datapoints for an organization"""
  dataPoints(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: DataPointFiltersInput, orderBy: [DataPointOrder!]): DataPointsPayload!

  """List the data reports for an organization"""
  dataReports(first: Int, offset: Int = 0, last: Int, filterBy: DataReportFiltersInput, orderBy: [DataReportRawOrder!]): DataReportsPayload!

  """Get the data retention schedule policy for the organization"""
  dataRetentionSchedulePolicy: DataRetentionSchedulePolicyPayload!

  """A data silo in the datamap"""
  dataSilo(id: String!): DataSilo!

  """List the emails that have been sent back and forth"""
  dataSiloCommunications(first: Int, offset: Int = 0, last: Int, filterBy: DataSiloCommunicationFilterInput!): DataSiloCommunicationsPayload!

  """fetches all country codes and a total count of all of their data silos"""
  dataSiloCountsByCountry(input: DataSiloCountsByCountryInput!): DataSilosByCountry!

  """A list of data silos that send and receive data from each other"""
  dataSiloLineage(filterBy: DataSiloLineageFiltersInput): DataSiloLineagePayload!

  """List the plugins associated with a data silo"""
  dataSiloPluginRecommendation(input: DataSiloPluginRecommendationInput!): DataSiloPluginRecommendationPayload!

  """List the rate limits in effect for a data silo"""
  dataSiloRateLimits(id: ID!): DataSiloRateLimitsPayload!

  """A data silo in the datamap with a minimal number of fields"""
  dataSiloReduced(input: DataSiloReducedQueryInput!): DataSiloReduced!

  """List the data silos in the datamap"""
  dataSilos(first: Int, offset: Int = 0, last: Int, filterBy: DataSiloFiltersInput, orderBy: [DataSiloBulkPreviewOrder!], useMaster: Boolean, isExportCsv: Boolean): DataSilosPayload!

  """
  Get a summary of the status of a data silo being processed over all privacy requests
  """
  dataSiloSummary(id: ID!): DataSiloSummary!

  """Get the data categories and data subcategories for an organization"""
  dataSubCategories(first: Int, offset: Int = 0, last: Int, filterBy: DataSubCategoryFiltersInput, useMaster: Boolean, isExportCsv: Boolean): DataSubCategoriesPayload!

  """List the emails that have been sent back and forth"""
  dataSubjectCommunications(first: Int, offset: Int = 0, last: Int, id: ID!): DataSubjectCommunicationsPayload!

  """Paginated query for fetching data subject consent preferences data"""
  dataSubjectConsentPreferences(input: ConsentPreferencesInput!, dhEncrypted: String!, lookup: PrivacyCenterLookupInput): DataSubjectConsentPreferencesPayload!

  """Display the default template configurations"""
  defaultTemplates: DefaultTemplates!

  """
  Return the scan configuration associated with a classification data silo
  """
  discoClassScanConfig(input: DiscoClassScanConfigQueryInput!): DiscoClassScanConfig

  """Return the scans associated with a data silo"""
  discoClassScans(first: Int, offset: Int = 0, last: Int, filterBy: DiscoClassScanFiltersInput): DiscoClassScansPayload!

  """Get the files to include in a data subject access request"""
  downloadFiles(first: Int, offset: Int = 0, last: Int, dhEncrypted: String, filterBy: DownloadFileFiltersInput!, orderBy: [DownloadFileOrder!], lookup: PrivacyCenterLookupInput): DownloadFilesPayload!

  """Get the file counts to include in a data subject access request"""
  downloadFilesCountsOnly(dhEncrypted: String!, filterBy: DownloadFileFiltersInput!, lookup: PrivacyCenterLookupInput): DownloadFilesCountsOnlyPayload!

  """Grab an enricher"""
  enricher(id: ID!): Enricher!

  """List of enrichers in an organization"""
  enrichers(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: EnricherFiltersInput, orderBy: [EnricherOrder!]): EnrichersPayload!

  """Transcend configurations for subjects in organization defined regions"""
  experiences(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ExperienceFiltersInput, orderBy: [ExperienceOrder!]): ExperiencesPayload!

  """Get the secrets for signing tokens (current and former)"""
  getTokenSecrets(id: ID!): GetTokenSecretsPayload!

  """
  Paginated list of all action item collections for the specified location
  """
  globalActionItemCollections(filterBy: GlobalActionItemCollectionFiltersInput!): GlobalActionItemCollectionsPayload!

  """Paginated list of all new (global) action items"""
  globalActionItems(first: Int, offset: Int = 0, last: Int, filterBy: GlobalActionItemFiltersInput!): GlobalActionItemsPayload!

  """The google ReCaptcha site key to use"""
  googleSiteKey: GoogleSiteKeyPayload!

  """Paginate over the list of identifiers configured for an organization"""
  identifiers(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: IdentifierFiltersInput, orderBy: [IdentifierOrder!]): IdentifiersPayload!

  """Display the current initializer"""
  initializer: Enricher!

  """Inspect the results of a lookup process for a given identifier"""
  inspectLookupProcesses(input: InspectLookupProcessesInput!): InspectLookupProcessesPayload!

  """Returns all data subject configurations"""
  internalSubjects(filterBy: InternalSubjectsFiltersInput): [DataSubjectInternal!]!

  """List of large language models registered in the instance"""
  largeLanguageModels(first: Int, offset: Int = 0, last: Int, filterBy: LargeLanguageModelFiltersInput, orderBy: [LargeLanguageModelOrder!]): LargeLanguageModelsPayload!

  """Fetch the scan information for a plugin"""
  latestScan(id: ID!): LatestScanPayload!

  """
  Fetch the scan progress information for the latest schema discovery scan
  """
  latestSchemaDiscoveryScanProgress(id: ID!): LatestSchemaDiscoveryScanProgressPayload!

  """List the legal holds for the existing organization"""
  legalHolds(first: Int, offset: Int = 0, last: Int, filterBy: LegalHoldsFiltersInput, orderBy: [LegalHoldOrder!], useMaster: Boolean, isExportCsv: Boolean): LegalHoldsPayload!

  """List the legal matters for the existing organization"""
  legalMatters(first: Int, offset: Int = 0, last: Int, filterBy: LegalMattersFiltersInput, orderBy: [LegalMatterOrder!]): LegalMattersPayload!

  """
  List reduced-scope requests for a data silo, designed primarily for users not logged-in
  """
  listReducedRequestsForDataSilo(first: Int, offset: Int = 0, last: Int, input: BulkCompletionReducedRequestInput!): ListReducedRequestsForDataSiloPayload!

  """
  List reduced-scope requests for a data silo, designed primarily for logged-in users
  """
  listReducedRequestsForDataSiloAuthenticated(first: Int, offset: Int = 0, last: Int, input: BulkCompletionReducedRequestAuthenticatedInput!): ListReducedRequestsForDataSiloAuthenticatedPayload!

  """List lookup processes for a data silo"""
  lookupProcesses(input: LookupProcessInput!, first: Int, offset: Int = 0, last: Int, filterBy: LookupProcessFiltersInput, orderBy: [LookupProcessOrder!]): LookupProcessesPayload!

  """
  The types of identifiers that the organization can add. i.e. Email once but custom as many times as desired.
  """
  newIdentifierTypes: [NewIdentifierType!]!

  """Get the status of an oauth connection"""
  oauthConnectionStatus(input: OAuthConnectionStatusInput!): OauthConnectionStatusPayload!

  """The organization associated with the current user or API key"""
  organization: Organization!

  """List the mapping from TCF Purposes to Airgap Tracking Purposes"""
  orgTcfPurposes(input: OptionalAirgapBundleInput!, filterBy: OrgTcfPurposeFilterInput): OrgTcfPurposesPayload!

  """
  Query for the mapping from TCF Special Features to Airgap Tracking Purposes
  """
  orgTcfSpecialFeatures(input: OptionalAirgapBundleInput!, filterBy: OrgTcfSpecialFeatureFilterInput): OrgTcfSpecialFeaturesPayload!

  """TCF Special Purposes applicable for an organization"""
  orgTcfSpecialPurposes(input: AirgapBundleInput!): OrgTcfSpecialPurposesPayload!

  """
  The list of teams that can be connected from in the parent organization
  """
  parentOrganizationTeams(first: Int, offset: Int = 0, last: Int, filterBy: ParentTeamFiltersInput, orderBy: [TeamOrder!]): ParentOrganizationTeamsPayload!

  """List of pathfinder policies registered in the instance"""
  pathfinderPolicies(first: Int, offset: Int = 0, last: Int, filterBy: PathfinderPolicyFiltersInput, orderBy: [PathfinderPolicyOrder!]): PathfinderPoliciesPayload!

  """List of pathfinders registered in the instance"""
  pathfinders(first: Int, offset: Int = 0, last: Int, filterBy: PathfinderFiltersInput, orderBy: [PathfinderOrder!]): PathfindersPayload!

  """List the plugins associated with a data silo"""
  plugins(first: Int, offset: Int = 0, last: Int, filterBy: PluginsFiltersInput): PluginsPayload!

  """List out past scan runs for a given plugin"""
  pluginScans(first: Int, input: PluginScansInput!): PluginScansPayload!

  """List the data silos that could be dependencies of a given data silo"""
  possibleDataSiloDependencies(first: Int, offset: Int = 0, last: Int, filterBy: PossibleDataSiloDependencyFilterInput!): PossibleDataSiloDependenciesPayload!

  """Guess the privacy policy URL based on the domain name of the company"""
  predictPrivacyPolicyUrl: PredictPrivacyPolicyUrlPayload!

  """Get the preferences for an organization or user"""
  preference(filterBy: PreferenceFiltersInput!): PreferencePayload!

  """Query for all preference option values"""
  preferenceOptionValues(first: Int, offset: Int = 0, last: Int, filterBy: PreferenceOptionValueFilterInput): PreferenceOptionValuesPayload!

  """Query for all preference topics"""
  preferenceTopics(first: Int, offset: Int = 0, last: Int, filterBy: PreferenceTopicFilterInput): PreferenceTopicsPayload!

  """Configuration for an organization's privacy center"""
  privacyCenter(lookup: PrivacyCenterLookupInput): PrivacyCenterStringified!

  """The deployment metadata for a privacy center"""
  privacyCenterDeployment(input: PrivacyCenterIdInput!): PrivacyCenterDeployment!

  """Configuration for an organization's privacy center"""
  privacyCenterPolicies(lookup: PrivacyCenterLookupInput): [Policy!]!

  """Get the purposes configured for the privacy center"""
  privacyCenterPurposes(lookup: PrivacyCenterLookupInput): [PrivacyCenterTrackingPurposePreview!]!

  """The data subjects that are allowed to submit the form"""
  privacyCenterSubjects(lookup: PrivacyCenterLookupInput): [DataSubject!]!

  """
  The Tracking Technologies in use by the organization owning a privacy center
  """
  privacyCenterTrackingTechnology(lookup: PrivacyCenterLookupInput): [TrackingTechnology!]!

  """Grab all of the translations for a particular locale"""
  privacyCenterTranslatedMessages(input: TranslatedMessagesInput!, lookup: PrivacyCenterLookupInput): [PrivacyCenterTranslation!]!

  """Get either the deployed or saved privacy center version modules"""
  privacyCenterVersionModules(input: PrivacyCenterVersionModulesInput!): PrivacyCenterVersionModules

  """Get privacy center workflows"""
  privacyCenterWorkflows(lookup: PrivacyCenterLookupInput): PrivacyCenterWorkflowsPayload!

  """List the processing activities in the datamap"""
  processingActivities(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ProcessingActivitiesFiltersInput): ProcessingActivitiesPayload!

  """List the purposes of processing for an organization"""
  processingPurposes(first: Int, offset: Int = 0, last: Int, filterBy: ProcessingPurposeFiltersInput): ProcessingPurposesPayload!

  """List the purpose of processing sub categories for an organization"""
  processingPurposeSubCategories(first: Int, offset: Int = 0, last: Int, filterBy: ProcessingPurposeCategoryFiltersInput, useMaster: Boolean, isExportCsv: Boolean): ProcessingPurposeSubCategoriesPayload!

  """List out ProfileDataPoint metadata"""
  profileDataPoints(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: ProfileDataPointFiltersInput!, orderBy: [ProfileDataPointOrder!]): ProfileDataPointsPayload!

  """List the prompt groups"""
  promptGroups(first: Int, offset: Int = 0, last: Int, filterBy: PromptGroupFiltersInput, orderBy: [PromptGroupOrder!]): PromptGroupsPayload!

  """List the prompt partials"""
  promptPartials(first: Int, offset: Int = 0, last: Int, filterBy: PromptPartialFiltersInput, orderBy: [PromptPartialOrder!]): PromptPartialsPayload!

  """List the execution results for the prompts registered in the instance"""
  promptRuns(first: Int, offset: Int = 0, last: Int, filterBy: PromptRunFiltersInput, orderBy: [PromptRunOrder!]): PromptRunsPayload!

  """List the prompts"""
  prompts(first: Int, offset: Int = 0, last: Int, filterBy: PromptFiltersInput, orderBy: [PromptOrder!]): PromptsPayload!

  """
  Given a list of prompts, compile all of the necessary metadata that is needed to render the prompt
  """
  promptsWithVariables(input: PromptsWithVariablesInput!): PromptsWithVariablesPayload!

  """List of prompt threads registered in the instance"""
  promptThreads(first: Int, offset: Int = 0, last: Int, filterBy: PromptThreadFiltersInput, orderBy: [PromptThreadOrder!]): PromptThreadsPayload!

  """List of pull requests registered in the instance"""
  pullRequests(first: Int, offset: Int = 0, last: Int, filterBy: PullRequestFiltersInput, orderBy: [PullRequestOrder!]): PullRequestsPayload!

  """Return the list of consent tracking purposes for this organization."""
  purposes(first: Int, offset: Int = 0, last: Int, filterBy: TrackingPurposeFiltersInput, orderBy: [PurposeOrder!], input: TrackingPurposeInput): PurposesPayload!

  """
  Lookup consent preferences (intended for use by Customer-Ingress Sombra)
  """
  queryConsentPreferences(input: MCDConsentLookupInput!): ConsentPreferenceResponseSombra!

  """
  Return catalogs that match scans of this organization's website, and / or popular catalogs
  """
  recommendedCatalogs(input: RecommendedCatalogsInput!): RecommendedCatalogsPayload!

  """Query for fetching historical records of consent"""
  recordsOfConsent(input: RecordsOfConsentInput!, dhEncrypted: String!): RecordsOfConsentPayload!

  """List the repositories"""
  repositories(first: Int, offset: Int = 0, last: Int, filterBy: RepositoryFiltersInput, orderBy: [RepositoryOrder!]): RepositoriesPayload!

  """Get a request by id"""
  request(id: ID!): Request!

  """Get a data silo lookup for a particular request"""
  requestDataSilo(input: RequestDataSiloInput!): RequestDataSilo!

  """List out datapoints for a specific RequestDataSilo"""
  requestDataSiloDataPoints(first: Int, offset: Int = 0, last: Int, input: RequestDataSiloDataPointInput, id: ID!): RequestDataSiloDataPointsPayload!

  """Get the data silo statuses associated with a request"""
  requestDataSilos(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RequestDataSiloFiltersInput!, orderBy: [RequestDataSiloOrder!]): RequestDataSilosPayload!

  """List the enrichers for a given request"""
  requestEnrichers(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RequestEnrichersFiltersInput, orderBy: [RequestEnricherOrder!], input: RequestEnrichersInput!): RequestEnrichersPayload!

  """Get the files to include in a data subject access request download zip"""
  requestFiles(first: Int, offset: Int = 0, last: Int, filterBy: RequestFileFiltersInput!, orderBy: [RequestFileOrder!]): RequestFilesPayload!

  """Get files counts as if they were downloaded from privacy center"""
  requestFilesCountsOnly(filterBy: DownloadFileFiltersInput!): RequestFilesCountsOnlyPayload!

  """
  Get the files to include in a data subject access request download zip, but authenticated via a token magic link.
  """
  requestFilesToken(first: Int, offset: Int = 0, last: Int, filterBy: RequestFileTokenFiltersInput!, orderBy: [RequestFileOrder!], input: TokenInput): RequestFilesTokenPayload!

  """
  View the history of data subject requests submitted by a particular data subject.
  """
  requestHistory(first: Int, offset: Int = 0, last: Int, dhEncrypted: String, filterBy: RequestHistoryFiltersInput, orderBy: [RequestHistoryOrder!], lookup: PrivacyCenterLookupInput): RequestHistoryPayload!

  """List the identifiers for a given request"""
  requestIdentifiers(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RequestIdentifiersFiltersInput, orderBy: [RequestIdentifierOrder!], input: RequestIdentifiersInput!): RequestIdentifiersPayload!

  """List the request identity enrichment jobs for a given request"""
  requestIdentityEnrichmentJobs(first: Int, offset: Int = 0, last: Int, filterBy: RequestIdentityEnrichmentJobFiltersInput, input: RequestIdentityEnrichmentJobInput!): RequestIdentityEnrichmentJobsPayload!

  """List the data subject requests made to the logged in organization"""
  requests(first: Int, offset: Int = 0, last: Int, filterBy: RequestFiltersInput, orderBy: [RequestOrder!], input: RequestsContextInput, useMaster: Boolean, isExportCsv: Boolean): RequestsPayload!

  """
  List the data subject requests made to the logged in organization for a specified data silo
  """
  requestsForDataSilo(first: Int, offset: Int = 0, last: Int, filterBy: RequestFiltersForDataSiloInput): RequestsForDataSiloPayload!

  """
  Get stats for the number of requests processed in a year. Used for CCPA disclosure.
  """
  requestsProcessedDisclosureStats(lookup: PrivacyCenterLookupInput, input: RequestsProcessedDisclosureStatsInput): [RequestsProcessedDisclosureStatsByYear!]!

  """Get configured settings for the requests processed disclosure table"""
  requestsProcessedDisclosureStatsSettings(input: PrivacyCenterIdInput!): RequestsProcessedDisclosureStatsSettings!

  """Get retention schedules for the organization"""
  retentionSchedules(first: Int, offset: Int = 0, last: Int, filterBy: RetentionScheduleFiltersInput, useMaster: Boolean): RetentionSchedulesPayload!

  """List the risk categories"""
  riskCategories(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RiskCategoriesFiltersInput): RiskCategoriesPayload!

  """List the risk frameworks"""
  riskFrameworks(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RiskFrameworksFiltersInput): RiskFrameworksPayload!

  """List the risk levels"""
  riskLevels(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: RiskLevelsFiltersInput): RiskLevelsPayload!

  """
  Get a paginated list of saaSCategories and catalogs within those categories.
  """
  saaSCategories(first: Int, offset: Int = 0, last: Int, filterBy: SaaSCategoryFiltersInput, orderBy: [SaaSCategoryOrder!]): SaaSCategoriesPayload!

  """Get a paginated list of saaSCategory names."""
  saaSCategoryNames(filterBy: SaaSCategoryNamesFiltersInput): SaaSCategoryNamesPayload!

  """Fetch the savings configuration information for the org"""
  savingsConfiguration: SavingsConfigurationPreview!

  """The scanned colors for the currently-authorized organization"""
  scanColor: ScanColor

  """The purposeMap for an organization"""
  scanCookiePurposes(first: Int, offset: Int = 0, last: Int, filterBy: ScanCookiePurposeFiltersInput, orderBy: [ScanCookiePurposeOrder!]): ScanCookiePurposesPayload!

  """The purposeMap for an organization"""
  scanDomainPurposes(first: Int, offset: Int = 0, last: Int, filterBy: ScanDomainPurposeFiltersInput, orderBy: [ScanDomainPurposeOrder!]): ScanDomainPurposesPayload!

  """Return catalogs that match scans of this organization's website"""
  scannedCatalogs(first: Int, offset: Int = 0, last: Int): ScannedCatalogsPayload!

  """Get unique file types for a given data silo"""
  scannedObjectFileTypes(filterBy: ScannedObjectFileTypesFiltersInput!): ScannedObjectFileTypesPayload!

  """
  List the scannedObjects and scannedObjectPaths for a silo at a given level in the hierarchy
  """
  scannedObjectHierarchy(first: Int, offset: Int = 0, last: Int, filterBy: ScannedObjectHierarchyFiltersInput!): ScannedObjectHierarchyPayload!

  """
  List the path segments at a given level in the scanned object hierarchy
  """
  scannedObjectHierarchyPath(filterBy: ScannedObjectHierarchyPathFiltersInput): ScannedObjectHierarchyPathPayload!

  """All scopes that can be assigned to users or teams"""
  scopes(first: Int, offset: Int = 0, last: Int, filterBy: ScopeFiltersInput, orderBy: [ScopeOrder!]): ScopesPayload!

  """Return a paginated view of the sdks in our catalog"""
  sdks(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: SdkFiltersInput!, orderBy: [SdkOrder!]): SdksPayload!

  """Search catalogs by name (will return at most 100 matching results)"""
  searchCatalogs(input: CatalogSearchInput!): SearchCatalogsPayload!

  """List the sensitive categories"""
  sensitiveCategories(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: SensitiveCategoriesFiltersInput): SensitiveCategoriesPayload!

  """Lookup a signup code"""
  signupCode(input: SignupCodeInput!): SignupCode!

  """Count of the silo discovery recommendations for an organization"""
  siloDiscoveryPendingRecommendationCount(filterBy: SiloDiscoveryPendingConfirmationCountFiltersInput): SiloDiscoveryPendingRecommendationCountPayload!

  """List the silo discovery recommendations for an organization"""
  siloDiscoveryRecommendations(first: Int, input: SiloDiscoveryRecommendationsInput!, filterBy: SiloDiscoveryRecommendationFiltersInput): SiloDiscoveryRecommendationsPayload!

  """The site scan status for the currently-authorized organization"""
  sitescan: Sitescan

  """Retrieve metadata about a Slack instance from an OAuth connection"""
  slackWorkspaceMetadata: SlackWorkspaceMetadata!

  """List of software development kits in the instance"""
  softwareDevelopmentKits(first: Int, offset: Int = 0, last: Int, filterBy: SoftwareDevelopmentKitFiltersInput, orderBy: [SoftwareDevelopmentKitOrder!]): SoftwareDevelopmentKitsPayload!

  """List out the sombra API keys"""
  sombraApiKeys(filterBy: SombraApiKeysFilterInput, id: ID): [SombraApiKeyEntry!]!

  """List out the sombra changelog"""
  sombraChangelog: [SombraChangelogEntry!]!

  """List the sombras in an organization"""
  sombras(filterBy: SombraFilterInput, orderBy: [SombraOrder!]): [ConfiguredSombra!]!

  """The SSO information for the organization"""
  ssoProvider: SsoProvider

  """
  List out rolled-up errors encountered in scanning or classifying a property (aka subdatapoint)
  """
  subDataPointErrorRollup(first: Int, offset: Int = 0, last: Int, filterBy: SubDataPointErrorRollupFilterInput!): SubDataPointErrorRollupPayload!

  """List the subdatapoints for an organization"""
  subDataPoints(first: Int, offset: Int = 0, last: Int, filterBy: SubDataPointFiltersInput, useMaster: Boolean, isExportCsv: Boolean): SubDataPointsPayload!

  """Query for all TCF Features for a given Consent bundle"""
  tcfFeatures(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!): TcfFeaturesPayload!

  """Query to retrieve details for a specific TCF vendors"""
  tcfVendorDetails(first: Int, offset: Int = 0, last: Int, input: TCFVendorDetailsInput!): TcfVendorDetailsPayload!

  """Query for all TCF vendors"""
  tcfVendors(first: Int, offset: Int = 0, last: Int, input: AirgapBundleInput!, filterBy: TCFVendorFilterInput): TcfVendorsPayload!

  """The groupings of users within the organization"""
  teams(first: Int, offset: Int = 0, last: Int, filterBy: TeamFiltersInput, orderBy: [TeamOrder!]): TeamsPayload!

  """Paginate over the list of templates associated with the organization."""
  templates(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, orderBy: [TemplateOrder!], filterBy: TemplateFiltersInput): TemplatesPayload!

  """List out all messages that need to be translated (excludes policies)"""
  translatedMessages(input: TranslatedMessagesFilterInput): [Message!]!

  """Files discovered during Unstructured Data Discovery plugin runs"""
  unstructuredDataDiscoveryFiles(first: Int, offset: Int = 0, last: Int, filterBy: UnstructuredDataDiscoveryFilesFilterInput!): UnstructuredDataDiscoveryFilesPayload!

  """The list of data silos with unstructured discovery plugin available"""
  unstructuredDiscoverySilos(first: Int, offset: Int = 0, last: Int, filterBy: ContentClassificationDataSiloFiltersInput, orderBy: [DataSiloBulkPreviewOrder!]): UnstructuredDiscoverySilosPayload!

  """
  Fetch all the subdatapoint recommendations from our Unstructured Data Discovery scans
  """
  unstructuredSubDataPointRecommendations(first: Int, offset: Int = 0, last: Int, useMaster: Boolean, isExportCsv: Boolean, filterBy: UnstructuredSubDataPointRecommendationsFilterInput, orderBy: [UnstructuredSubDataPointRecommendationOrder!]): UnstructuredSubDataPointRecommendationsPayload!

  """The logger in user"""
  user: CurrentUser

  """The users in the organization"""
  users(first: Int, offset: Int = 0, last: Int, filterBy: UserFiltersInput, orderBy: [UserOrder!]): UsersPayload!

  """Gets a list of vendor communications that were sent for that data silo"""
  vendorCommunicationsMetadata(first: Int, offset: Int = 0, last: Int, input: VendorCommunicationsMetadataInput!): VendorCommunicationsMetadataPayload!

  """List the vendors in the datamap"""
  vendors(first: Int, offset: Int = 0, last: Int, filterBy: VendorsFiltersInput, orderBy: [VendorOrder!], useMaster: Boolean, isExportCsv: Boolean): VendorsPayload!

  """Get communications for a given workflow"""
  workflowCommunicationsSettings(input: WorkflowConfigIdInput!): WorkflowCommunicationsSettingsPayload!

  """get a workflowConfig"""
  workflowConfig(input: WorkflowConfigInput!): WorkflowConfigPayload!

  """Get enrichers for a given workflow"""
  workflowEnrichers(first: Int, offset: Int = 0, last: Int, input: WorkflowEnrichersInput!): WorkflowEnrichersPayload!

  """Get identifiers for a given workflow"""
  workflowIdentifiers(first: Int, offset: Int = 0, last: Int, input: WorkflowConfigIdInput!): WorkflowIdentifiersPayload!

  """List the workflows for the organization"""
  workflows(first: Int, offset: Int = 0, last: Int, filterBy: WorkflowFilterInput): WorkflowsPayload!
}

type Mutation {
  """Action item rescans"""
  actionItemRescans(input: ActionItemRescanInput!): ActionItemRescansPayload!

  """Add a data silo to open requests"""
  addDataSiloToOpenRequests(input: AddDataSiloToOpenRequestsInput!): AddDataSiloToOpenRequestsPayload!

  """adds a data silo to a workflow"""
  addDataSiloToWorkflowConfig(input: WorkflowDataSiloInput!): AddDataSiloToWorkflowConfigPayload!

  """Add an email domain to the current org"""
  addEmailDomain(input: CreateEmailDomainInput!): AddEmailDomainPayload!

  """Add a list of enrichers to a given workflow"""
  addEnrichersToWorkflowConfig(input: AddEnrichersToWorkflowConfigInput!): AddEnrichersToWorkflowConfigPayload!

  """Update an existing prompt run with additional messages"""
  addMessagesToPromptRun(input: AddMessagesToPromptRunInput!): AddMessagesToPromptRunPayload!

  """Add new signed and enriched identifiers."""
  addSignedIdentifiers(input: SignedIdentifiersInput!): AddSignedIdentifiersPayload!

  """
  Create or update data silo discovery results, to be classified by Transcend
  """
  addSiloDiscoveryResults(input: AddSiloDiscoveryResultInput!): AddSiloDiscoveryResultsPayload!

  """Add TCF stacks to an airgap bundle"""
  addTCFStacksToBundle(input: SetTCFStacksInput!): AddTcfStacksToBundlePayload!

  """Adds a user to your organization"""
  addUser(input: AddUserInput!): AddUserPayload!

  """Upsert User Preferences (intended for use by Customer-Ingress Sombra)"""
  adminUpsertPreferences(input: AdminUpsertPreferenceRecordsInput!): AdminUpsertPreferencesPayload!

  """Approve a request and send download link to user"""
  approveRequest(input: CommunicationInput!): ApproveRequestPayload!

  """
  Approve a request in the secondary state - this is approval after deletion is completed.
  """
  approveRequestSecondary(input: CommunicationInput!): ApproveRequestSecondaryPayload!

  """Assume a role into another organization"""
  assumeRole(id: ID!, publicKey: String!): AssumeRolePayload!

  """
  Cancel a request and notify the user that the request has been canceled
  """
  cancelRequest(input: CommunicationInput!): CancelRequestPayload!

  """Change the user's password from a logged out view, via a reset token"""
  changePassword(input: ChangePasswordInput!, publicKey: String!): ChangePasswordPayload!

  """Change the primary sombra gateway"""
  changePrimarySombra(id: ID!): ChangePrimarySombraPayload!

  """Mark a request data silo as completed"""
  changeRequestDataSiloStatus(input: UpdateRequestDataSiloStatusInput!): ChangeRequestDataSiloStatusPayload!

  """Mark a request data silo as completed"""
  changeRequestDataSiloStatuses(input: UpdateRequestDataSiloStatusesInput!): ChangeRequestDataSiloStatusesPayload!

  """Retrieve suggestions for purpose and service based on cookie values"""
  classifyCookies(input: ClassifyCookiesInput!): ClassifyCookiesPayload!

  """
  Retrieve suggestions for tracking type and service based on data flow values
  """
  classifyDataFlows(input: ClassifyDataFlowsInput!): ClassifyDataFlowsPayload!

  """Create a deep clone of a workflow"""
  cloneWorkflowConfig(input: WorkflowConfigIdInput!): CloneWorkflowConfigPayload!

  """Begin compiling a request that is queued"""
  compileRequest(id: ID!): CompileRequestPayload!

  """Paginated query for fetching employee consent preferences data"""
  consentPreferences(first: Int, input: ConsentPreferencesInput!, dhEncrypted: String!): ConsentPreferencesPayload!

  """Create an action item collection"""
  createActionItemCollection(input: CreateActionItemCollectionInput!): CreateActionItemCollectionPayload!

  """Create action items"""
  createActionItems(input: [CreateActionItemsInput!]!): CreateActionItemsPayload!

  """Subscribes a user to notifications for a list of action item types"""
  createActionItemSubscriptions(input: CreateActionItemSubscriptionsInput!): CreateActionItemSubscriptionsPayload!

  """Creates a new Prompt Template"""
  createAgent(input: CreateAgentInput!): CreateAgentPayload!

  """Creates a new agentFile"""
  createAgentFile(input: CreateAgentFileInput!): CreateAgentFilePayload!

  """Creates a new agent file"""
  createAgentFunction(input: CreateAgentFunctionInput!): CreateAgentFunctionPayload!

  """Create a new global organization API key"""
  createApiKey(input: ApiKeyInput!): CreateApiKeyPayload!

  """Creates a new application"""
  createApplication(input: CreateApplicationInput!): CreateApplicationPayload!

  """Creates a new AssessmentEmailSet"""
  createAssessmentEmailSet(input: CreateAssessmentEmailSetInput!): CreateAssessmentEmailSetPayload!

  """Bulk creates new assessmentFormComments"""
  createAssessmentFormComments(input: CreateAssessmentFormCommentsInput!): CreateAssessmentFormCommentsPayload!

  """Bulk create new assessment forms"""
  createAssessmentForms(input: CreateAssessmentFormsInput!): CreateAssessmentFormsPayload!

  """Creates a new Assessment Form Template"""
  createAssessmentFormTemplate(input: CreateAssessmentFormTemplateInput!): CreateAssessmentFormTemplatePayload!

  """Used by external users to create an assessment form."""
  createAssessmentFormToken(input: CreateAssessmentFormTokenInput!): CreateAssessmentFormTokenPayload!

  """Creates a new AssessmentGroup"""
  createAssessmentGroup(input: CreateAssessmentGroupInput!): CreateAssessmentGroupPayload!

  """Bulk creates new assessmentQuestionComments"""
  createAssessmentQuestionComments(input: CreateAssessmentQuestionCommentsInput!): CreateAssessmentQuestionCommentsPayload!

  """Bulk creates new AssessmentQuestions"""
  createAssessmentQuestions(input: [CreateAssessmentQuestionInput!]!): CreateAssessmentQuestionsPayload!

  """Creates a new AssessmentSection"""
  createAssessmentSection(input: CreateAssessmentSectionInput!): CreateAssessmentSectionPayload!

  """Bulk creates new assessmentSectionComments"""
  createAssessmentSectionComments(input: CreateAssessmentSectionCommentsInput!): CreateAssessmentSectionCommentsPayload!

  """Create an attribute key for an organization"""
  createAttributeKey(input: CreateAttributeKeyInput!): CreateAttributeKeyPayload!

  """Create an new attribute value"""
  createAttributeValues(input: [CreateAttributeValuesInput!]!): CreateAttributeValuesPayload!

  """Creates a schedule to run auditor"""
  createAuditorSchedule(input: AuditorScheduleInput!): CreateAuditorSchedulePayload!

  """Create a new businessEntity"""
  createBusinessEntity(input: CreateBusinessEntityInput!): CreateBusinessEntityPayload!

  """Creates a new code package"""
  createCodePackage(input: CreateCodePackageInput!): CreateCodePackagePayload!

  """Create a new consent manager"""
  createConsentManager(input: CreateConsentManagerInput!): CreateConsentManagerPayload!

  """Create a record for a custom UI module for Airgap"""
  createConsentManagerUI(input: CreateConsentManagerUIInput!): CreateConsentManagerUiPayload!

  """Create a new consent partition (only for parent orgs)"""
  createConsentPartition(input: CreateConsentPartitionInput!): CreateConsentPartitionPayload!

  """Creates a new contract"""
  createContract(input: CreateContractInput!): CreateContractPayload!

  """Creates a new contract scan"""
  createContractScan(input: CreateContractScanInput!): CreateContractScanPayload!

  """Create a new data collection"""
  createDataCollection(input: NewDataCollectionInput!): CreateDataCollectionPayload!

  """Create new data flows"""
  createDataFlows(input: CreateDataFlowInput!): CreateDataFlowsPayload!

  """Creates a new data report"""
  createDataReport(input: CreateDataReportInput!): CreateDataReportPayload!

  """Create shells for a list of data silos"""
  createDataSilos(input: [CreateDataSilosInput!]!): CreateDataSilosPayload!

  """Create a new data subcategory for an organization"""
  createDataSubCategory(input: CreateDataInventorySubCategoryInput!): CreateDataSubCategoryPayload!

  """Create an email sender address"""
  createEmailSenderAddress(input: CreateEmailSenderAddressInput!): CreateEmailSenderAddressPayload!

  """
  Create a new enricher that can resolve identifiers from one type to another
  """
  createEnricher(input: EnricherInput!, dhEncrypted: String): CreateEnricherPayload!

  """Create a new experience for an organization"""
  createExperience(input: CreateExperienceInput!): CreateExperiencePayload!

  """
  Create a new identifier that the organization allows data to be keyed by
  """
  createIdentifier(input: IdentifierInput!): CreateIdentifierPayload!

  """Create a new legal hold"""
  createLegalHolds(input: CreateLegalHoldInput!): CreateLegalHoldsPayload!

  """Create a new legal matter"""
  createLegalMatter(input: CreateLegalMatterInput!): CreateLegalMatterPayload!

  """Create a new on-premise sombra gateway instance"""
  createOnPremiseSombra(input: OnPremiseSombraInput!): CreateOnPremiseSombraPayload!

  """Mutation for bulk upserting consent applications"""
  createOrUpdateConsentApplications(input: CreateOrUpdateConsentApplicationInput!): CreateOrUpdateConsentApplicationsPayload!

  """Mutation for bulk upserting consent SDKs"""
  createOrUpdateConsentSdks(input: CreateOrUpdateConsentSdkInput!): CreateOrUpdateConsentSdksPayload!

  """Create or update consent services"""
  createOrUpdateConsentServices(input: CreateOrUpdateConsentServicesInput!): CreateOrUpdateConsentServicesPayload!

  """Create or update a consent site for an organization"""
  createOrUpdateConsentSite(input: CreateOrUpdateConsentSiteInput!): CreateOrUpdateConsentSitePayload!

  """create or update a consent workflow trigger"""
  createOrUpdateConsentWorkflowTrigger(input: CreateOrUpdateConsentWorkflowTriggerInput!): CreateOrUpdateConsentWorkflowTriggerPayload!

  """Create or update a preference for an organization"""
  createOrUpdateOrganizationPreference(input: CreateOrUpdatePreferenceInput!): CreateOrUpdateOrganizationPreferencePayload!

  """create or update preference option values"""
  createOrUpdatePreferenceOptionValues(input: CreateOrUpdatePreferenceOptionValuesInput!): CreateOrUpdatePreferenceOptionValuesPayload!

  """create or update a preference topic"""
  createOrUpdatePreferenceTopic(input: CreateOrUpdatePreferenceTopicInput!): CreateOrUpdatePreferenceTopicPayload!

  """Create or update a preference for a user"""
  createOrUpdateUserPreference(input: CreateOrUpdatePreferenceInput!): CreateOrUpdateUserPreferencePayload!

  """Creates a new pathfinder"""
  createPathfinder(input: CreatePathfinderInput!): CreatePathfinderPayload!

  """Creates a new pathfinder policy"""
  createPathfinderPolicy(input: CreatePathfinderPolicyInput!): CreatePathfinderPolicyPayload!

  """Create privacy center access tokens"""
  createPrivacyCenterAccessTokens(input: CreatePrivacyCenterAccessTokensInput!): CreatePrivacyCenterAccessTokensPayload!

  """Creates a new processing activity"""
  createProcessingActivity(input: CreateProcessingActivityInput!): CreateProcessingActivityPayload!

  """Create a new Purpose of Processing subcategory"""
  createProcessingPurposeSubCategory(input: CreateProcessingPurposeCategoryInput!): CreateProcessingPurposeSubCategoryPayload!

  """Creates a new Prompt"""
  createPrompt(input: CreatePromptInput!): CreatePromptPayload!

  """Creates a new Prompt Group"""
  createPromptGroup(input: CreatePromptGroupInput!): CreatePromptGroupPayload!

  """Creates a new Prompt Partial"""
  createPromptPartial(input: CreatePromptPartialInput!): CreatePromptPartialPayload!

  """Creates a new prompt thread"""
  createPromptThread(input: CreatePromptThreadInput!): CreatePromptThreadPayload!

  """Creates a new pull request"""
  createPullRequest(input: CreatePullRequestInput!): CreatePullRequestPayload!

  """Create a consent tracking purpose for an organization"""
  createPurpose(input: CreatePurposeInput!): CreatePurposePayload!

  """Creates a new repository"""
  createRepository(input: CreateRepositoryInput!): CreateRepositoryPayload!

  """Create new risk categories"""
  createRiskCategories(input: CreateRiskCategoriesInput!): CreateRiskCategoriesPayload!

  """Create new risk frameworks"""
  createRiskFrameworks(input: CreateRiskFrameworksInput!): CreateRiskFrameworksPayload!

  """Creates a new sensitive category"""
  createSensitiveCategory(input: CreateSensitiveCategoryInput!): CreateSensitiveCategoryPayload!

  """Creates a new software development kit"""
  createSoftwareDevelopmentKit(input: CreateSoftwareDevelopmentKitInput!): CreateSoftwareDevelopmentKitPayload!

  """Create a single subdatapoint"""
  createSubDataPoint(input: CreateSubDataPointInput!): CreateSubDataPointPayload!

  """Create a new classification of data subject"""
  createSubject(input: CreateSubjectInput!): CreateSubjectPayload!

  """Add a new team to the organization"""
  createTeam(input: TeamInput!): CreateTeamPayload!

  """Create a new data subject communication template"""
  createTemplate(input: TemplateInput!): CreateTemplatePayload!

  """Create a new vendor"""
  createVendor(input: CreateVendorInput!): CreateVendorPayload!

  """Create workflow with basic details"""
  createWorkflow(input: CreateWorkflowInput!): CreateWorkflowPayload!

  """
  Get the decryption context needed to download a zip of the files for a request on the privacy center
  """
  dataSubjectDownloadCEK(id: ID!, lookup: PrivacyCenterLookupInput, dhEncrypted: String!): DataSubjectDownloadCekPayload!

  """Update consent preferences for a given data subject identifier"""
  dataSubjectUpdateConsentPreferences(input: UpdateConsentPreferenceInput!, lookup: PrivacyCenterLookupInput, dhEncrypted: String!): DataSubjectUpdateConsentPreferencesPayload!

  """Delete action item collections"""
  deleteActionItemCollections(input: DeleteActionItemCollectionsInput!): DeleteActionItemCollectionsPayload!

  """Delete action items"""
  deleteActionItems(input: DeleteActionItemsInput!): DeleteActionItemsPayload!

  """
  Unsubscribes a user from a specific notification or all action item notifications
  """
  deleteActionItemSubscription(input: DeleteActionItemSubscriptionInput!): DeleteActionItemSubscriptionPayload!

  """Delete multiple agentFiles from an organization"""
  deleteAgentFiles(input: DeleteAgentFilesInput!): DeleteAgentFilesPayload!

  """Delete multiple agent functions from an organization"""
  deleteAgentFunctions(input: DeleteAgentFunctionsInput!): DeleteAgentFunctionsPayload!

  """Delete multiple agents from an organization"""
  deleteAgents(input: DeleteAgentsInput!): DeleteAgentsPayload!

  """Deletes an existing API key"""
  deleteApiKey(id: ID!): DeleteApiKeyPayload!

  """Delete multiple applications from an organization"""
  deleteApplications(input: DeleteApplicationsInput!): DeleteApplicationsPayload!

  """Delete multiple application users from an organization"""
  deleteApplicationUsers(input: DeleteApplicationUsersInput!): DeleteApplicationUsersPayload!

  """Delete multiple answer files from an organization"""
  deleteAssessmentAnswerFiles(input: DeleteAssessmentAnswerFilesInput!): DeleteAssessmentAnswerFilesPayload!

  """Delete multiple answer files from an organization via an auth token"""
  deleteAssessmentAnswerFilesToken(input: DeleteAssessmentAnswerFilesTokenInput!): DeleteAssessmentAnswerFilesTokenPayload!

  """Delete multiple assessmentEmailSets from an organization"""
  deleteAssessmentEmailSets(input: DeleteAssessmentEmailSetsInput!): DeleteAssessmentEmailSetsPayload!

  """Delete multiple assessmentFormComments from an organization"""
  deleteAssessmentFormComments(input: DeleteAssessmentFormCommentsInput!): DeleteAssessmentFormCommentsPayload!

  """Delete multiple assessmentForms from an organization"""
  deleteAssessmentForms(input: DeleteAssessmentFormsInput!): DeleteAssessmentFormsPayload!

  """Delete multiple assessmentFormTemplates from an organization"""
  deleteAssessmentFormTemplates(input: DeleteAssessmentFormTemplatesInput!): DeleteAssessmentFormTemplatesPayload!

  """Delete multiple assessmentGroups from an organization"""
  deleteAssessmentGroups(input: DeleteAssessmentGroupsInput!): DeleteAssessmentGroupsPayload!

  """Delete multiple assessmentQuestionComments from an organization"""
  deleteAssessmentQuestionComments(input: DeleteAssessmentQuestionCommentsInput!): DeleteAssessmentQuestionCommentsPayload!

  """Delete multiple assessmentQuestions from an organization"""
  deleteAssessmentQuestions(input: DeleteAssessmentQuestionsInput!): DeleteAssessmentQuestionsPayload!

  """Delete multiple assessmentSectionComments from an organization"""
  deleteAssessmentSectionComments(input: DeleteAssessmentSectionCommentsInput!): DeleteAssessmentSectionCommentsPayload!

  """Delete multiple assessmentSections from an organization"""
  deleteAssessmentSections(input: DeleteAssessmentSectionsInput!): DeleteAssessmentSectionsPayload!

  """Delete an attribute key"""
  deleteAttributeKey(input: DeleteAttributeKeyInput!): DeleteAttributeKeyPayload!

  """Delete an attribute value"""
  deleteAttributeValue(id: ID!): DeleteAttributeValuePayload!

  """Deletes auditor schedules, leaving the auditor runs intact"""
  deleteAuditorSchedules(input: DeleteAuditorSchedulesInput!): DeleteAuditorSchedulesPayload!

  """Remove business entities"""
  deleteBusinessEntities(input: DeleteBusinessEntitiesInput!): DeleteBusinessEntitiesPayload!

  """Delete multiple code packages from an organization"""
  deleteCodePackages(input: DeleteCodePackagesInput!): DeleteCodePackagesPayload!

  """Mutation for deleting consent applications"""
  deleteConsentApplications(input: DeleteConsentApplicationInput!): DeleteConsentApplicationsPayload!

  """Delete a consent partition (only for parent orgs)"""
  deleteConsentPartition(id: ID!): DeleteConsentPartitionPayload!

  """Mutation for deleting consent SDKs"""
  deleteConsentSdks(input: DeleteConsentSdkInput!): DeleteConsentSdksPayload!

  """Mutation for deleting consent Services"""
  deleteConsentServices(input: DeleteConsentServicesInput!): DeleteConsentServicesPayload!

  """(Soft) delete a consent site for an organization"""
  deleteConsentSite(input: DeleteConsentSiteInput!): DeleteConsentSitePayload!

  """deletes list of consent workflow triggers by id"""
  deleteConsentWorkflowTriggers(input: DeleteConsentWorkflowTriggersInput!): DeleteConsentWorkflowTriggersPayload!

  """Delete multiple contracts from an organization"""
  deleteContracts(input: DeleteContractsInput!): DeleteContractsPayload!

  """Delete multiple contract scans from an organization"""
  deleteContractScans(input: DeleteContractScansInput!): DeleteContractScansPayload!

  """Deletes cookies by some criteria"""
  deleteCookies(input: DeleteCookiesInput!): DeleteCookiesPayload!

  """Deletes data flows by some criteria"""
  deleteDataFlows(input: DeleteDataFlowsInput!): DeleteDataFlowsPayload!

  """Delete multiple datapoints from an organization"""
  deleteDataPoints(input: DeleteDataPointsInput!): DeleteDataPointsPayload!

  """Delete multiple data reports for an organization"""
  deleteDataReports(input: DeleteDataReportsInput!): DeleteDataReportsPayload!

  """Delete multiple data silos for an organization"""
  deleteDataSilos(input: DeleteDataSilosInput!): DeleteDataSilosPayload!

  """Delete data subcategories for an organization"""
  deleteDataSubCategories(input: DeleteDataSubCategoriesInput!): DeleteDataSubCategoriesPayload!

  """Delete an email domain from the current org"""
  deleteEmailDomain(input: CreateEmailDomainInput!): DeleteEmailDomainPayload!

  """Delete an email sender address"""
  deleteEmailSenderAddress(input: DeleteEmailSenderAddressInput!): DeleteEmailSenderAddressPayload!

  """Remove an existing enricher"""
  deleteEnricher(id: ID!): DeleteEnricherPayload!

  """Delete a list of experiences by id"""
  deleteExperiences(input: DeleteExperiencesInput!): DeleteExperiencesPayload!

  """Remove identifiers"""
  deleteIdentifiers(input: DeleteIdentifiersInput!): DeleteIdentifiersPayload!

  """Remove an existing legal hold"""
  deleteLegalHolds(input: DeleteLegalHoldsInput!): DeleteLegalHoldsPayload!

  """Remove legal matters"""
  deleteLegalMatters(input: DeleteLegalMattersInput!): DeleteLegalMattersPayload!

  """Delete multiple pathfinder policies from an organization"""
  deletePathfinderPolicies(input: DeletePathfinderPoliciesInput!): DeletePathfinderPoliciesPayload!

  """Delete multiple pathfinders from an organization"""
  deletePathfinders(input: DeletePathfindersInput!): DeletePathfindersPayload!

  """Delete the organization's privacy center policies"""
  deletePolicies(input: DeletePoliciesInput!): DeletePoliciesPayload!

  """deletes list of preference option values by id"""
  deletePreferenceOptionValues(input: DeletePreferenceOptionValuesInput!): DeletePreferenceOptionValuesPayload!

  """deletes list of preference topics by id"""
  deletePreferenceTopics(input: DeletePreferenceTopicsInput!): DeletePreferenceTopicsPayload!

  """Remove processing activities"""
  deleteProcessingActivities(input: DeleteProcessingActivitiesInput!): DeleteProcessingActivitiesPayload!

  """Delete processing purpose subcategories for an organization"""
  deleteProcessingPurposeSubCategories(input: DeletePurposeSubCategoriesInput!): DeleteProcessingPurposeSubCategoriesPayload!

  """Delete multiple prompt groups from an organization"""
  deletePromptGroups(input: DeletePromptGroupsInput!): DeletePromptGroupsPayload!

  """Delete multiple prompt partials from an organization"""
  deletePromptPartials(input: DeletePromptPartialsInput!): DeletePromptPartialsPayload!

  """Delete multiple prompts from an organization"""
  deletePrompts(input: DeletePromptsInput!): DeletePromptsPayload!

  """Delete multiple prompt threads from an organization"""
  deletePromptThreads(input: DeletePromptThreadsInput!): DeletePromptThreadsPayload!

  """Delete multiple pull requests from an organization"""
  deletePullRequests(input: DeletePullRequestsInput!): DeletePullRequestsPayload!

  """Delete an existing consent tracking purposes for an organization"""
  deletePurposes(input: DeletePurposesInput!): DeletePurposesPayload!

  """Delete multiple repositories from an organization"""
  deleteRepositories(input: DeleteRepositoriesInput!): DeleteRepositoriesPayload!

  """Remove a specific file from a request"""
  deleteRequestFile(id: ID!): DeleteRequestFilePayload!

  """Remove a specific file from a request using a magic link"""
  deleteRequestFileToken(id: ID!, input: TokenInput!): DeleteRequestFileTokenPayload!

  """Remove risk categories"""
  deleteRiskCategories(input: DeleteRiskCategoriesInput!): DeleteRiskCategoriesPayload!

  """Remove risk frameworks"""
  deleteRiskFrameworks(input: DeleteRiskFrameworksInput!): DeleteRiskFrameworksPayload!

  """Remove sensitive categories"""
  deleteSensitiveCategories(input: DeleteSensitiveCategoriesInput!): DeleteSensitiveCategoriesPayload!

  """Delete multiple software development kits from an organization"""
  deleteSoftwareDevelopmentKits(input: DeleteSoftwareDevelopmentKitsInput!): DeleteSoftwareDevelopmentKitsPayload!

  """Delete multiple subdatapoints from an organization"""
  deleteSubDataPoints(input: DeleteSubDataPointsInput!): DeleteSubDataPointsPayload!

  """Delete a data subject"""
  deleteSubject(id: ID!, skipPublish: Boolean): DeleteSubjectPayload!

  """Remove a team from the organization"""
  deleteTeam(id: ID!): DeleteTeamPayload!

  """Delete an existing communication template"""
  deleteTemplate(id: ID!): DeleteTemplatePayload!

  """Remove vendors"""
  deleteVendors(input: DeleteVendorsInput!): DeleteVendorsPayload!

  """Deletes a workflow"""
  deleteWorkflow(input: DeleteWorkflowInput!): DeleteWorkflowPayload!

  """Deploy the CloudFront distribution for an organization"""
  deployCloudfront(input: PrivacyCenterIdInput!): DeployCloudfrontPayload!

  """Deploy a new consent manager with the current configuration."""
  deployConsentManagerBundle(id: ID!, input: DeployConsentManagerInput!): DeployConsentManagerBundlePayload!

  """Deploy the saved privacy center version"""
  deployPrivacyCenterVersion(input: DeployPrivacyCenterVersionInput!): DeployPrivacyCenterVersionPayload!

  """Destroy the current user's account"""
  destroyAccount(input: DestroyUserInput!): DestroyAccountPayload!

  """Determine how to login an email address"""
  determineLoginMethod(input: LoginDetailsInput!): DetermineLoginMethodPayload!

  """Disable or enable a list of experiences by id"""
  disableExperiences(input: DisableExperiencesInput!): DisableExperiencesPayload!

  """Disable a user account"""
  disableUserAccount(id: ID!): DisableUserAccountPayload!

  """Duplicate an existing API key with a fresh secret"""
  duplicateApiKey(id: ID!): DuplicateApiKeyPayload!

  """
  Get the decryption context needed to download a zip of the files for a request
  """
  employeeDownloadCEK(id: ID!, dhEncrypted: String!): EmployeeDownloadCekPayload!

  """Submit a data subject request as an employee in the organization"""
  employeeMakeDataSubjectRequest(input: EmployeeRequestInput!, dhEncrypted: String): EmployeeMakeDataSubjectRequestPayload!

  """
  Submit a data subject request as an employee in the organization (bulk)
  """
  employeeMakeDataSubjectRequests(input: [EmployeeRequestInput!]!, dhEncrypted: String): EmployeeMakeDataSubjectRequestsPayload!

  """ReSign the encrypted CEK context for each of the given requests"""
  employeeReSignEncryptedCEKContexts(input: ReSignEncryptedCEKContextsInput!, dhEncrypted: String!): EmployeeReSignEncryptedCekContextsPayload!

  """Update consent preferences for a list of identifiers"""
  employeeUpdateConsentPreferences(input: UpdateConsentPreferenceInput!, dhEncrypted: String!): EmployeeUpdateConsentPreferencesPayload!

  """
  Update attested identifiers on the request as an employee in the organization
  """
  employeeUpdateRequestIdentifiers(input: EmployeeUpdateRequestIdentifiersInput!, dhEncrypted: String!): EmployeeUpdateRequestIdentifiersPayload!

  """Enable a user account"""
  enableUserAccount(id: ID!): EnableUserAccountPayload!

  """
  Run a prompt and return the results. The results will also be available via the promptRuns query.
  """
  executePromptRun(input: ExecutePromptRunInput!): ExecutePromptRunPayload!

  """Expires a Sombra API key"""
  expireSombraApiKey(id: ID!): ExpireSombraApiKeyPayload!

  """Fetch metadata for configuring an enrichment check"""
  fetchEnrichmentMetadataForDataSilo(id: ID!, input: FetchEnrichmentMetadataInput!): FetchEnrichmentMetadataForDataSiloPayload!

  """Manually fire the secondary action for a request"""
  fireSecondaryAction(input: FireSecondaryActionInput!): FireSecondaryActionPayload!

  """Create a consent identifier encryption key"""
  generateConsentIdentifierEncryptionKey(dhEncrypted: String!): GenerateConsentIdentifierEncryptionKeyPayload!

  """
  Generate the SQL statements for a data silo based on the classifications
  """
  generateDataSiloSqlStatements(input: GenerateSqlInput!): GenerateDataSiloSqlStatementsPayload!

  """Generate a login token for the parent privacy center"""
  generateParentPrivacyCenterLoginToken(lookup: PrivacyCenterLookupInput, dhEncrypted: String!): GenerateParentPrivacyCenterLoginTokenPayload!

  """Bulk import Onetrust assessment forms"""
  importOneTrustAssessmentForms(input: ImportOnetrustAssessmentsInput!): ImportOneTrustAssessmentFormsPayload!

  """Starts a sitescan"""
  initiateSitescan: InitiateSitescanPayload!

  """
  Invalidate an email token that was sent for onboarding purposes to the wrong individual. This is the "not you" link.
  """
  invalidateUserEmail(input: TokenInput!): InvalidateUserEmailPayload!

  """Create an API key to use with Sombra"""
  issueSombraApiKey(id: ID!): IssueSombraApiKeyPayload!

  """
  Check if the currently logged in user has a valid sombra session. If session is invalid but transcend employee authentication is enabled, a new sombra session will be returned.
  """
  isUserAuthenticated(dhEncrypted: String!, publicKey: String!): IsUserAuthenticatedPayload!

  """Launch the organization's privacy page on its own domain"""
  launchPrivacyCenter(input: PrivacyCenterIdInput!): LaunchPrivacyCenterPayload!

  """Load the privacy policy from an external URL into the transcend."""
  loadPrivacyPolicy(input: LoadPrivacyPolicyInput!): LoadPrivacyPolicyPayload!

  """Store the reply to a request email in the database."""
  logEmailReply(input: LogEmailReplyInput!): LogEmailReplyPayload!

  """Log into the admin dashboard"""
  login(input: LoginInput!, publicKey: String!): LoginPayload!

  """Authenticate to sombra with a token, and get back a decryption context"""
  loginToSombraWithToken(id: ID!, publicKey: String!, input: TokenInput!): LoginToSombraWithTokenPayload!

  """Logout of the admin dashboard"""
  logout: LogoutPayload!

  """
  Log the sending of a request email in our database with information on how to handle the response later
  """
  logSentRequestEmail(input: LogSentRequestEmailInput!): LogSentRequestEmailPayload!

  """Data subject submitted a data subject request"""
  makeDataSubjectRequest(input: RequestInput!, lookup: PrivacyCenterLookupInput, dhEncrypted: String!): MakeDataSubjectRequestPayload!

  """Data subject submitted a data subject request (bulk version)"""
  makeDataSubjectRequests(input: [RequestInput!]!, lookup: PrivacyCenterLookupInput, dhEncrypted: String!): MakeDataSubjectRequestsPayload!

  """
  Mark a given sync endpoint as the default one, to be included in the generated airgap bundle configuration
  """
  makeDefaultSyncEndpoint(id: ID!, input: MakeDefaultSyncEndpointInput!): MakeDefaultSyncEndpointPayload!

  """
  Manually call dataSilo.refresh then dataSilo.test() and return response
  """
  manuallyTestAndRefreshDataSilo(id: ID!): ManuallyTestAndRefreshDataSiloPayload!

  """
  Manually mark all link-only Request Files as Ready, associated with the given Request Data Silo
  """
  markLinkOnlyRequestFilesAsReady(input: MarkLinkOnlyRequestFileAsReadyInput!): MarkLinkOnlyRequestFilesAsReadyPayload!

  """
  Mark data silo recommendations as a duplicate of some existing data silo entry
  """
  markSiloRecommendationsDuplicate(input: [MarkSiloRecommendationsDuplicateInput!]!): MarkSiloRecommendationsDuplicatePayload!

  """
  Mark data silo recommendations as junk so they do not appear on your Data Inventory table
  """
  markSiloRecommendationsJunk(input: [MarkSiloRecommendationsJunkInput!]!): MarkSiloRecommendationsJunkPayload!

  """
  Notify that data subject that additional time is needed to complete the request
  """
  notifyAdditionalTime(input: AdditionalTimeInput!): NotifyAdditionalTimePayload!

  """Link an OAuth account to a user"""
  oauthLink(input: OAuthLinkInput!): OauthLinkPayload!

  """Revoke an OAuth Token"""
  oauthRevoke(input: OAuthRevokeInput!): OauthRevokePayload!

  """Get an OAuth token"""
  oauthToken(input: OAuthTokenInput!): OauthTokenPayload!

  """Place an active request on hold"""
  placeRequestOnHold(id: ID!): PlaceRequestOnHoldPayload!

  """Login to the privacy center via email magic link"""
  privacyCenterEmailLogin(lookup: PrivacyCenterLookupInput, input: EmailLoginInput!): PrivacyCenterEmailLoginPayload!

  """Enqueues cookies in NEEDS_REVIEW status to be re-classified"""
  reClassifyCookies(id: ID!): ReClassifyCookiesPayload!

  """Enqueues data flows in NEEDS_REVIEW status to be re-classified"""
  reClassifyDataFlows(id: ID!): ReClassifyDataFlowsPayload!

  """Reconnects a third party SaaS tool"""
  reconnectDataSilo(input: ReconnectDataSiloInput!, dhEncrypted: String!): ReconnectDataSiloPayload!

  """Set the redaction indices for subjective request files"""
  redactRequestFiles(input: RedactRequestFilesInput!): RedactRequestFilesPayload!

  """Forces the plugin to refetch samples for a list of subdatapoints"""
  refetchSubDataPointSample(input: RefetchSubDataPointSampleInput!): RefetchSubDataPointSamplePayload!

  """remove a data silo from a workflow"""
  removeDataSiloFromWorkflowConfig(input: WorkflowDataSiloInput!): RemoveDataSiloFromWorkflowConfigPayload!

  """Remove a list of enrichers from a given workflow"""
  removeEnrichersFromWorkflowConfig(input: RemoveEnrichersFromWorkflowConfigInput!): RemoveEnrichersFromWorkflowConfigPayload!

  """Remove a set of RequestIdentifiers on a request"""
  removeRequestIdentifiers(input: RemoveRequestIdentifiersInput!): RemoveRequestIdentifiersPayload!

  """Remove a sombra instance"""
  removeSombra(id: ID!): RemoveSombraPayload!

  """Remove TCF stacks from an airgap bundle"""
  removeTCFStacksFromBundle(input: SetTCFStacksInput!): RemoveTcfStacksFromBundlePayload!

  """Remove a user from the organization"""
  removeUser(id: ID, input: RemoveUserInput): RemoveUserPayload!

  """
  When executing a prompt that runs in a separate application, this endpoint can be used to report the status of the prompt run.
  """
  reportPromptRun(input: ReportPromptRunInput!): ReportPromptRunPayload!

  """Request a new certificate"""
  requestCertificate(input: PrivacyCenterIdInput!): RequestCertificatePayload!

  """
      Request a demo to our backend.
  This is not a real demo request and is used solely for testing.
  """
  requestDemo(input: DemoInput!): RequestDemoPayload!

  """Updates a request email to mark that it bounced & has failed"""
  requestEmailBounced(input: RequestEmailBouncedInput!): RequestEmailBouncedPayload!

  """Request a new data silo token be sent to the configured email"""
  requestNewDataSiloToken(input: RequestNewDataSiloTokenInput!): RequestNewDataSiloTokenPayload!

  """Rescan Plugin Permissions"""
  reScanPluginPermissions(input: UpdatePluginInput!): ReScanPluginPermissionsPayload!

  """Reset the rate limit values for a data silo"""
  resetDataSiloRateLimitsToDefault(id: ID!): ResetDataSiloRateLimitsToDefaultPayload!

  """Reset a password from a logged out view"""
  resetUserPassword(input: ResetPasswordInput!): ResetUserPasswordPayload!

  """ReSign the SaaS contexts for each of the given data silos"""
  reSignSaaSContexts(input: ReSignSaaSContextsInput!, dhEncrypted: String!): ReSignSaaSContextsPayload!

  """
  Re-classify the subDataPoints of a data silo (that were discovered via Structured Discovery)
  """
  restartSiloClassification(input: RestartSiloClassificationInput!): RestartSiloClassificationPayload!

  """
  Re-classify the scanned objects of a data silo (that were discovered via Unstructured Discovery)
  """
  restartSiloObjectClassifications(input: RestartSiloObjectClassificationsInput!): RestartSiloObjectClassificationsPayload!

  """Resume processing of a request that is placed on hold"""
  resumeRequest(id: ID!): ResumeRequestPayload!

  """
  Retry all of the errors for a particular data silo, returning the updated data silo
  """
  retryDataSiloErrors(id: ID!): RetryDataSiloErrorsPayload!

  """
  Retry all of the errors for a particular enricher, returning the updated enricher
  """
  retryEnricherErrors(id: ID!): RetryEnricherErrorsPayload!

  """Re-run a datapoint resolver for a specific profile"""
  retryProfileDataPoint(id: ID!, input: RetryProfileDataPointInput): RetryProfileDataPointPayload!

  """
  Re-run a datapoint resolver for a specific profile in a secondary state
  """
  retryProfileDataPointSecondary(id: ID!): RetryProfileDataPointSecondaryPayload!

  """
  Retry a RequestDataSilo and begin compilation process from scratch (note cannot be done after secondary action)
  """
  retryRequestDataSilo(id: ID!): RetryRequestDataSiloPayload!

  """Retry a request enricher that is not in a completed state"""
  retryRequestEnricher(id: ID!): RetryRequestEnricherPayload!

  """
  Reveal the consent identifier encryption key, for customers to copy and add to their backend for managed consent
  """
  revealConsentIdentifierEncryptionKey(dhEncrypted: String!): RevealConsentIdentifierEncryptionKeyPayload!

  """
  Reveal the root sombra secret, for the purposes of migrating the gateway on-premise
  """
  revealRootSombraSecret(dhEncrypted: String!): RevealRootSombraSecretPayload!

  """Login to the privacy center via sombra"""
  revokeRequest(dhEncrypted: String!, id: ID!, lookup: PrivacyCenterLookupInput): RevokeRequestPayload!

  """Rollback to a previous version of an airgap bundle"""
  rollbackAirgapBundle(id: ID!, input: RollbackAirgapBundleInput!): RollbackAirgapBundlePayload!

  """Rotate Sombra root keys"""
  rotateSombraRootKeys(dhEncrypted: String!): RotateSombraRootKeysPayload!

  """Executes the Web Auditor on a given URL"""
  runAuditor(input: AuditorRunInput!): RunAuditorPayload!

  """Run a Custom Function"""
  runCustomFunction(input: RunCustomFunctionInput!, dhEncrypted: String): RunCustomFunctionPayload!

  """Save the Prompt a vendor request completion status"""
  savePaVCompletionStatus(input: MarkBulkRequestsAsCompletedInput!): SavePaVCompletionStatusPayload!

  """Select the answers for an assessment question"""
  selectAssessmentQuestionAnswers(input: SelectAssessmentQuestionAnswerInput!): SelectAssessmentQuestionAnswersPayload!

  """Select the answers for an assessment question via an auth token"""
  selectAssessmentQuestionAnswersToken(input: SelectAssessmentQuestionAnswersTokenInput!): SelectAssessmentQuestionAnswersTokenPayload!

  """Signs up a completely new user and organization via onboarding wizard"""
  selfServeSignup(input: SelfServeSignupInput!): SelfServeSignupPayload!

  """Send an arbitrary message to the data subject"""
  sendCommunication(input: SendMessageInput!, dhEncrypted: String!): SendCommunicationPayload!

  """
  Send a test email through sombra to verify everything is setup correctly
  """
  sendTestEmail(input: SendTestEmailInput!): SendTestEmailPayload!

  """Sends the email to invite a user to your organization"""
  sendUserInviteEmail(input: SendUserInviteEmailInput!): SendUserInviteEmailPayload!

  """set TCF stacks for an airgap bundle"""
  setAirgapBundleTcfStacks(input: SetTCFStacksInput!): SetAirgapBundleTcfStacksPayload!

  """
  Sets allow-list of destinations that notifications can be sent to e.g. slack
  """
  setOrgNotificationDestinationAllowList(input: AllowNotificationDestinationsInput!): SetOrgNotificationDestinationAllowListPayload!

  """Set configured settings for the requests processed disclosure table"""
  setRequestsProcessedDisclosureStatsSettings(input: RequestsProcessedDisclosureStatsSettingsInput!): SetRequestsProcessedDisclosureStatsSettingsPayload!

  """Set the attributeValues associated with a given resource"""
  setResourceAttributes(input: SetResourceAttributesInput!): SetResourceAttributesPayload!

  """Specify a list of custom domains hosting the sync endpoint"""
  setSyncEndpoints(id: ID!, input: SetSyncEndpointInput!): SetSyncEndpointsPayload!

  """Update secret for signing and verifying JWTs"""
  setTokenSecret(input: TokenSecretInput!): SetTokenSecretPayload!

  """Mutation for showing or hiding a given vendor in the TCF UI"""
  showTcfVendorInUI(input: ShowTCFVendorInput!): ShowTcfVendorInUiPayload!

  """Skip a RequestEnricher from processing"""
  skipRequestEnricher(id: ID!): SkipRequestEnricherPayload!

  """Login to the privacy center via sombra"""
  sombraDataSubjectLogin(dhEncrypted: String!, lookup: PrivacyCenterLookupInput): SombraDataSubjectLoginPayload!

  """Sync a Single-Tenant Sombra instance's configuration to the database"""
  sombraSingleTenantConfigSync(input: SombraSingleTenantConfigSyncInput!): SombraSingleTenantConfigSyncPayload!

  """Store the colors found by the sitescanner service"""
  storeColors(input: StoreColorsInput!): StoreColorsPayload!

  """Create the cookie results found by the sitescanner service"""
  storeCookiePurposeResults(input: CreateScanCookiePurposesInput!): StoreCookiePurposeResultsPayload!

  """Create the sitescan results found by the sitescanner service"""
  storeDomainPurposeResults(input: CreateScanDomainPurposesInput!): StoreDomainPurposeResultsPayload!

  """
  Used by external users to submit an assessment form for review with an auth token.
  """
  submitAssessmentFormForReviewToken(input: TokenInput!): SubmitAssessmentFormForReviewTokenPayload!

  """
  Test a basic connection from an integrations lambda to a Sombra gateway
  """
  testIntegrationsSombraConnectivity(id: ID!): TestIntegrationsSombraConnectivityPayload!

  """Test employee authentication for a specific sombra gateway"""
  testSombraEmployeeAuthentication(id: ID!, dhEncrypted: String!): TestSombraEmployeeAuthenticationPayload!

  """Test a basic connection to a sombra gateway"""
  testSombraGatewayConnection(id: ID!): TestSombraGatewayConnectionPayload!

  """Make a communication email as read or unread"""
  toggleCommunicationRead(input: ToggleCommunicationReadInput!): ToggleCommunicationReadPayload!

  """Toggle the consent manager enforcement on/off"""
  toggleConsentManagerEnforcement(input: ToggleConsentManagerEnforcementInput!): ToggleConsentManagerEnforcementPayload!

  """Toggle the Consent Resolution Precedence for the Consent Manager."""
  toggleConsentPrecedence(input: ToggleConsentPrecedenceInput!): ToggleConsentPrecedencePayload!

  """
  Toggle the active status of a datapoint action or a set of datapoint actions
  """
  toggleDataPointActions(input: ToggleDataPointActionsInput!): ToggleDataPointActionsPayload!

  """Enable/disable existing consent tracking purposes for an organization"""
  togglePurposeActive(input: TogglePurposeActiveInput!): TogglePurposeActivePayload!

  """Whether the subject type is turned on or not"""
  toggleSubject(input: ToggleSubjectInput!): ToggleSubjectPayload!

  """Toggle the telemetry partitioning strategy for the Consent Manager."""
  toggleTelemetryPartitioning(input: ToggleTelemetryPartitionStrategyInput!): ToggleTelemetryPartitioningPayload!

  """Toggle the unknown cookie policy for the Consent Manager."""
  toggleUnknownCookiePolicy(input: ToggleUnknownCookiePolicyInput!): ToggleUnknownCookiePolicyPayload!

  """Toggle the unknown request policy for the Consent Manager."""
  toggleUnknownRequestPolicy(input: ToggleUnknownRequestPolicyInput!): ToggleUnknownRequestPolicyPayload!

  """Opt-in to using default TCF Settings"""
  toggleUseDefaultTcfSettings(input: ToggleUseDefaultTcfSettingsInput!): ToggleUseDefaultTcfSettingsPayload!

  """
  Update preferences and trigger DSR for a data subject without authentication
  """
  unauthenticatedPreferenceUpdate(input: UpdateConsentPreferenceInput!, lookup: PrivacyCenterLookupInput, dhEncrypted: String!): UnauthenticatedPreferenceUpdatePayload!

  """Unwrap a custom function"""
  unwrapCustomFunction(input: UnwrapCustomFunctionInput!, dhEncrypted: String!): UnwrapCustomFunctionPayload!

  """Unwrap the subject and body of a request email"""
  unwrapEmailContents(input: DecryptCommunicationInput!, dhEncrypted: String!): UnwrapEmailContentsPayload!

  """
  Unwraps file snippets for the specified file recommendations and returns their decryption contexts.
  """
  unwrapFileSnippets(input: UnwrapFileSnippetFiltersInput!, dhEncrypted: String!): UnwrapFileSnippetsPayload!

  """Unwrap identifier for a profile"""
  unwrapProfileIdentifier(id: ID!, dhEncrypted: String!): UnwrapProfileIdentifierPayload!

  """Unwrap identifier for a request"""
  unwrapRequestIdentifier(id: ID!, dhEncrypted: String!): UnwrapRequestIdentifierPayload!

  """
  Unwraps sample data for the specified sub data points and returns their decryption contexts.
  """
  unwrapSubDataPointSamples(input: UnwrapSubDataPointSamplesFiltersInput!, dhEncrypted: String!): UnwrapSubDataPointSamplesPayload!

  """Update the configuration for a request action"""
  updateAction(input: UpdateActionInput!): UpdateActionPayload!

  """Update an action item collection"""
  updateActionItemCollection(input: UpdateActionItemCollectionInput!): UpdateActionItemCollectionPayload!

  """Bulk update the metadata for one or more existing action items"""
  updateActionItems(input: UpdateActionItemsInput!): UpdateActionItemsPayload!

  """Updates a set of agentFiles"""
  updateAgentFiles(input: UpdateAgentFilesInput!): UpdateAgentFilesPayload!

  """Updates a set of agent functions"""
  updateAgentFunctions(input: UpdateAgentFunctionsInput!): UpdateAgentFunctionsPayload!

  """Updates a set of agents"""
  updateAgents(input: UpdateAgentsInput!): UpdateAgentsPayload!

  """Updates an existing API key"""
  updateApiKey(input: UpdateApiKeyInput!): UpdateApiKeyPayload!

  """Updates a set of applications"""
  updateApplications(input: UpdateApplicationsInput!): UpdateApplicationsPayload!

  """Updates an AssessmentEmailSet"""
  updateAssessmentEmailSet(input: UpdateAssessmentEmailSetInput!): UpdateAssessmentEmailSetPayload!

  """Updates an AssessmentForm"""
  updateAssessmentForm(input: UpdateAssessmentFormInput!): UpdateAssessmentFormPayload!

  """Bulk updates assessmentFormComments"""
  updateAssessmentFormComments(input: UpdateAssessmentFormCommentsInput!): UpdateAssessmentFormCommentsPayload!

  """Updates and AssessmentQuestion within a form"""
  updateAssessmentFormQuestion(input: UpdateAssessmentFormQuestionInput!): UpdateAssessmentFormQuestionPayload!

  """Updates multiple assessment form sections"""
  updateAssessmentFormSections(input: updateAssessmentFormSectionsInput!): UpdateAssessmentFormSectionsPayload!

  """Updates an Assessment Form Template"""
  updateAssessmentFormTemplate(input: UpdateAssessmentFormTemplateInput!): UpdateAssessmentFormTemplatePayload!

  """Updates an AssessmentGroup"""
  updateAssessmentGroup(input: UpdateAssessmentGroupInput!): UpdateAssessmentGroupPayload!

  """Bulk updates assessmentQuestionComments"""
  updateAssessmentQuestionComments(input: [UpdateAssessmentQuestionCommentInput!]!): UpdateAssessmentQuestionCommentsPayload!

  """Bulk updates assessmentSectionComments"""
  updateAssessmentSectionComments(input: [UpdateAssessmentSectionCommentInput!]!): UpdateAssessmentSectionCommentsPayload!

  """Updates and AssessmentQuestion"""
  updateAssessmentTemplateQuestion(input: UpdateAssessmentTemplateQuestionInput!): UpdateAssessmentTemplateQuestionPayload!

  """Updates an assessment template section"""
  updateAssessmentTemplateSection(input: UpdateAssessmentTemplateSectionInput!): UpdateAssessmentTemplateSectionPayload!

  """Update an attribute key"""
  updateAttributeKey(input: UpdateAttributeKeyInput!): UpdateAttributeKeyPayload!

  """Update attribute values"""
  updateAttributeValues(input: [UpdateAttributeValueInput!]!): UpdateAttributeValuesPayload!

  """Updates auditor schedules"""
  updateAuditorSchedule(input: UpdateAuditorScheduleInput!): UpdateAuditorSchedulePayload!

  """Update the configuration of a business entity"""
  updateBusinessEntities(input: UpdateBusinessEntitiesInput!): UpdateBusinessEntitiesPayload!

  """Updates a set of code packages"""
  updateCodePackages(input: UpdateCodePackagesInput!): UpdateCodePackagesPayload!

  """Update the consent manager settings"""
  updateConsentManager(id: ID!, input: UpdateConsentManagerInput!): UpdateConsentManagerPayload!

  """
  Modifies the domain list that the Consent Manager is allowed to run on.
  """
  updateConsentManagerDomains(input: UpdateDomainListInput!): UpdateConsentManagerDomainsPayload!

  """Update the onboarding status of a consent manager"""
  updateConsentManagerOnboardingStatus(input: UpdateConsentManagerOnboardingStatusInput!): UpdateConsentManagerOnboardingStatusPayload!

  """Update the key used to partition consent records."""
  updateConsentManagerPartition(input: UpdateConsentManagerPartitionInput!): UpdateConsentManagerPartitionPayload!

  """Update the consent manager's theme settings"""
  updateConsentManagerTheme(input: UpdateConsentManagerThemeInput!): UpdateConsentManagerThemePayload!

  """
  Updates consent manager to the latest airgap.js version and deploys the change immediately
  """
  updateConsentManagerToLatestVersion(id: ID!, input: DeployConsentManagerInput!): UpdateConsentManagerToLatestVersionPayload!

  """Updates a set of contracts"""
  updateContracts(input: UpdateContractsInput!): UpdateContractsPayload!

  """Updates a set of contract scans"""
  updateContractScans(input: UpdateContractScansInput!): UpdateContractScansPayload!

  """Update or Create a Custom Function's code or context"""
  updateCustomFunction(input: UpdateCustomFunctionInput!, dhEncrypted: String!): UpdateCustomFunctionPayload!

  """Update a data flow"""
  updateDataFlows(input: UpdateDataFlowsInput!): UpdateDataFlowsPayload!

  """Update a dataPointLevel"""
  updateDataPointLevel(input: UpdateDataPointLevelInput!): UpdateDataPointLevelPayload!

  """Bulk update properties associated with multiple data reports"""
  updateDataReports(input: UpdateDataReportsInput!): UpdateDataReportsPayload!

  """Update an organizations data retention policy"""
  updateDataRetentionSchedulePolicy(input: UpdateRetentionScheduleInput!): UpdateDataRetentionSchedulePolicyPayload!

  """Toggle a data silo plugin"""
  updateDataSiloPlugin(input: UpdatePluginInput!): UpdateDataSiloPluginPayload!

  """Update the rate limit values for a data silo"""
  updateDataSiloRateLimits(input: UpdateDataSiloRateLimitsInput!): UpdateDataSiloRateLimitsPayload!

  """Bulk update the settings for one or more existing data silos"""
  updateDataSilos(input: UpdateDataSilosInput!): UpdateDataSilosPayload!

  """Bulk update properties associated with multiple data subcategories"""
  updateDataSubCategories(input: UpdateDataSubCategoriesInput!): UpdateDataSubCategoriesPayload!

  """Update the latest scan associated with a classification data silo"""
  updateDiscoClassScan(input: UpdateDiscoClassScanInput!): UpdateDiscoClassScanPayload!

  """
  Update the scan configuration associated with a classification data silo
  """
  updateDiscoClassScanConfig(input: UpdateDiscoClassScanConfigInput!): UpdateDiscoClassScanConfigPayload!

  """Update the email sender address"""
  updateEmailSenderAddress(input: UpdateEmailSenderAddressInput!): UpdateEmailSenderAddressPayload!

  """Update the configuration of an enricher"""
  updateEnricher(input: UpdateEnricherInput!, dhEncrypted: String): UpdateEnricherPayload!

  """Update a list of enrichers in a given workflow"""
  updateEnrichersInWorkflowConfig(input: UpdateEnrichersInWorkflowConfigInput!): UpdateEnrichersInWorkflowConfigPayload!

  """Update an existing experience for an organization"""
  updateExperience(input: UpdateExperienceInput!): UpdateExperiencePayload!

  """
  Bulk update features. It is only used for enabling/disabling beta features. Other configurations are managed by CX.
  """
  updateFeatures(input: UpdateFeaturesInput!): UpdateFeaturesPayload!

  """Update an existing identifier"""
  updateIdentifier(input: UpdateIdentifierInput!): UpdateIdentifierPayload!

  """Update the internationalized messages displayed on the privacy center."""
  updateIntlMessages(input: UpdateMessagesInput!): UpdateIntlMessagesPayload!

  """Update the configuration of a legal matter"""
  updateLegalMatter(input: UpdateLegalMatterInput!): UpdateLegalMatterPayload!

  """Update an airgap bundle loadOptions."""
  updateLoadOptions(input: UpdateLoadOptionsInput!): UpdateLoadOptionsPayload!

  """Update a Lookup process"""
  updateLookupProcess(input: UpdateLookupProcessInput!): UpdateLookupProcessPayload!

  """Updates or create a set of application users"""
  updateOrCreateApplicationUsers(input: UpdateOrCreateApplicationUsersInput!): UpdateOrCreateApplicationUsersPayload!

  """Update or create airgap cookies"""
  updateOrCreateCookies(input: UpdateOrCreateCookiesInput!): UpdateOrCreateCookiesPayload!

  """Update a datapoint"""
  updateOrCreateDataPoint(input: UpdateOrCreateDataPointInput!, dhEncrypted: String): UpdateOrCreateDataPointPayload!

  """Update or create a workflow data point"""
  updateOrCreateWorkflowDataPoint(input: UpdateOrCreateWorkflowDataPointInput!): UpdateOrCreateWorkflowDataPointPayload!

  """Update the global organization information"""
  updateOrganizationInfo(input: UpdateOrganizationInput!): UpdateOrganizationInfoPayload!

  """Update the mapping from TCF Purposes to Airgap tracking purposes"""
  updateOrgTCFPurposes(input: UpdateOrgTCFPurposesInput!): UpdateOrgTcfPurposesPayload!

  """
  Update the mapping from TCF Special Features to Airgap tracking purposes
  """
  updateOrgTcfSpecialFeature(input: UpdateTCFSpecialFeatureTrackingPurposesInput!): UpdateOrgTcfSpecialFeaturePayload!

  """Updates a user's password when they are logged in"""
  updatePassword(input: UpdatePasswordInput!): UpdatePasswordPayload!

  """Updates a set of pathfinder policies"""
  updatePathfinderPolicies(input: UpdatePathfinderPoliciesInput!): UpdatePathfinderPoliciesPayload!

  """Updates a set of pathfinders"""
  updatePathfinders(input: UpdatePathfindersInput!): UpdatePathfindersPayload!

  """Update the organization's privacy center policies"""
  updatePolicies(input: UpdatePoliciesInput!): UpdatePoliciesPayload!

  """Update the organization's privacy center"""
  updatePrivacyCenter(input: UpdatePrivacyCenterInput!): UpdatePrivacyCenterPayload!

  """Bulk update the configuration of one or many processing activities"""
  updateProcessingActivities(input: UpdateProcessingActivitiesInput!): UpdateProcessingActivitiesPayload!

  """
  Bulk update properties associated with multiple purpose of processing subcategories
  """
  updateProcessingPurposeSubCategories(input: UpdateProcessingPurposeSubCategoriesInput!): UpdateProcessingPurposeSubCategoriesPayload!

  """Updates a Prompt Group"""
  updatePromptGroups(input: UpdatePromptGroupsInput!): UpdatePromptGroupsPayload!

  """Updates a set of partial prompts"""
  updatePromptPartials(input: UpdatePromptPartialsInput!): UpdatePromptPartialsPayload!

  """Updates a set of prompts"""
  updatePrompts(input: UpdatePromptsInput!): UpdatePromptsPayload!

  """Updates a set of prompt threads"""
  updatePromptThreads(input: UpdatePromptThreadsInput!): UpdatePromptThreadsPayload!

  """Updates a set of pull requests"""
  updatePullRequests(input: UpdatePullRequestsInput!): UpdatePullRequestsPayload!

  """Update an existing consent tracking purpose for an organization"""
  updatePurpose(input: UpdatePurposeInput!): UpdatePurposePayload!

  """Updates a set of repository"""
  updateRepositories(input: UpdateRepositoriesInput!): UpdateRepositoriesPayload!

  """Update the details of a request or mark it as a test/silent request"""
  updateRequest(input: UpdateRequestInput!): UpdateRequestPayload!

  """
  Update the details for a specified bulk response request (aka RequestDataSilo)
  """
  updateRequestDataSiloDetails(input: UpdateRequestDataSiloDetailsInput!): UpdateRequestDataSiloDetailsPayload!

  """
  Manually update the state of a request file. Used only in the case a remote request file that is on our systems, and the client needs to manually confirm they've actioned upon it.
  """
  updateRequestFileStatus(input: UpdateRequestFileStatusInput!): UpdateRequestFileStatusPayload!

  """Update the risk categories"""
  updateRiskCategories(input: UpdateRiskCategoriesInput!): UpdateRiskCategoriesPayload!

  """Update the risk frameworks"""
  updateRiskFrameworks(input: UpdateRiskFrameworksInput!): UpdateRiskFrameworksPayload!

  """Updates the savings configuration with the specified values"""
  updateSavingsConfiguration(input: UpdateSavingsConfigurationInput!): UpdateSavingsConfigurationPayload!

  """Update the associations of a scope"""
  updateScope(input: UpdateScopeInput!): UpdateScopePayload!

  """Bulk update the configuration of one or many sensitive categories"""
  updateSensitiveCategories(input: UpdateSensitiveCategoriesInput!): UpdateSensitiveCategoriesPayload!

  """Update sitescan status for an organization"""
  updateSitescan(input: UpdateSitescanInput!): UpdateSitescanPayload!

  """Updates a set of software development kits"""
  updateSoftwareDevelopmentKits(input: UpdateSoftwareDevelopmentKitsInput!): UpdateSoftwareDevelopmentKitsPayload!

  """Update a sombra gateway"""
  updateSombra(id: ID!, input: UpdateSombraInput!): UpdateSombraPayload!

  """Update the JWT configuration for data subject verification on Sombra"""
  updateSombraJWTConfig(input: UpdateSombraJWTConfigInput!, dhEncrypted: String!): UpdateSombraJwtConfigPayload!

  """Update the OAuth configuration for data subject verification on Sombra"""
  updateSombraOAuthConfig(input: UpdateSombraOAuthConfigInput!, dhEncrypted: String!): UpdateSombraOAuthConfigPayload!

  """Update the sombra tenant configuration"""
  updateSombraTenantConfig(dhEncrypted: String!): UpdateSombraTenantConfigPayload!

  """Update the SSO account for the organization"""
  updateSsoProvider(input: SsoProviderInput!, dhEncrypted: String!): UpdateSsoProviderPayload!

  """Bulk update data associated with multiple subdatapoints"""
  updateSubDataPoints(input: UpdateSubDataPointsInput!): UpdateSubDataPointsPayload!

  """Update the configuration of a data subject class"""
  updateSubject(input: UpdateSubjectInput!): UpdateSubjectPayload!

  """Update the airgap XDI consent sync endpoint URL."""
  updateSyncEndpoint(input: UpdateSyncEndpointInput!): UpdateSyncEndpointPayload!

  """Update sync groups."""
  updateSyncGroups(input: UpdateSyncGroupsInput!): UpdateSyncGroupsPayload!

  """Updates the attributes of a team"""
  updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

  """Update an existing communication template"""
  updateTemplate(input: UpdateTemplateInput!): UpdateTemplatePayload!

  """Update unstructured subdatapoints recommendations"""
  updateUnstructuredSubDataPointRecommendations(input: UpdateScannedObjectsInput!): UpdateUnstructuredSubDataPointRecommendationsPayload!

  """Update a user in the organization"""
  updateUser(input: UpdateUserInput!): UpdateUserPayload!

  """Update the profile of the currently logged in user"""
  updateUserProfile(input: UpdateCurrentUserInput!): UpdateUserProfilePayload!

  """Bulk update the configuration of one or many vendors"""
  updateVendors(input: UpdateVendorsInput!): UpdateVendorsPayload!

  """updates communication settings for a workflowConfig"""
  updateWorkflowCommunicationSettings(input: UpdateWorkflowCommunicationSettingsInput!): UpdateWorkflowCommunicationSettingsPayload!

  """updates basic details for a workflowConfig"""
  updateWorkflowConfig(input: UpdateWorkflowConfigInput!): UpdateWorkflowConfigPayload!

  """Login to the privacy center by providing a valid email token"""
  verifyPrivacyCenterLoginEmail(lookup: PrivacyCenterLookupInput, input: TokenInput!): VerifyPrivacyCenterLoginEmailPayload!

  """Verify the ownership of a request identifier JWT token"""
  verifyRequestToken(lookup: PrivacyCenterLookupInput, input: TokenInput!): VerifyRequestTokenPayload!

  """
  Invalidate an email, indicating the email address did not initiate login
  """
  wrongLoginEmail(lookup: PrivacyCenterLookupInput, input: TokenInput!): WrongLoginEmailPayload!

  """
  Invalidate a request identifier, indicating the identifier was not expected to be processed
  """
  wrongRequestToken(lookup: PrivacyCenterLookupInput, input: TokenInput!): WrongRequestTokenPayload!
}

"""An action that the data subject can make on the privacy center"""
type Action implements ActionInterface {
  """The unique id of the action"""
  id: ID!

  """The type of action"""
  type: RequestAction!

  """The display title of the request action"""
  title: DefinedMessage!

  """The display description of the request action"""
  description: DefinedMessage!

  """The display description of the request action on the confirmation page"""
  secondaryDescription: DefinedMessage!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus!

  """
  The different ways that regions can be detected at time of request submit
  """
  regionDetectionMethod: RegionDetectionMethod!

  """
  The list of regions that should appear in the form on the privacy center for the data subjects region
  """
  regionList: [String!]!

  """Allow for choice in postCompile option."""
  allowPostCompileChoice: Boolean

  """
  The form items that should be rendered when the data subject submits the request
  """
  formItems: [FormItem!]!

  """A custom icon for the action"""
  icon: String

  """The delay configuration"""
  delay: ActionDelay
}

"""Input for a checkbox confirmation form item"""
input ActionConfirmationInput {
  """The ID of an existing form item, if updating"""
  id: ID

  """The default message to display"""
  message: String!
}

"""Configuration for delaying a request action"""
type ActionDelay {
  """
  The default delay time added to the request to give the data subject a chance to cancel
  """
  time: Int!

  """The action to use to preview the request before true compilation"""
  previewAction: RequestAction!
}

"""The expiry times for an action"""
type ActionExpiryTime {
  """The region code (or 'default') for the expiry time for the action"""
  region: String!

  """The expiry time for the action"""
  value: Int!
}

"""The expiry times for an action"""
input ActionExpiryTimeInput {
  """The region code (or 'default') for the expiry time for the action"""
  region: String!

  """The expiry time for the action"""
  value: Int!
}

"""Input for filtering an action"""
input ActionFiltersInput {
  """Filter text on action title/description/secondary description"""
  text: String

  """Filter for required review"""
  requiresReview: Boolean

  """Filter by the action type"""
  type: [RequestAction!]

  """Filter by the data subject IDs that have this action enabled"""
  dataSubjectIds: [ID!]
}

"""A type of action that a data subject can make"""
interface ActionInterface {
  """The unique id of the action"""
  id: ID!

  """The type of action"""
  type: RequestAction!

  """The display title of the request action"""
  title: DefinedMessage!

  """The display description of the request action"""
  description: DefinedMessage!

  """The display description of the request action on the confirmation page"""
  secondaryDescription: DefinedMessage!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus!

  """
  The different ways that regions can be detected at time of request submit
  """
  regionDetectionMethod: RegionDetectionMethod!

  """
  The list of regions that should appear in the form on the privacy center for the data subjects region
  """
  regionList: [String!]!

  """Allow for choice in postCompile option."""
  allowPostCompileChoice: Boolean

  """
  The form items that should be rendered when the data subject submits the request
  """
  formItems: [FormItem!]!

  """A custom icon for the action"""
  icon: String

  """The delay configuration"""
  delay: ActionDelay
}

"""An action that the data subject can make on the privacy center"""
type ActionInternal implements ActionInterface {
  """The unique id of the action"""
  id: ID!

  """The type of action"""
  type: RequestAction!

  """The display title of the request action"""
  title: DefinedMessage!

  """The display description of the request action"""
  description: DefinedMessage!

  """The display description of the request action on the confirmation page"""
  secondaryDescription: DefinedMessage!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus!

  """
  The different ways that regions can be detected at time of request submit
  """
  regionDetectionMethod: RegionDetectionMethod!

  """
  The list of regions that should appear in the form on the privacy center for the data subjects region
  """
  regionList: [String!]!

  """Allow for choice in postCompile option."""
  allowPostCompileChoice: Boolean

  """
  The form items that should be rendered when the data subject submits the request
  """
  formItems: [FormItem!]!

  """A custom icon for the action"""
  icon: String

  """The delay configuration"""
  delay: ActionDelay

  """
  Configuration option to skip running erasures when no data is found in initial access request.
  """
  skipSecondaryIfNoFiles: Boolean!

  """The number of datapoints configured for this action"""
  dataPointCount: Int!

  """The number of integrations configured for this action"""
  integrationCount: Int!

  """Preview a set of up to 12 integrations configured to this workflow"""
  integrationPreviews: [Resource!]!

  """Transcend users involved in the process"""
  owners: [UserPreview!]!

  """
  Configuration option to skip the ability to download files in an ACCESS request.
  """
  skipDownloadableStep: Boolean!

  """Whether the action should undergo a review step"""
  requiresReview: Boolean!

  """Whether the action should undergo a review step post deletion"""
  requiresSecondaryReview: Boolean!

  """
  Indicates if the action is connected to any datapoints, and can thus be resolved if a request is made
  """
  canResolve: Boolean!

  """When a data subject submits a request, send them a receipt"""
  sendReceiptEmail: Boolean!

  """The display to display to an administrator"""
  adminTitle: String!

  """The display to display to an administrator"""
  dataSilos: [DataSiloPreview!]!

  """Total number of requests received"""
  requestCount: Int!

  """Total number of requests resolved successfully"""
  successfulRequestCount: Int!

  """Total number of open requests"""
  openRequestCount: Int!

  """The report to use for a successful resolve of the action"""
  successTemplate: Template

  """The report to use upon receipt of a new request"""
  receiptTemplate: Template!

  """The report to use when the data subject was not found in the systems"""
  notFoundTemplate: Template

  """The template used when secondary action is completed"""
  secondaryTemplate: Template

  """The default steps for the action"""
  steps: [Step!]!

  """The expiry times for the action"""
  expiryTimeRegions: [ActionExpiryTime!]!

  """The number of days the request files are downloadable"""
  downloadAvailabilityDuration: Int!

  """The number of days to wait before starting to compile requests"""
  waitingPeriod: Int!
}

"""Input for Action Items rescan mutation"""
input ActionItemRescanInput {
  """A list of action item types to queue for rescan"""
  types: [ActionItemCode!]!
}

type ActionItemRescansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""The subscription info for each type of action item"""
type ActionItemRunLock {
  """When the run lock was created"""
  createdAt: Date!

  """The run lock id"""
  id: ID!

  """When the run lock was updated"""
  updatedAt: Date!

  """When the run lock expires"""
  expiresAt: Date!

  """When the action item was last completed"""
  lastCompletedAt: Date

  """When the action item was last queued to be processed"""
  lastQueuedAt: Date

  """The type of action item"""
  type: ActionItemCode!
}

type ActionItemRunLocksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ActionItemRunLock"""
  nodes: [ActionItemRunLock!]!

  """string"""
  now: String!
}

"""Input action items run locks query"""
input ActionItemRunLocksInput {
  """A list of action item types to check"""
  types: [ActionItemCode!]!
}

"""subscription to action item notifications"""
type ActionItemSubscription {
  """row id for this subscription"""
  id: ID!

  """method of notification for this subscription"""
  notificationMethod: ActionItemSubscriptionNotificationMethod!

  """The type of action item"""
  actionItemCode: ActionItemCode!

  """
  Unique identifier of subscription destination, i.e. custom email or slack channel id
  """
  destinationIdentifier: String

  """Additional context for the action item subscription"""
  additionalContext: ActionItemSubscriptionContext
}

"""additional context for an action item subscription"""
type ActionItemSubscriptionContext {
  """name of the slack channel this subscription gets sent to"""
  slackChannelName: String
}

"""additional context for an action item subscription"""
input ActionItemSubscriptionContextInput {
  """name of the slack channel this subscription gets sent to"""
  slackChannelName: String
}

"""Input for creating actionItemSubscriptions"""
input ActionItemSubscriptionInput {
  """The type of action items to subscribe to"""
  actionItemCode: ActionItemCode!

  """The method by which the user will be notified of this action item"""
  notificationMethod: ActionItemSubscriptionNotificationMethod!

  """
  Unique identifier of subscription destination, i.e. custom email or slack channel id
  """
  destinationIdentifier: String

  """Additional context for the action item subscription"""
  additionalContext: ActionItemSubscriptionContextInput
}

"""The order for a Action query"""
input ActionOrder {
  """The field that the Action nodes should be ordered by"""
  field: ActionOrderField!

  """
  The direction in which to order the Action nodes by the specified field
  """
  direction: OrderDirection!
}

"""Preview an action"""
type ActionPreview {
  """The unique id of the action"""
  id: ID!

  """The display title of the request action with associated translations"""
  title: Message!

  """The type of action"""
  type: RequestAction!
}

type ActionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ActionInternal"""
  nodes: [ActionInternal!]!

  """int"""
  totalCount: Int!
}

type ActivitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Activity"""
  nodes: [Activity!]!

  """int"""
  totalCount: Int!
}

"""
An activity related to a request. This is the audit trail of everything that occurs during the request lifecycle.
"""
type Activity {
  """The id of the activity"""
  id: ID!

  """The code of the activity"""
  code: ActivityCode!

  """The time the activity occurred"""
  createdAt: Date!

  """The request that the activity was created for"""
  request: RequestDetails!

  """The user that performed the activity"""
  user: UserPreview

  """The requestFile that the activity is about"""
  requestFile: RequestFile

  """The profile that the request file belongs to"""
  profile: ProfilePreview

  """The data silo that the profile belongs to"""
  dataSilo: DataSiloPreview

  """The datapoint that is being resolved"""
  dataPoint: DataPointPreview

  """The request enricher that the activity is about"""
  requestEnricher: RequestEnricher

  """The request enricher that the activity is about"""
  requestIdentifier: RequestIdentifier

  """The edge between the request enricher and request identifier"""
  requestEnricherRequestIdentifier: RequestEnricherRequestIdentifier

  """The communication message that was sent"""
  communication: Communication

  """The error message if on occurred"""
  error: String
}

"""Input for filtering activities"""
input ActivityFiltersInput {
  """Request to filter by"""
  requestId: ID

  """Data silo to filter by"""
  dataSiloId: ID

  """The code of the activity"""
  code: [ActivityCode!]
}

"""The order for a Activity query"""
input ActivityOrder {
  """The field that the Activity nodes should be ordered by"""
  field: ActivityOrderField!

  """
  The direction in which to order the Activity nodes by the specified field
  """
  direction: OrderDirection!
}

type AddDataSiloToOpenRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  updatedRequestCount: Int!
}

"""Add this data silo to a set of open requests"""
input AddDataSiloToOpenRequestsInput {
  """The id of the data silo to add to requests"""
  dataSiloId: ID!

  """
  The list of request IDs to attach to (if none, will attach all possible requests)
  """
  requestIds: [ID!]
}

type AddDataSiloToWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type AddEmailDomainPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Domains from which Transcend can send emails"""
  domain: EmailDomain!
}

type AddEnrichersToWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to associate list of enrichers with a given workflow"""
input AddEnrichersToWorkflowConfigInput {
  """The workflow config ID"""
  workflowConfigId: ID!

  """list of enrichers to add"""
  enrichers: [AddEnricherToWorkflowConfigInput!]!
}

"""Input used to associate an enricher with a given workflow"""
input AddEnricherToWorkflowConfigInput {
  """Enricher id"""
  id: ID!

  """
  Whether the associated enricher is being used to produce additional identifiers
  """
  isIdentifierSource: Boolean!

  """Whether the enricher is disabled"""
  isDisabled: Boolean
}

"""Input for requesting additional time"""
input AdditionalTimeInput {
  """The id of the request to send to"""
  requestId: ID!

  """The HTML email template to send"""
  template: String

  """The subject of the email"""
  subject: String

  """The amount of time (in days) to extend by"""
  additionalTime: Int!
}

type AddMessagesToPromptRunPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An instance of running a prompt"""
  promptRun: PromptRun!
}

"""Input for adding messages to an existing prompt run"""
input AddMessagesToPromptRunInput {
  """
  The ID of the prompt run being reported on. Either this or "name" must be provided, but not both.
  """
  id: ID

  """
  The name of the prompt run (specified in API or derived from the file input). Either this or "id" must be provided, but not both.
  """
  name: String

  """Error message to report when an error occurs"""
  error: String

  """The status of the prompt run"""
  status: QueueStatus

  """The number of milliseconds it took to run the message"""
  duration: Int

  """The messages in the prompt run"""
  promptRunMessages: [PromptRunMessageInput!]
}

type AddSignedIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for bulk create-or-update silo discovery results"""
input AddSiloDiscoveryResultInput {
  """The plugin to associate with these results"""
  pluginId: ID!

  """The resources that can be classified as data silos"""
  rawResults: [SiloDiscoveryRawResultInput!]!
}

type AddSiloDiscoveryResultsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type AddTcfStacksToBundlePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFStack"""
  tcfStacks: [TCFStack!]!
}

type AddUserPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Another user in the organization."""
  user: User!
}

"""Input for adding a user to the organization"""
input AddUserInput {
  """The name of the new user"""
  name: String!

  """The email of the new user"""
  email: String!

  """Whether the user should be an administrator"""
  isAdmin: Boolean

  """The teams in the organization the user should have"""
  teams: [ID!]

  """The dataSilos in the organization the user should have"""
  dataSilos: [ID!]

  """The scopes the user should have"""
  scopes: [ScopeName!]

  """Send invitation email now?"""
  sendInviteEmail: Boolean
}

"""Request for upserting consent records from the Admin Dashboard and API"""
input AdminPurposeInput {
  """Tracking purpose"""
  purpose: String!

  """Whether the user has given consent for this purpose"""
  consent: Boolean!

  """User preferences for this purpose"""
  preferences: [PreferenceInput!]

  """Settings for triggering a consent workflow"""
  workflowSettings: ConsentWorkflowSettingsInput
}

"""Request for upserting a single preference record"""
input AdminUpsertPreferenceRecordInput {
  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """Most recent consent event timestamp (ISO 8601)"""
  timestamp: String!

  """US IAB Privacy String"""
  usp: String

  """IAB GPP String, encoding both USP and USNAT"""
  gpp: String

  """IAB GPP String, encoding both USP and USNAT"""
  tcf: String

  """Airgap Version"""
  airgapVersion: String

  """Metadata"""
  metadata: String

  """Last-modified for metadata timestamp (ISO 8601)"""
  metadataTimestamp: String

  """Last record modification timestamp (ISO 8601)"""
  updatedAt: String

  """
  When triggering a consent workflow, the locale to use for translation of email template and privacy center content.
  """
  locale: String

  """associated consent purposes"""
  purposes: [AdminPurposeInput!]!

  """Whether the user has confirmed their consent choices"""
  confirmed: Boolean

  """The identifiers for the user"""
  identifiers: [PreferenceStoreIdentifierInput!]!
}

"""Request for upserting preference records by admin"""
input AdminUpsertPreferenceRecordsInput {
  """List of preference store records to upsert"""
  records: [AdminUpsertPreferenceRecordInput!]!

  """Whether to skip workflow triggers for the updated preference records"""
  skipWorkflowTriggers: Boolean

  """
  Whether to force trigger workflows regardless of the difference in the consent status
  """
  forceTriggerWorkflows: Boolean
}

type AdminUpsertPreferencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!

  """A list of ConsentRecord"""
  nodes: [ConsentRecord!]!
}

"""An LLM-based agent, capable of performing tasks autonomously"""
type Agent {
  """The id of the agent"""
  id: ID!

  """The name of the agent"""
  name: String!

  """The ID of the agent in the remote system"""
  agentId: String!

  """The description of the agent"""
  description: String!

  """The instructions of the agent"""
  instructions: String!

  """The date the prompt was last updated"""
  updatedAt: Date!

  """Whether agent has code interpreter enabled"""
  codeInterpreterEnabled: Boolean!

  """Whether agent has code retrieval enabled"""
  retrievalEnabled: Boolean!

  """The number of prompt runs by this agent"""
  promptRunCount: Int!

  """The prompt that the agent uses for instructions"""
  prompt: PromptPreview

  """The code package that created the agent"""
  codePackage: CodePackagePreview

  """The repository that created the agent"""
  repository: RepositoryPreview

  """The user that created the agent"""
  creator: UserPreview

  """The LLM that the agent is based on"""
  largeLanguageModel: LargeLanguageModelPreview

  """The team/s that the prompt is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the prompt is assigned to"""
  owners: [UserPreview!]!

  """The applications that have interacted with the agent"""
  applications: [ApplicationPreview!]!

  """The pathfinders that have interacted with the agent"""
  pathfinders: [PathfinderPreview!]!

  """The application users that have interacted with the agent"""
  applicationUsers: [ApplicationUserPreview!]!

  """The functions assigned to the agent"""
  agentFunctions: [AgentFunctionPreview!]!

  """The files assigned to the agent"""
  agentFiles: [AgentFilePreview!]!
}

"""A legal agentFile"""
type AgentFile {
  """The id of the agent file"""
  id: ID!

  """The name of the agent file"""
  name: String!

  """ID of the file in remote system"""
  fileId: String!

  """
  The name of the initial file, when this file is a chunk of another file
  """
  initialFileName: String

  """The date the agent file was created"""
  createdAt: Date!

  """The date the agent file was last updated"""
  updatedAt: Date!

  """The description of the agent file"""
  description: String!

  """Date that the file was uploaded to the remote system"""
  fileUploadedAt: Date!

  """Size of the file in bytes"""
  size: Int!

  """Purpose of the file"""
  purpose: PromptFilePurpose!

  """The list of agents that have access to this file"""
  agents: [AgentPreview!]!

  """The user that created the file"""
  creator: UserPreview
}

"""Inputs for filtering a list of agent files"""
input AgentFileFiltersInput {
  """The ids of the agent files"""
  ids: [ID!]

  """The ids of the agents that have access to the file"""
  agentIds: [ID!]

  """The file purposes to filter on"""
  purposes: [PromptFilePurpose!]

  """Filter by text (name, description of the agent file)"""
  text: String

  """Filter by file IDs"""
  fileIds: [String!]

  """Filter by name"""
  names: [String!]

  """Filter by initial file name"""
  initialFileNames: [String!]
}

"""The order for a AgentFile query"""
input AgentFileOrder {
  """The field that the AgentFile nodes should be ordered by"""
  field: AgentFileOrderField!

  """
  The direction in which to order the AgentFile nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an agent file instance"""
type AgentFilePreview {
  """The id of the agent file"""
  id: ID!

  """The name of the agent file"""
  name: String!

  """ID of the file in remote system"""
  fileId: String!

  """
  The name of the initial file, when this file is a chunk of another file
  """
  initialFileName: String

  """The date the agent file was created"""
  createdAt: Date!

  """The date the agent file was last updated"""
  updatedAt: Date!
}

type AgentFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AgentFile"""
  nodes: [AgentFile!]!

  """int"""
  totalCount: Int!
}

"""Inputs for filtering a list of agents"""
input AgentFiltersInput {
  """The ids of the agents"""
  ids: [ID!]

  """The ids of the prompts"""
  promptIds: [ID!]

  """Filter by text (name of the agent)"""
  text: String

  """Filter by the names of the agents"""
  names: [String!]

  """Filter by the agent ids"""
  agentIds: [String!]

  """The ids of the large language models"""
  largeLanguageModelIds: [ID!]

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """Filter by agent file IDs"""
  agentFileIds: [ID!]

  """Filter by agent function IDs"""
  agentFunctionIds: [ID!]
}

"""A legal agentFunction"""
type AgentFunction {
  """The id of the agent function"""
  id: ID!

  """The name of the agent function"""
  name: String!

  """The date the agent function was created"""
  createdAt: Date!

  """The date the agent function was last updated"""
  updatedAt: Date!

  """The description of the agent function"""
  description: String!

  """The JSON scheme definition for the function parameters"""
  parameters: String!

  """The list of agents that have access to this function"""
  agents: [AgentPreview!]!
}

"""Inputs for filtering a list of agent functions"""
input AgentFunctionFiltersInput {
  """The ids of the agent functions"""
  ids: [ID!]

  """The ids of the agents that have access to the function"""
  agentIds: [ID!]

  """Filter by text (name, description of the agent function)"""
  text: String

  """Filter by name"""
  name: String
}

"""Input for creating an agent function"""
input AgentFunctionInput {
  """The name of the agent function"""
  name: String!

  """The description of the agent function"""
  description: String

  """The JSON schema definition of the function parameters"""
  parameters: String!
}

"""The order for a AgentFunction query"""
input AgentFunctionOrder {
  """The field that the AgentFunction nodes should be ordered by"""
  field: AgentFunctionOrderField!

  """
  The direction in which to order the AgentFunction nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an agent function instance"""
type AgentFunctionPreview {
  """The id of the agent function"""
  id: ID!

  """The name of the agent function"""
  name: String!

  """The date the agent function was created"""
  createdAt: Date!

  """The date the agent function was last updated"""
  updatedAt: Date!
}

type AgentFunctionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AgentFunction"""
  nodes: [AgentFunction!]!

  """int"""
  totalCount: Int!
}

"""The order for a Agent query"""
input AgentOrder {
  """The field that the Agent nodes should be ordered by"""
  field: AgentOrderField!

  """The direction in which to order the Agent nodes by the specified field"""
  direction: OrderDirection!
}

"""A preview of an agent"""
type AgentPreview {
  """The id of the agent"""
  id: ID!

  """The name of the agent"""
  name: String!

  """The ID of the agent in the remote system"""
  agentId: String!
}

type AgentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Agent"""
  nodes: [Agent!]!

  """int"""
  totalCount: Int!
}

"""Input for querying aggregate analytics data for an airgap bundle"""
input AirgapBundleAggregateAnalyticsInput {
  """The metric to query for"""
  metric: AnalyticsEvent!

  """The start time of the window to analyze"""
  start: Int!

  """The end time of the window to analyze"""
  end: Int!

  """Dimensions to include in the response"""
  includeDimensions: [AnalyticsDimension!]

  """Whether the cache should ignore the ttl and manually refetch"""
  forceRefetch: Boolean
}

"""A single item containing aggregate analytics data"""
type AirgapBundleAggregateAnalyticsItem {
  """The name of the metric this item measures"""
  metric: AnalyticsEvent!

  """The value of the item"""
  measure: String!

  """Additional dimension fields for the item"""
  dimensions: AnalyticsDimensions
}

"""Airgap aggregate analytics data result"""
type AirgapBundleAggregateAnalyticsResult {
  """The list of results"""
  items: [AirgapBundleAggregateAnalyticsItem!]!

  """The last time the data was fetched"""
  cachedAt: Date
}

"""Airgap Bundle ID"""
input AirgapBundleInput {
  """The id of the airgap bundle"""
  airgapBundleId: ID!
}

"""Input for querying timeseries analytics data for an airgap bundle"""
input AirgapBundleTimeseriesAnalyticsInput {
  """The metric to query for"""
  metric: AnalyticsEvent!

  """The start time of the window to analyze"""
  start: Int!

  """The end time of the window to analyze"""
  end: Int!

  """The time interval to bin datapoints by"""
  binInterval: String!

  """Whether the cache should ignore the ttl and manually refetch"""
  forceRefetch: Boolean
}

"""A single item containing timeseries analytics data"""
type AirgapBundleTimeseriesAnalyticsItem {
  """The name of the metric this item measures"""
  metric: AnalyticsEvent!

  """The value of the item"""
  measure: String!

  """The time this item represents"""
  time: Int!
}

"""Airgap timeseries analytics data"""
type AirgapBundleTimeseriesAnalyticsResult {
  """The name of the metric this item measures"""
  items: [AirgapBundleTimeseriesAnalyticsItem!]!

  """The last time the data was fetched"""
  cachedAt: Date
}

"""A version of an airgap bundle"""
type AirgapBundleVersion {
  """Rollback modules hosted on this specific CDN"""
  cdn: AirgapCdn!

  """The version ID for the airgap core module"""
  core: String!

  """The version ID for the airgap xdi module"""
  xdi: String

  """The version ID for the airgap userscript module"""
  userscript: String

  """The version ID for the airgap explorer module"""
  explorer: String

  """The version ID for the airgap metadata module"""
  metadata: String

  """The version ID for the airgap ui module"""
  ui: String

  """The version ID for the airgap stylesheet module"""
  stylesheet: String

  """The version ID for the airgap En module"""
  En: String

  """The version ID for the airgap FrFr module"""
  FrFr: String

  """The version ID for the airgap DeDe module"""
  DeDe: String

  """The version ID for the airgap ItIt module"""
  ItIt: String

  """The version ID for the airgap PtBr module"""
  PtBr: String

  """The version ID for the airgap Es419 module"""
  Es419: String

  """The version ID for the airgap EsEs module"""
  EsEs: String

  """The version ID for the airgap CsCz module"""
  CsCz: String

  """The version ID for the airgap DaDk module"""
  DaDk: String

  """The version ID for the airgap FiFi module"""
  FiFi: String

  """The version ID for the airgap ElGr module"""
  ElGr: String

  """The version ID for the airgap LtLt module"""
  LtLt: String

  """The version ID for the airgap NbNi module"""
  NbNi: String

  """The version ID for the airgap PlPl module"""
  PlPl: String

  """The version ID for the airgap RoRo module"""
  RoRo: String

  """The version ID for the airgap RuRu module"""
  RuRu: String

  """The version ID for the airgap SrLatnRs module"""
  SrLatnRs: String

  """The version ID for the airgap SvSe module"""
  SvSe: String

  """The version ID for the airgap ArAe module"""
  ArAe: String

  """The version ID for the airgap JaJp module"""
  JaJp: String

  """The version ID for the airgap KoKr module"""
  KoKr: String

  """The version ID for the airgap ZhCn module"""
  ZhCn: String

  """The version ID for the airgap ZhHk module"""
  ZhHk: String

  """The version ID for the airgap AfZz module"""
  AfZz: String

  """The version ID for the airgap BgBg module"""
  BgBg: String

  """The version ID for the airgap HrHr module"""
  HrHr: String

  """The version ID for the airgap HuHu module"""
  HuHu: String

  """The version ID for the airgap IdId module"""
  IdId: String

  """The version ID for the airgap MsMy module"""
  MsMy: String

  """The version ID for the airgap HiIn module"""
  HiIn: String

  """The version ID for the airgap MrIn module"""
  MrIn: String

  """The version ID for the airgap TaIn module"""
  TaIn: String

  """The version ID for the airgap ThTh module"""
  ThTh: String

  """The version ID for the airgap TrTr module"""
  TrTr: String

  """The version ID for the airgap UkUa module"""
  UkUa: String

  """The version ID for the airgap ViVn module"""
  ViVn: String

  """The version ID for the airgap NlNl module"""
  NlNl: String

  """The version ID for the airgap HeIl module"""
  HeIl: String

  """The version ID for the airgap tcfUi module"""
  tcfUi: String

  """The version ID for the airgap gpp module"""
  gpp: String

  """The version ID for the airgap tcfStylesheet module"""
  tcfStylesheet: String

  """The version ID for the airgap tcfVendorsList module"""
  tcfVendorsList: String

  """The version ID for the airgap tcfEn module"""
  tcfEn: String

  """The version ID for the airgap tcfFrFr module"""
  tcfFrFr: String

  """The version ID for the airgap tcfDeDe module"""
  tcfDeDe: String

  """The version ID for the airgap tcfItIt module"""
  tcfItIt: String

  """The version ID for the airgap tcfPtBr module"""
  tcfPtBr: String

  """The version ID for the airgap tcfEs419 module"""
  tcfEs419: String

  """The version ID for the airgap tcfEsEs module"""
  tcfEsEs: String

  """The version ID for the airgap tcfCsCz module"""
  tcfCsCz: String

  """The version ID for the airgap tcfDaDk module"""
  tcfDaDk: String

  """The version ID for the airgap tcfFiFi module"""
  tcfFiFi: String

  """The version ID for the airgap tcfElGr module"""
  tcfElGr: String

  """The version ID for the airgap tcfLtLt module"""
  tcfLtLt: String

  """The version ID for the airgap tcfNbNi module"""
  tcfNbNi: String

  """The version ID for the airgap tcfPlPl module"""
  tcfPlPl: String

  """The version ID for the airgap tcfRoRo module"""
  tcfRoRo: String

  """The version ID for the airgap tcfRuRu module"""
  tcfRuRu: String

  """The version ID for the airgap tcfSrLatnRs module"""
  tcfSrLatnRs: String

  """The version ID for the airgap tcfSvSe module"""
  tcfSvSe: String

  """The version ID for the airgap tcfArAe module"""
  tcfArAe: String

  """The version ID for the airgap tcfJaJp module"""
  tcfJaJp: String

  """The version ID for the airgap tcfKoKr module"""
  tcfKoKr: String

  """The version ID for the airgap tcfZhCn module"""
  tcfZhCn: String

  """The version ID for the airgap tcfZhHk module"""
  tcfZhHk: String

  """The version ID for the airgap tcfAfZz module"""
  tcfAfZz: String

  """The version ID for the airgap tcfBgBg module"""
  tcfBgBg: String

  """The version ID for the airgap tcfHrHr module"""
  tcfHrHr: String

  """The version ID for the airgap tcfHuHu module"""
  tcfHuHu: String

  """The version ID for the airgap tcfIdId module"""
  tcfIdId: String

  """The version ID for the airgap tcfMsMy module"""
  tcfMsMy: String

  """The version ID for the airgap tcfHiIn module"""
  tcfHiIn: String

  """The version ID for the airgap tcfMrIn module"""
  tcfMrIn: String

  """The version ID for the airgap tcfTaIn module"""
  tcfTaIn: String

  """The version ID for the airgap tcfThTh module"""
  tcfThTh: String

  """The version ID for the airgap tcfTrTr module"""
  tcfTrTr: String

  """The version ID for the airgap tcfUkUa module"""
  tcfUkUa: String

  """The version ID for the airgap tcfViVn module"""
  tcfViVn: String

  """The version ID for the airgap tcfNlNl module"""
  tcfNlNl: String

  """The version ID for the airgap tcfHeIl module"""
  tcfHeIl: String

  """The version ID for the airgap nativeAppConfig module"""
  nativeAppConfig: String

  """The version ID for the airgap bridgeJs module"""
  bridgeJs: String

  """The version ID for the airgap bridgeHtml module"""
  bridgeHtml: String

  """The version ID for the sync endpoint script"""
  sync: String

  """
  Whether to rollback the "TEST" or "PRODUCTION" bundle, defaults to "PRODUCTION"
  """
  isTest: Boolean!

  """The core module configuration used in this deployed version"""
  coreConfig: String

  """The time at which the version was created"""
  createdAt: Date!

  """The version of the airgap bundle that was deployed"""
  version: String

  """The user who deployed this version"""
  user: UserPreview

  """The API key who deployed this version"""
  apiKey: ApiKeyPreview
}

type AirgapBundleVersionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AirgapBundleVersion"""
  nodes: [AirgapBundleVersion!]!

  """int"""
  totalCount: Int!
}

"""Input for querying airgapBundleVersions"""
input AirgapBundleVersionsInput {
  """Whether to return versions for the "TEST" or "PRODUCTION" bundle"""
  isTest: Boolean!

  """
  The CDN to return versions for (defaults to "preferredCdn" of airgapBundle)
  """
  cdn: AirgapCdn
}

"""A preview of an airgap cookie or data flow"""
type AirgapCookieOrDataFlowPreview {
  """The ID of this cookie or data flow"""
  id: String!

  """The description for the cookie or data flow"""
  description: String

  """Name or regex of cookie or data flow"""
  name: String!
}

"""The airgap version and associated metadata"""
type AirgapVersion {
  """The version of airgap.js"""
  version: String!

  """Changes introduced in this version"""
  description: String

  """Changes introduced in this version, as a list"""
  descriptions: [String!]!

  """Changes introduced in this version, as a list"""
  issues: [AirgapVersionIssue!]!

  """When this version was released"""
  releasedOn: String!
}

"""A known issue associated with a given airgap version"""
type AirgapVersionIssue {
  """Description of the known issue"""
  description: String!

  """Severity of the known issue"""
  severity: AirgapIssueSeverityGQL!

  """Version the issue was fixed in"""
  fixedIn: String!
}

type AirgapVersionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AirgapVersion"""
  versions: [AirgapVersion!]!
}

"""Input for fetching airgap versions"""
input AirgapVersionsInput {
  """How many versions to fetch (defaults to 50)"""
  limit: Int

  """Whether to clear the cache & force a refetch"""
  forceRefetch: Boolean
}

"""Input for allowing a sombra key to be used in multiple tenants"""
input AllowMultiTenantSombraKeyInput {
  """The ID of the Organization to allow multi tenant access to"""
  organizationId: ID!

  """The IDs of the users that should be able to download the key"""
  allowUserIds: [ID!]

  """The IDs of the users that should not be able to download the key"""
  revokeUserIds: [ID!]
}

"""A single data point"""
type AnalyticsDataPoint {
  """The key of the data point (usually x axis)"""
  key: String

  """The value of the data point (usually y axis)"""
  value: Float!
}

"""A series of datapoints"""
type AnalyticsDataSeries {
  """The name of the data series"""
  name: String!

  """The list of datapoints for the series"""
  points: [AnalyticsDataPoint!]!
}

"""Dimensions from a query of telemetry analytics"""
type AnalyticsDimensions {
  """The dimension value for REGIME"""
  REGIME: String

  """The dimension value for SIGNAL"""
  SIGNAL: String

  """The dimension value for SIGNAL_GPC"""
  SIGNAL_GPC: String

  """The dimension value for SIGNAL_DNT"""
  SIGNAL_DNT: String

  """The dimension value for COOKIE"""
  COOKIE: String

  """The dimension value for HOST"""
  HOST: String

  """The dimension value for PATH"""
  PATH: String

  """The dimension value for PURPOSE"""
  PURPOSE: String

  """The dimension value for PURPOSE_DEFAULT_CONSENT_VALUE"""
  PURPOSE_DEFAULT_CONSENT_VALUE: String

  """The dimension value for PURPOSE_CURRENT_CONSENT_VALUE"""
  PURPOSE_CURRENT_CONSENT_VALUE: String

  """The dimension value for NEW_VALUE"""
  NEW_VALUE: String

  """The dimension value for WAS_ALLOWED"""
  WAS_ALLOWED: String

  """The dimension value for CONSENT_MANAGER_ID"""
  CONSENT_MANAGER_ID: String

  """The dimension value for ENCOUNTERED_AT"""
  ENCOUNTERED_AT: String

  """The dimension value for MOBILE_APP_ID"""
  MOBILE_APP_ID: String

  """The dimension value for REGEX"""
  REGEX: String

  """The dimension value for MAX_AGE"""
  MAX_AGE: String

  """The dimension value for SAMPLING_RATE"""
  SAMPLING_RATE: String

  """The dimension value for CLIENT_SAMPLING_RATE"""
  CLIENT_SAMPLING_RATE: String

  """The dimension value for BACKEND_SAMPLING_MULTIPLIER"""
  BACKEND_SAMPLING_MULTIPLIER: String
}

"""Input for analytics data endpoint"""
input AnalyticsInput {
  """The data source to use when fetching data"""
  dataSource: AnalyticsDataSource!

  """The start date of the analytics data"""
  startDate: Date

  """The end date of the analytics data"""
  endDate: Date

  """How to group the data"""
  groupBy: AnalyticsGroupBy

  """The key of the attribute to filter to"""
  attributeKey: String

  """The id of the airgap bundle"""
  airgapBundleId: ID

  """The id of the dataPoint to fetch data for"""
  dataPointId: ID

  """The id of the data silo to fetch data for"""
  dataSiloId: ID

  """Should ignore the cache and force a fetch?"""
  forceRefetch: Boolean

  """The potential bin intervals to use. Defaults to 1d (1 day)"""
  binInterval: String

  """
  The potential bin intervals to use as a number. Defaults to ONE_DAY/1000 
  """
  binIntervalNum: Float

  """Whether or not to smooth the timeseries data. Defaults to true."""
  smoothTimeseries: Boolean

  """Whether or not to show test requests. Defaults to false."""
  isTestRequest: Boolean

  """The unique id for the backend request"""
  uniqueId: String

  """The app id to filter to"""
  appId: String

  """The id of the auditor run to fetch data for"""
  runId: String
}

"""Metadata for a specific analytics source"""
type AnalyticsMetadata {
  """The percent change since the previous interval"""
  percentChange: Float

  """The value that summarizes the entire dataset"""
  summaryValue: Float

  """
  The date after which this data is valid. Is an ISO string when an effective date, is "true" when no data is valid (i.e. current configuration is invalid to collect data)
  """
  effectiveDate: String
}

"""Data and metadata for a specific analytics source"""
type AnalyticsResult {
  """The list of data series"""
  series: [AnalyticsDataSeries!]!

  """The global metadata for the analytics data"""
  metadata: AnalyticsMetadata!

  """The last time the data was fetched"""
  cachedAt: Date
}

"""
An API key that can be used to programmatically access a Transcend account
"""
type ApiKey implements ApiKeyInterface {
  """The unique id of the api key"""
  id: ID!

  """The title of the api key"""
  title: String!

  """The api key preview"""
  preview: String!

  """The time the api key was created"""
  createdAt: Date!

  """The time the api key was last used"""
  lastUsedAt: Date

  """The age of the api key in days"""
  age: Int!

  """The cycle status of the api key (for indicating need to refresh)"""
  status: ApiKeyStatus!

  """The user that created the API key"""
  user: UserPreview

  """The scopes associated with the api key"""
  scopes: [ScopePreview!]!

  """The data silos connected to the API Key"""
  dataSilos: [Resource!]!
}

"""The API key filters"""
input ApiKeyFiltersInput {
  """Filter by the title"""
  text: String

  """Filter by a list of API key ids"""
  ids: [ID!]

  """Fetch API keys by title"""
  titles: [String!]

  """Filter by the status of the API key (need for refresh)"""
  status: [ApiKeyStatus!]
}

"""Inputs for creating a new API key"""
input ApiKeyInput {
  """The title used to identify the API key"""
  title: String!

  """The names of the scopes to add"""
  scopes: [ScopeName!]

  """The ids of the data silos to assign to"""
  dataSilos: [ID!]
}

"""
An API key that can be used to programmatically access a Transcend account
"""
interface ApiKeyInterface {
  """The unique id of the api key"""
  id: ID!

  """The title of the api key"""
  title: String!

  """The api key preview"""
  preview: String!

  """The time the api key was created"""
  createdAt: Date!

  """The time the api key was last used"""
  lastUsedAt: Date

  """The age of the api key in days"""
  age: Int!

  """The cycle status of the api key (for indicating need to refresh)"""
  status: ApiKeyStatus!

  """The user that created the API key"""
  user: UserPreview

  """The scopes associated with the api key"""
  scopes: [ScopePreview!]!

  """The data silos connected to the API Key"""
  dataSilos: [Resource!]!
}

"""The order for a ApiKey query"""
input ApiKeyOrder {
  """The field that the ApiKey nodes should be ordered by"""
  field: ApiKeyOrderField!

  """
  The direction in which to order the ApiKey nodes by the specified field
  """
  direction: OrderDirection!
}

"""Preview of an api key"""
type ApiKeyPreview {
  """The unique id of the api key"""
  id: ID!

  """The title of the api key"""
  title: String!

  """The api key preview"""
  preview: String!
}

type ApiKeysPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ApiKey"""
  nodes: [ApiKey!]!

  """int"""
  totalCount: Int!
}

"""
A service or application that executes some code - typically tracked for the purposes of AI governance
"""
type Application {
  """The id of the application"""
  id: ID!

  """The name of the application"""
  name: String!

  """The description of the application"""
  description: String!

  """The date the application was created"""
  createdAt: Date!

  """The date the application was last updated"""
  updatedAt: Date!

  """The date the application was last seen reporting a prompt run"""
  lastSeenAt: Date

  """List of prompts that the application is calling"""
  prompts: [PromptPreview!]!

  """
  The list of individual users who are responsible for managing this application
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this application"""
  teams: [TeamPreview!]!

  """The list of pathfinder instances that the application has access to"""
  pathfinders: [PathfinderPreview!]!

  """The list of agents that this application has access to"""
  agents: [AgentPreview!]!

  """
  Data sub categories that were detected in the prompt runs for this application
  """
  promptRunDataSubCategories: [DataSubCategoryPreview!]!

  """The number of users detected in the application"""
  applicationUserCount: Int!

  """The number of prompt runs that this application has ran"""
  promptRunCount: Int!
}

"""Inputs for filtering a list of applications"""
input ApplicationFiltersInput {
  """The ids of the applications"""
  ids: [ID!]

  """The ids of the owners that are mapped to this application"""
  ownerIds: [ID!]

  """The ids of the teams that are mapped to this application"""
  teamIds: [ID!]

  """The ids of the prompts that this application has called"""
  promptIds: [ID!]

  """The ids of the pathfinders to filter down applications for"""
  pathfinderIds: [ID!]

  """The ids of the agents to filter down applications for"""
  agentIds: [ID!]

  """The ids of the data sub categories detected in prompt runs"""
  dataSubCategoryIds: [ID!]

  """The ids of the application users to filter applications for"""
  appUserIds: [ID!]

  """Filter by text (name, description of the application)"""
  text: String
}

"""The order for a Application query"""
input ApplicationOrder {
  """The field that the Application nodes should be ordered by"""
  field: ApplicationOrderField!

  """
  The direction in which to order the Application nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an application instance"""
type ApplicationPreview {
  """The id of the application"""
  id: ID!

  """The name of the application"""
  name: String!

  """The description of the application"""
  description: String!

  """The date the application was created"""
  createdAt: Date!

  """The date the application was last updated"""
  updatedAt: Date!

  """The date the application was last seen reporting a prompt run"""
  lastSeenAt: Date
}

type ApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Application"""
  nodes: [Application!]!

  """int"""
  totalCount: Int!
}

"""A user that was found to be interacting with an application"""
type ApplicationUser {
  """The id of the application user"""
  id: ID!

  """The title of the application user"""
  name: String

  """The core identifier of the application user"""
  coreIdentifier: String!

  """The date the application user was created"""
  createdAt: Date!

  """The date the application user was last updated"""
  updatedAt: Date!

  """
  The date the application user was last seen interacting with an application
  """
  lastSeenAt: Date

  """The list of applications that this user has interacted with"""
  applications: [ApplicationPreview!]!

  """The list of prompts that this user has interacted with"""
  prompts: [PromptPreview!]!

  """The list of agents that this user has interacted with"""
  agents: [AgentPreview!]!

  """
  Data sub categories that were detected in the prompt runs for this user
  """
  promptRunDataSubCategories: [DataSubCategoryPreview!]!

  """The number of prompt runs that this app user has ran"""
  promptRunCount: Int!
}

"""Inputs for filtering a list of applicationUsers"""
input ApplicationUserFiltersInput {
  """The ids of the application users"""
  ids: [ID!]

  """The ids of the prompts that this app user has called"""
  promptIds: [ID!]

  """The ids of the agents that this user has interacted with"""
  agentIds: [ID!]

  """The ids of the data sub categories that this user has interacted with"""
  dataSubCategoryIds: [ID!]

  """The ids of the applications that this user has interacted with"""
  applicationIds: [ID!]

  """Filter by text (name, coreIdentifier of the application user)"""
  text: String

  """Filter by fuzzy coreIdentifier"""
  coreIdentifier: String

  """Filter by exact coreIdentifier"""
  coreIdentifiers: [String!]
}

"""The order for a ApplicationUser query"""
input ApplicationUserOrder {
  """The field that the ApplicationUser nodes should be ordered by"""
  field: ApplicationUserOrderField!

  """
  The direction in which to order the ApplicationUser nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an application user"""
type ApplicationUserPreview {
  """The id of the application user"""
  id: ID!

  """The title of the application user"""
  name: String

  """The core identifier of the application user"""
  coreIdentifier: String!

  """The date the application user was created"""
  createdAt: Date!

  """The date the application user was last updated"""
  updatedAt: Date!

  """
  The date the application user was last seen interacting with an application
  """
  lastSeenAt: Date
}

type ApplicationUsersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ApplicationUser"""
  nodes: [ApplicationUser!]!

  """int"""
  totalCount: Int!
}

type ApproveRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

type ApproveRequestSecondaryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

"""A possible answer to an assessment question."""
type AssessmentAnswer implements AssessmentAnswerInterface {
  """The id of the assessment answer"""
  id: ID!

  """The index of the assessment answer"""
  index: Int!

  """The value to be displayed for this assessment answer"""
  value: String!

  """The presigned AWS url for where the document answer is stored"""
  presignedUrl: String

  """Whether the answer option was manually created by the user"""
  isUserCreated: Boolean!
}

"""Input for creating an assessment answer"""
input AssessmentAnswerInput {
  """The value to be displayed for this assessment answer"""
  value: String!

  """Whether the answer option was manually created by the user"""
  isUserCreated: Boolean!
}

"""Base fields for answers to an assessment question."""
interface AssessmentAnswerInterface {
  """The id of the assessment answer"""
  id: ID!

  """The index of the assessment answer"""
  index: Int!

  """The value to be displayed for this assessment answer"""
  value: String!

  """The presigned AWS url for where the document answer is stored"""
  presignedUrl: String

  """Whether the answer option was manually created by the user"""
  isUserCreated: Boolean!
}

"""Input for creating an assessment answer option in a template"""
input AssessmentAnswerOptionInput {
  """The value to be displayed for this assessment answer"""
  value: String!
}

"""A previous response to an assessment question."""
type AssessmentAnswerSubmission {
  """The id of the assessment event"""
  id: ID!

  """The time the event was last updated"""
  updatedAt: Date!

  """The id of the question related to this event"""
  assessmentQuestionId: ID!

  """The assessment answers submitted with this event"""
  answers: [SelectedAssessmentAnswerRaw!]!
}

"""An assessment email set"""
type AssessmentEmailSet {
  """The id of the assessment email set"""
  id: ID!

  """The title of the assessment email set"""
  title: String!

  """The description of the assessment email set"""
  description: String!

  """Whether this is the default email set"""
  isDefault: Boolean!

  """The email templates associated with the email set"""
  templates: [Template!]!
}

"""Filters for querying assessment email sets"""
input AssessmentEmailSetFiltersInput {
  """The ids of the assessment email sets to query"""
  ids: [ID!]

  """The title or description of the assessment email sets"""
  text: String

  """Whether the email set is default"""
  isDefault: Boolean
}

type AssessmentEmailSetsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentEmailSet"""
  nodes: [AssessmentEmailSet!]!

  """int"""
  totalCount: Int!
}

"""An event associated with an assessment form"""
type AssessmentEvent {
  """The id of the assessment event"""
  id: ID!

  """The time the event was last updated"""
  updatedAt: Date!

  """The status of the event"""
  status: AssessmentFormStatus!
}

"""
An assessment file uploaded by an organization to be displayed within an assessment or assessment template
"""
type AssessmentFile {
  """The presigned AWS url for where the file is stored"""
  presignedUrl: String!

  """The file size in bytes"""
  size: Int!

  """The mimetype of the file"""
  mimetype: String!

  """The unique id of the assessment file"""
  id: ID!

  """The url in AWS where the assessment file can be downloaded"""
  src: String!
}

"""Filters for filtering a list of assessment files"""
input AssessmentFileFiltersInput {
  """The ids of the assessment files to return"""
  ids: [ID!]
}

type AssessmentFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFile"""
  nodes: [AssessmentFile!]!

  """int"""
  totalCount: Int!
}

"""A comment to an assessment form."""
type AssessmentFormComment {
  """The id of the assessment form comment"""
  id: ID!

  """The content of the assessment form comment"""
  content: String!

  """The user who wrote this comment"""
  author: UserPreview

  """The date the comment was last updated"""
  updatedAt: Date!

  """The date the comment was created"""
  createdAt: Date!

  """The change in status associated with the comment"""
  formStatus: AssessmentFormStatus

  """The ID of the event that the comment refers to"""
  assessmentEventId: ID
}

"""Inputs for filtering a list of assessment form comments"""
input AssessmentFormCommentFiltersInput {
  """The ids of the assessment form comments"""
  ids: [ID!]

  """Filter the comments by the text present in its content"""
  text: String

  """The ids of users wrote the comments"""
  authorIds: [ID!]

  """The IDs of forms that the comments refer to"""
  assessmentFormIds: [ID!]

  """The IDs of events that the comments refer to"""
  assessmentEventIds: [ID!]
}

type AssessmentFormCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormComment"""
  nodes: [AssessmentFormComment!]!

  """int"""
  totalCount: Int!
}

"""The external users assigned to fill out an assessment form."""
type AssessmentFormExternalAssignee {
  """The id of the external assignee."""
  id: ID!

  """The email of the external assignee."""
  email: String!

  """Whether the external user created the form."""
  isFormCreator: Boolean!

  """
  Whether the external user who created the form is still assigned to it.
  """
  isFormCreatorAssigned: Boolean!
}

"""Inputs for filtering a list of assessment forms"""
input AssessmentFormFiltersInput {
  """The ids of assessment forms"""
  ids: [ID!]

  """The ids of users assigned to provide answers for assessment forms"""
  assigneeIds: [ID!]

  """The emails of the external users assigned to the form"""
  externalAssigneeEmails: [String!]

  """The ids of the users assigned to review assessment forms"""
  reviewerIds: [ID!]

  """The labels or descriptions of assessment forms"""
  text: String

  """The IDs of templates from which assessment forms were created"""
  templateIds: [ID!]

  """The IDs of groups to which assessment forms belong"""
  assessmentGroupIds: [ID!]

  """Whether to include only sections assigned to the user"""
  includeAssignedSectionsOnly: Boolean

  """Filter for assessment forms created before this date"""
  createdAtBefore: Date

  """Filter for assessment forms created after this date"""
  createdAtAfter: Date

  """Filter for assessmentForms due on or before this date"""
  dueDateBefore: Date

  """Filter for assessmentForms due after this date"""
  dueDateAfter: Date

  """Filter for assessmentForms with any of these statuses"""
  statuses: [AssessmentFormStatus!]

  """The attribute values used to filter the assessment groups"""
  attributeValueIds: [ID!]
}

"""Assessment form that can be filled out by users"""
type AssessmentFormPreview {
  """The id of the assessment form"""
  id: ID!

  """The internal label of the assessment form"""
  title: String!

  """The status of the assessment form"""
  status: AssessmentFormStatus!
}

"""Assessment form that can be filled out by users"""
type AssessmentFormRaw {
  """The id of the assessment form"""
  id: ID!

  """The user who created the Assessment Form"""
  creator: UserPreview

  """The user who last edited the Assessment Form"""
  lastEditor: UserPreview

  """The internal label of the assessment form"""
  title: String!

  """The description of the assessment form"""
  description: String!

  """The status of the assessment form"""
  status: AssessmentFormStatus!

  """The users assigned to provide answers for this assessment form"""
  assignees: [UserPreview!]!

  """
  The external users assigned to provide answers for this assessment form
  """
  externalAssignees: [AssessmentFormExternalAssignee!]!

  """
  The users responsible for reviewing the answers to this assessment form
  """
  reviewers: [UserPreview!]!

  """Whether the form is locked"""
  isLocked: Boolean!

  """Whether the form is archived"""
  isArchived: Boolean!

  """Whether the form is created by an external user"""
  isExternallyCreated: Boolean!

  """The date by which the assessment form should be completed"""
  dueDate: Date

  """The date the assessmentForm was created"""
  createdAt: Date!

  """The date the assessmentForm was last updated"""
  updatedAt: Date!

  """The date the assessmentForm was assigned to a respondent"""
  assignedAt: Date

  """The date the assessmentForm was submitted by the respondent"""
  submittedAt: Date

  """The date the assessmentForm responses were approved"""
  approvedAt: Date

  """The date the assessmentForm responses were rejected"""
  rejectedAt: Date

  """The Assessment sections under this form"""
  sections: [AssessmentSectionRaw!]!

  """The assessment group to which this form belongs"""
  assessmentGroup: AssessmentGroupPreview!

  """Resources that have this assessment form assigned as an attribute"""
  resources: [AttributeResourceInterface!]!

  """Rows that answers to this assessment form will be synced to"""
  syncedRows: [AttributeResourceInterface!]!

  """The latest event associated with the assessment form"""
  latestEvent: AssessmentEvent!

  """
  Whether the form title is an internal label only, and the group title should be used in communications with assignees
  """
  titleIsInternal: Boolean!

  """The retention schedule for the Assessment Form"""
  retentionSchedule: RetentionSchedule

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!

  """Whether the triggers are enabled"""
  isTriggerEnabled: Boolean!

  """The trigger configured for this form"""
  triggers: [AssessmentTriggerRaw!]!

  """The form that triggered this form"""
  triggeredByForm: AssessmentFormPreview

  """The forms that were triggered by this form"""
  triggeredForms: [AssessmentFormPreview!]!
}

type AssessmentFormsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormRaw"""
  nodes: [AssessmentFormRaw!]!

  """int"""
  totalCount: Int!
}

"""The users assigned to fill out an assessment form."""
input AssessmentFormSectionAssigneesInput {
  """The index of the section"""
  index: Int!

  """The IDs of the users assigned to fill out this assessment section"""
  assigneeIds: [ID!]

  """
  The emails of the external users assigned to review this assessment section
  """
  externalAssigneeEmails: [String!]
}

"""
Input for setting all the syncing row ids of questions in an assessment form
"""
input AssessmentFormSyncRowsInput {
  """The model the sync row ids belong to"""
  syncModel: AssessmentSyncModel!

  """The ids of the rows that the assessment answers will be synced back to"""
  syncRowIds: [String!]!
}

"""
Subset of fields for an editable template from which assessment forms can be created
"""
type AssessmentFormTemplateAttributePreview {
  """The id of the assessment form template"""
  id: ID!

  """The title of the assessment form template"""
  title: String!
}

"""Inputs for filtering a list of assessment form templates"""
input AssessmentFormTemplateFiltersInput {
  """The ids of assessment form templates"""
  ids: [ID!]

  """The titles or descriptions of assessment form templates"""
  text: String

  """The IDs of the users who created the assessment form templates"""
  creatorIds: [ID!]

  """The IDs of the users who created the assessment form templates"""
  lastEditorIds: [ID!]

  """The statuses of the assessment form templates"""
  statuses: [AssessmentFormTemplateStatus!]

  """The method by which the assessment form template was created"""
  sources: [AssessmentFormTemplateSource!]
}

"""
Very limited subset of fields necessary to identify an assessment form template in the UI
"""
type AssessmentFormTemplatePreview {
  """The id of the assessment form template"""
  id: ID!

  """The title of the assessment form template"""
  title: String!
}

"""
Subset of assessment form template fields necessary to create assessment forms
"""
type AssessmentFormTemplatePreviewForCreation {
  """The id of the assessment form template"""
  id: ID!

  """The title of the assessment form template"""
  title: String!

  """The triggers belonging to this template"""
  triggers: [AssessmentTriggerPreview!]!

  """The sections belonging to this template"""
  sections: [AssessmentSectionPreview!]!
}

"""A template for creating assessment forms with questions and answers."""
type AssessmentFormTemplateRaw {
  """The id of the assessment form template"""
  id: ID!

  """The title of the assessment form template"""
  title: String!

  """The description of the Assessment Form Template"""
  description: String!

  """The status of the assessment"""
  status: AssessmentFormTemplateStatus!

  """The method by which the assessment form template was created"""
  source: AssessmentFormTemplateSource!

  """The user who created the Assessment Form Template"""
  creator: UserPreview

  """The user who last edited the Assessment Form Template"""
  lastEditor: UserPreview

  """The id of the parent of this Assessment Form Template"""
  parentId: ID

  """Whether the Assessment Form Template is in a locked status"""
  isLocked: Boolean!

  """Whether the Assessment Form Template is archived"""
  isArchived: Boolean!

  """The date the Assessment Form Template was created"""
  createdAt: Date!

  """The date the Assessment Form Template was last updated"""
  updatedAt: Date!

  """The Assessment sections under this template"""
  sections: [AssessmentSectionRaw!]!

  """
  Attribute keys of type assessment that have been associated with this template
  """
  attributeKeys: [AttributeKeyPreview!]

  """The retention schedule for the Assessment Form Template"""
  retentionSchedule: RetentionSchedule

  """The email template set used for notifications"""
  assessmentEmailSet: AssessmentEmailSet!

  """The trigger configured for this template"""
  triggers: [AssessmentTriggerRaw!]!
}

type AssessmentFormTemplatesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormTemplateRaw"""
  nodes: [AssessmentFormTemplateRaw!]!

  """int"""
  totalCount: Int!
}

type AssessmentFormTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment form that can be filled out by users"""
  assessmentForm: AssessmentFormRaw!
}

"""Input for setting the configuration of the form triggers"""
input AssessmentFormTriggerInput {
  """
  The id of the parent template's assessment trigger within the parent form or template.
  """
  id: ID!

  """The id of the users to assign to the trigger's secondary form"""
  assigneeIds: [ID!]

  """
  The emails of the external users to to assign to the trigger's secondary form
  """
  externalAssigneeEmails: [String!]
}

"""Group of assessment forms"""
type AssessmentGroup {
  """The id of the assessment group"""
  id: ID!

  """The title of the assessment group"""
  title: String!

  """The description of the assessment group"""
  description: String!

  """Whether to enable by default the triggers of this group's forms"""
  isTriggerEnabled: Boolean!

  """The user who created the assessment group"""
  creator: UserPreview

  """The user who last edited the assessment group"""
  lastEditor: UserPreview

  """The users responsible for reviewing new assessment forms in this group"""
  reviewers: [UserPreview!]

  """
  The status of the assessment group, derived from its member assessments
  """
  status: AssessmentFormStatus!

  """The template this assessment group was created from"""
  assessmentFormTemplate: AssessmentFormTemplatePreviewForCreation

  """Whether the group is archived"""
  isArchived: Boolean!

  """The date by which the assessment group should be completed"""
  dueDate: Date

  """The date the assessment group was created"""
  createdAt: Date!

  """The date the assessment group was last updated"""
  updatedAt: Date!

  """The link that external users can use to create forms under this group"""
  shareLink: String

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]

  """The domains accepted for external assignee emails"""
  externalEmailDomains: [String!]!

  """The maximum number of forms that can be created by external users"""
  externalFormLimit: Int

  """
  Whether to allow external users assigned via a link to modify the form's label
  """
  allowExternalLabelEdit: Boolean!
}

"""Inputs for filtering a list of assessment groups"""
input AssessmentGroupFiltersInput {
  """The ids of assessment groups"""
  ids: [ID!]

  """The titles or descriptions of assessment groups"""
  text: String

  """The IDs of templates from which assessment groups were created"""
  templateIds: [ID!]

  """Filter for groups with any of these statuses"""
  statuses: [AssessmentFormStatus!]
}

"""Subset of fields for assessment group"""
type AssessmentGroupPreview {
  """The id of the assessment group"""
  id: ID!

  """The title of the assessment group"""
  title: String!

  """The description of the assessment group"""
  description: String!
}

type AssessmentGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentGroup"""
  nodes: [AssessmentGroup!]!

  """int"""
  totalCount: Int!
}

type AssessmentGroupTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Group of assessment forms"""
  assessmentGroup: AssessmentGroup!
}

"""Input for adding logic to an assessment trigger configuration"""
input AssessmentLogicInput {
  """The operator to use when comparing the rules"""
  logicOperator: LogicOperator!

  """
  The rules to evaluate and be compared with each other using the logic operator
  """
  rules: [AssessmentRuleInput!]

  """The nested logics to add one more level of nesting to the logic."""
  nestedLogics: [AssessmentLogicInput!]
}

"""A comment to an assessment question."""
type AssessmentQuestionComment {
  """The id of the assessment question comment"""
  id: ID!

  """The content of the assessment question"""
  content: String!

  """The user who wrote this comment"""
  author: UserPreview

  """The date the comment was last updated"""
  updatedAt: Date!

  """The date the comment was created"""
  createdAt: Date!
}

"""Inputs for filtering a list of assessment question comments"""
input AssessmentQuestionCommentFiltersInput {
  """The ids of the assessment question comments"""
  ids: [ID!]

  """Filter the comments by the text present in its content"""
  text: String

  """The ids of users wrote the comments"""
  authorIds: [ID!]

  """The IDs of questions that the comments refer to"""
  assessmentQuestionIds: [ID!]
}

"""Input for creating an assessment question comment"""
input AssessmentQuestionCommentInput {
  """The content of the assessment question"""
  content: String!
}

type AssessmentQuestionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionComment"""
  nodes: [AssessmentQuestionComment!]!

  """int"""
  totalCount: Int!
}

"""Inputs for filtering a list of assessment questions"""
input AssessmentQuestionFiltersInput {
  """The ids of the assessment questions"""
  ids: [ID!]

  """Filter the comments by the text present in its title or placeholder"""
  text: String

  """The types of the questions"""
  types: [AssessmentQuestionType!]

  """The IDs of the parent sections"""
  assessmentSectionIds: [ID!]

  """The IDs of the users who responded the questions"""
  respondentIds: [ID!]
}

"""Input for creating an assessment question"""
input AssessmentQuestionInput {
  """The title of the assessment question"""
  title: String!

  """The type of the assessment question"""
  type: AssessmentQuestionType!

  """The sub-type of the assessment question"""
  subType: AssessmentQuestionSubType

  """The placeholder of the assessment question"""
  placeholder: String

  """The description of the assessment question"""
  description: String

  """Whether the assessment question is required"""
  isRequired: Boolean

  """
  Used to identify the question within a form or template so it can be referenced in conditional logic.
  """
  referenceId: String!

  """
  The logic for determining whether this question should show in the assessment form
  """
  displayLogic: DisplayLogicInput

  """The logic for determining the risk score for the assessment question"""
  riskLogic: [RiskLogicInput!]

  """The IDs of the risk categories the risk score applies to"""
  riskCategoryIds: [ID!]

  """The ID of the risk framework the risk score applies to"""
  riskFrameworkId: ID

  """The possible answer options to this question"""
  answerOptions: [AssessmentAnswerOptionInput!]

  """The mime types allowed for the file question"""
  allowedMimeTypes: [String!]

  """Whether the question allows selecting Other"""
  allowSelectOther: Boolean

  """The data inventory model that this assessment question syncs to"""
  syncModel: AssessmentSyncModel

  """
  The column of the data inventory that this assessment question syncs to
  """
  syncColumn: AssessmentSyncColumn

  """The ID of the attributeKey used to respond this question."""
  attributeKeyId: ID

  """Whether the question requires a risk score"""
  requireRiskEvaluation: Boolean

  """
  Whether the question requires the risk to be assigned via a risk matrix
  """
  requireRiskMatrixEvaluation: Boolean
}

"""
A question of an assessment form or template that belongs to a section.
"""
type AssessmentQuestionRaw {
  """The id of the assessment question"""
  id: ID!

  """The title of the assessment question"""
  title: String!

  """The index of the assessment question"""
  index: Int!

  """The type of the assessment question"""
  type: AssessmentQuestionType!

  """The sub-type of the assessment question"""
  subType: AssessmentQuestionSubType!

  """The placeholder of the assessment question"""
  placeholder: String!

  """The description of the assessment question"""
  description: String!

  """Whether the assessment question is required"""
  isRequired: Boolean!

  """
  The logic for determining whether this question should show in the assessment form
  """
  displayLogic: String!

  """The logic for determining the risk score for the assessment question"""
  riskLogic: [String!]!

  """Whether the question requires a risk score"""
  requireRiskEvaluation: Boolean!

  """
  Whether the question requires the risk to be assigned via a risk matrix
  """
  requireRiskMatrixEvaluation: Boolean!

  """The risk categories the risk score applies to"""
  riskCategories: [RiskCategory!]!

  """The risk framework the risk categories belong to"""
  riskFramework: RiskFramework

  """
  The risk level assigned to this question either automatically based on the response, or manually by the respondent
  """
  riskLevel: RiskLevel

  """The risk level manually assigned to this question by the reviewer"""
  reviewerRiskLevel: RiskLevel

  """
  The risk level calculated from the risk matrix values assigned to this question, either automatically based on the response, or manually by the respondent
  """
  riskLevelFromRiskMatrix: RiskLevel

  """The possible Assessment Answers options to this question"""
  answerOptions: [AssessmentAnswer!]!

  """The selected Assessment Answers for this question"""
  selectedAnswers: [SelectedAssessmentAnswerRaw!]!

  """The user who responded the Assessment Question"""
  respondent: UserPreview

  """The attribute key whose values the question should be responded with"""
  attributeKey: AttributeKeyPreview

  """The email of the external user who responded the Assessment Question"""
  externalRespondentEmail: String

  """The comments to this question"""
  comments: [AssessmentQuestionComment!]!

  """The mime types allowed for the file question"""
  allowedMimeTypes: [String!]!

  """The date the question was last answered or edited"""
  updatedAt: Date!

  """
  Used to identify the question within a form or template so it can be referenced in conditional logic.
  """
  referenceId: String!

  """Selected Assessment Answers for previous submissions of this question"""
  previousSubmissions: [AssessmentAnswerSubmission!]!

  """Whether the question allows selecting Other"""
  allowSelectOther: Boolean!

  """The data inventory model that the question syncs back to"""
  syncModel: AssessmentSyncModel

  """The column of the data inventory model that the question syncs back to"""
  syncColumn: AssessmentSyncColumn

  """
  The row IDs of the data inventory table that this question syncs back to.
  """
  syncRowIds: [String!]!

  """
  Whether this question should override existing values in the data inventory
  """
  syncOverride: Boolean!

  """The presigned AWS url for where the risk file is stored"""
  presignedRiskFileUrl: String
}

type AssessmentQuestionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionRaw"""
  nodes: [AssessmentQuestionRaw!]!

  """int"""
  totalCount: Int!
}

"""The possible answer options for a dynamic select-type question."""
type AssessmentQuestionSelectOption {
  """
  The id of the option in its respective database table (not an assessment answer)
  """
  id: String!

  """
  JSON stringified data to provide necessary context for displaying the option
  """
  additionalContext: String!
}

type AssessmentQuestionSelectOptionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionSelectOption"""
  nodes: [AssessmentQuestionSelectOption!]!

  """int"""
  totalCount: Int!
}

"""
Inputs for getting a list of possible answer options for an assessment question
"""
input AssessmentQuestionSelectOptionsFiltersInput {
  """The id of the organization whose answer options we want to retrieve"""
  organizationId: ID

  """
  The Assessment Question subType whose option values we want to retrieve
  """
  subType: AssessmentQuestionSubType!

  """Filter the options by the text search"""
  text: String

  """The ID of the attribute key whose values we want to retrieve"""
  attributeKeyId: ID

  """IDs of the resource the answer options or values corresponds to"""
  resourceIds: [String!]
}

type AssessmentQuestionSelectOptionsTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionSelectOption"""
  nodes: [AssessmentQuestionSelectOption!]!

  """int"""
  totalCount: Int!
}

"""
Inputs for getting a list of possible answer options for an assessment question using a token
"""
input AssessmentQuestionSelectOptionsTokenFiltersInput {
  """The id of the question whose answer options we want to retrieve"""
  id: ID!

  """Filter the options by the text search"""
  text: String
}

"""The rule to evaluate in some assessment logic."""
input AssessmentRuleInput {
  """The reference id of the question whose answer is compared by this rule"""
  questionReferenceId: String!

  """The operator to use when comparing the question answer to the operands"""
  comparisonOperator: ComparisonOperator!

  """The values to compare the question answer to"""
  comparisonOperands: [String!]!
}

"""A comment on an assessment section."""
type AssessmentSectionComment {
  """The id of the assessment section comment"""
  id: ID!

  """The content of the assessment section"""
  content: String!

  """The user who wrote this comment"""
  author: UserPreview

  """The date the comment was last updated"""
  updatedAt: Date!

  """The date the comment was created"""
  createdAt: Date!

  """The ID of the section that the comment belongs to"""
  assessmentSectionId: ID!
}

"""Inputs for filtering a list of assessment section comments"""
input AssessmentSectionCommentFiltersInput {
  """The ids of the assessment section comments"""
  ids: [ID!]

  """Filter the comments by the text present in its content"""
  text: String

  """The ids of users who wrote the comments"""
  authorIds: [ID!]

  """The IDs of sections that the comments refer to"""
  assessmentSectionIds: [ID!]

  """Filter the comments created after a specific date"""
  createdAfter: Date
}

"""Input for creating an assessment section comment"""
input AssessmentSectionCommentInput {
  """The content of the assessment section"""
  content: String!
}

type AssessmentSectionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentSectionComment"""
  nodes: [AssessmentSectionComment!]!

  """int"""
  totalCount: Int!
}

"""The external users assigned to fill out an assessment section."""
type AssessmentSectionExternalAssignee {
  """The id of the external assignee."""
  id: ID!

  """The email of the external assignee."""
  email: String!
}

"""Input for creating an assessment section"""
input AssessmentSectionInput {
  """The title of the assessment section"""
  title: String!

  """The questions belonging to this group"""
  questions: [AssessmentQuestionInput!]
}

"""Preview of an assessment section that belongs to a template or a form"""
type AssessmentSectionPreview {
  """The id of the assessment section"""
  id: ID!

  """The title of the assessment section"""
  title: String!

  """The index of the assessment section"""
  index: Int!
}

"""Assessment section that belongs to a template or a form"""
type AssessmentSectionRaw {
  """The id of the assessment section"""
  id: ID!

  """The title of the assessment section"""
  title: String!

  """The status of the assessment section"""
  status: String

  """The index of the assessment section"""
  index: Int!

  """The questions belonging to this group"""
  questions: [AssessmentQuestionRaw!]!

  """The users assigned to provide answers for this assessment section"""
  assignees: [UserPreview!]!

  """
  The external users assigned to provide answers for this assessment section
  """
  externalAssignees: [AssessmentSectionExternalAssignee!]!

  """Whether the section has been reviewed"""
  isReviewed: Boolean!

  """
  Whether the section contains metadata information about the imported form.
  """
  isMetadata: Boolean!
}

"""Input for creating or updating preferences for a given table"""
input AssessmentsPreferencesInput {
  """The names of columns in the order they should be shown in the table"""
  orderedColumns: [String!]

  """The names of columns to hide"""
  hiddenColumns: [String!]

  """The last time this set of preferences was selected for this table"""
  lastSelected: Date

  """
  Whether this preference is preferred for this table. ONLY set on user preferences.
  """
  isPreferred: Boolean

  """The ID of the assessment group whose preferences are being set"""
  assessmentGroupId: ID!
}

"""The external users associated to an assessment trigger."""
type AssessmentTriggerExternalUser {
  """The id of the external trigger assignee."""
  id: ID!

  """The email of the external assignee."""
  email: String!
}

"""Input for the trigger configuration for an assessment"""
input AssessmentTriggerInput {
  """The action to take"""
  action: AssessmentTriggerAction!

  """The event that causes the action"""
  event: AssessmentTriggerEvent!

  """The id of the template that should be kicked off by this trigger"""
  targetTemplateId: ID

  """The trigger logic to evaluate when deciding whether to take the action"""
  logic: AssessmentLogicInput!
}

"""
Subset of fields for identifying an assessment trigger when creating or updating a form
"""
type AssessmentTriggerPreview {
  """The id of the trigger"""
  id: ID!

  """The action to take"""
  action: AssessmentTriggerAction!

  """The event that causes the action"""
  event: AssessmentTriggerEvent!

  """The template that should be kicked off by this trigger"""
  targetTemplate: AssessmentFormTemplatePreview
}

"""The trigger configured for an assessment template"""
type AssessmentTriggerRaw {
  """The id of the trigger"""
  id: ID!

  """The action to take"""
  action: AssessmentTriggerAction!

  """The event that causes the action"""
  event: AssessmentTriggerEvent!

  """The template that should be kicked off by this trigger"""
  targetTemplate: AssessmentFormTemplatePreview

  """The secondary form kicked off by this trigger"""
  targetForm: AssessmentFormPreview

  """The users to be assigned to the target form."""
  targetAssignees: [UserPreview!]

  """The external users to be assigned to the targer form."""
  targetExternalAssignees: [AssessmentTriggerExternalUser!]

  """The trigger logic to evaluate when deciding whether to take the action"""
  logic: String!
}

"""
An asset file uploaded by an organization to be displayed on their privacy center
"""
type AssetFile {
  """The key where the file is stored"""
  key: String!

  """The file size in bytes"""
  size: Int!

  """The mimetype of the file"""
  mimetype: String!

  """The unique id of the asset file"""
  id: ID!

  """The public url where the asset file can be downloaded"""
  src: String!

  """The alternate text for this asset file"""
  alt: DefinedMessage
}

"""The order for a AssetFile query"""
input AssetFileOrder {
  """The field that the AssetFile nodes should be ordered by"""
  field: AssetFileOrderField!

  """
  The direction in which to order the AssetFile nodes by the specified field
  """
  direction: OrderDirection!
}

type AssetFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssetFile"""
  nodes: [AssetFile!]!

  """int"""
  totalCount: Int!
}

"""Input for grabbing the sombra URL associated with an email reply"""
input AssociateReplyWithSombraInput {
  """
  A JWT containing the parameters for looking up which message was being replied to
  """
  associateReplyWithSombraJWT: String!
}

"""
Tells which sombra is related to an incoming email, and whether that email is threaded
"""
type AssociateReplyWithSombraResponse {
  """Whether an email belongs to an existing thread or not"""
  deleteEmail: Boolean!

  """Sombra instance associated with an email"""
  sombra: SombraInternalUseOnly

  """The email address that matched with a Transcend customer organization"""
  customerEmailAddress: String

  """The URI of the organization the reply is associated with"""
  organizationUri: String
}

type AssumeRolePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The currently logged in user"""
  user: CurrentUser!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext
}

"""An airgap cookie with an attribute value assigned to it"""
type AttributeAirgapCookieResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The ID of this cookie or data flow"""
  id: String!

  """The description for the cookie or data flow"""
  description: String

  """Name or regex of cookie or data flow"""
  name: String!
}

"""An airgap data flow with an attribute value assigned to it"""
type AttributeAirgapDataFlowResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The ID of this cookie or data flow"""
  id: String!

  """The description for the cookie or data flow"""
  description: String

  """Name or regex of cookie or data flow"""
  name: String!
}

"""A business entity with an attribute value assigned to it"""
type AttributeBusinessEntityResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the business entity"""
  id: ID!

  """The time the business entity was created"""
  createdAt: Date!

  """The title of the business entity"""
  title: String!

  """The slug of the business entity for templating"""
  slug: String!

  """The description of the business entity"""
  description: String!

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """Address of entity"""
  address: String!

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String
}

"""A data silo with an attribute value assigned to it"""
type AttributeDataSiloResource implements AttributeResourceInterface & DataSiloInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!
}

"""A data subcategory with an attribute value assigned to it"""
type AttributeDataSubCategoryResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The ID for the subcategory"""
  id: ID!

  """The name of the subcategory"""
  name: String!

  """The category of personal data"""
  category: DataCategoryType!

  """The slug of the category for templating"""
  slug: String!

  """The regex used to identify this data subcategory"""
  regex: String

  """Description of (sub)category"""
  description: String

  """Number of data points within (sub)category"""
  dataPointCount: Int!

  """The attribute values used to label this subcategory"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this data sub category
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this data sub category
  """
  teams: [TeamPreview!]!

  """Whether the subcategory is a default subcategory"""
  isDefault: Boolean!

  """
  The headquarter regions assigned to vendors that have subdatapoints with this data subcategory
  """
  vendorHeadquarterLocations: [String!]!

  """
  The regions assigned to data silos that have subdatapoints with this data subcategory
  """
  dataSiloRegions: [String!]!

  """
  The type of retention schedule for subdatapoints with this data subcategory, or the number of days data is retained for, if type is stated period
  """
  subDataPointRetentionSchedules: [String!]!

  """
  The pre-labeled recipient categories for catalogs associated with data silos whose subdatapoints have this data subcategory
  """
  catalogRecipients: [SaaSCategoryBase!]!

  """The data silos related to the data subcategory"""
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """The identifier that is linked to this data category"""
  identifier: WiredIdentifier

  """The sensitive categories that are related to this data category"""
  sensitiveCategories: [SensitiveCategory!]
}

"""Input for attributeKey and attributeValue creation"""
input AttributeInput {
  """The attribute key that houses the attribute values"""
  key: String!

  """The attribute values used to label resources"""
  values: [String!]!
}

"""An attribute key to house attribute values"""
type AttributeKey {
  """The id for the attribute key"""
  id: ID!

  """The name for the attribute key"""
  name: String!

  """The type of this attribute key"""
  type: AttributeKeyType!

  """The views this attribute key is enabled on"""
  enabledOn: [AttributeSupportedResourceType!]!

  """The slug of the vendor for templating"""
  slug: String!

  """The description for the attribute key"""
  description: String

  """Whether this attribute key is custom created by users"""
  isCustom: Boolean!

  """
  The associated assessment form template for this attribute key, if it is of type "Assessment"
  """
  assessmentFormTemplate: AssessmentFormTemplateAttributePreview
}

"""The order for a AttributeKey query"""
input AttributeKeyOrder {
  """The field that the AttributeKey nodes should be ordered by"""
  field: AttributeKeyOrderField!

  """
  The direction in which to order the AttributeKey nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an attribute key to house attribute values"""
type AttributeKeyPreview {
  """The id for the attribute key"""
  id: ID!

  """The name for the attribute key"""
  name: String!

  """The type of the the attribute key"""
  type: AttributeKeyType!

  """The views this attribute key is enabled on"""
  enabledOn: [AttributeSupportedResourceType!]!

  """The slug of the vendor for templating"""
  slug: String!
}

type AttributeKeysPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AttributeKey"""
  nodes: [AttributeKey!]!

  """int"""
  totalCount: Int!
}

"""Input for filtering the list of attribute keys"""
input AttributeKeysFiltersInput {
  """Filter by text"""
  text: String

  """Filter for the model(s) the attribute key is not enabled on"""
  disabledOn: [AttributeSupportedResourceType!]

  """Filter for the model(s) the attribute key is enabled on"""
  enabledOn: [AttributeSupportedResourceType!]

  """Filter for keys that are custom created by users"""
  isCustom: Boolean

  """Filter for keys of a specific type"""
  type: AttributeKeyType
}

"""A processing activity with an attribute value assigned to it"""
type AttributeProcessingActivityResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the processing activity"""
  id: ID!

  """The title of the processing activity"""
  title: String!
}

"""A processing purpose with an attribute value assigned to it"""
type AttributeProcessingPurposeSubCategoryResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!

  """The ID of the subpurpose"""
  id: ID!

  """The purpose of processing subcategory"""
  name: String!

  """Whether this is a default processing subcategory"""
  isDefault: Boolean!

  """The number of sub-datapoints related to the processing purpose"""
  subDataPointCount: Int!

  """The number of vendors related to the processing purpose"""
  vendors: [VendorPreview!]!

  """The business entities that the processing purpose belongs to"""
  businessEntities: [BusinessEntityPreview!]!

  """The attribute values used to label this processing purpose"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this processing purpose subcategory
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this processing purpose subcategory
  """
  teams: [TeamPreview!]!

  """
  The headquarter regions assigned to vendors whose data silos or their subdatapoints have this processing purpose subcategory
  """
  vendorHeadquarterLocations: [String!]!

  """
  The regions assigned to data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloRegions: [String!]!

  """
  The users assigned as owners to data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloOwners: [UserPreview!]!

  """
  The users assigned as owners to vendors whose data silos or their subdatapoints have this processing purpose subcategory
  """
  vendorOwners: [UserPreview!]!

  """
  The data subcategories assigned to data silos and subdatapoints with this processing purpose subcategory
  """
  dataSubCategories: [DataSubCategoryPreview!]!

  """
  The super categories associated data silos and subdatapoints that have this processing purpose subcategory
  """
  superCategories: [AttributeValue!]!

  """
  The type of retention schedule for subdatapoints with this processing purpose subcategory, or the number of days data is retained for, if type is stated period
  """
  subDataPointRetentionSchedules: [String!]!

  """
  The recipient categories for data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  catalogRecipients: [SaaSCategoryBase!]!

  """
  The data silos that have or whose subdatapoints have this processing purpose
  """
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """
  The data subjects for data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloDataSubjects: [DataSubject!]!

  """
  The controllerships assigned to data silos and subdatapoints with this processing purpose subcategory
  """
  controllerships: [Controllership!]!

  """The sensitive categories that are related to this processing purpose"""
  sensitiveCategories: [SensitiveCategory!]
}

"""A prompt group with an attribute value assigned to it"""
type AttributePromptGroupResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the prompt group"""
  id: ID!

  """The title of the prompt group"""
  title: String!
}

"""A prompt with an attribute value assigned to it"""
type AttributePromptResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the prompt"""
  id: ID!

  """The title of the prompt"""
  title: String!
}

"""A prompt run with an attribute value assigned to it"""
type AttributePromptRunResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the prompt run"""
  id: ID!

  """The title of the prompt run"""
  title: String!
}

"""A request with an attribute value assigned to it"""
type AttributeRequestResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the request"""
  id: ID!

  """The type of request being made"""
  type: String!

  """The status of request being made"""
  status: String!
}

"""Default type for AttributeResourceInterface"""
type AttributeResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!
}

"""
A preview of a generic resource, such as a row associated with an attribute value.
"""
interface AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!
}

"""A sub-datapoint with an attribute value assigned to it"""
type AttributeSubDataPointResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The ID of the subdatapoint"""
  id: ID!

  """The time the subdatapoint was first discovered"""
  createdAt: Date!

  """The name of the subdatapoint"""
  name: String!

  """The display title of the subdatapoint"""
  title: DefinedMessage

  """The slug of the sub datapoint for templating"""
  slug: String!

  """The datapoint for this subdatapoint"""
  dataPoint: DataPoint!

  """The ID of the dataSilo for this subdatapoint"""
  dataSiloId: ID!

  """The ID of the datapoint to associate with this subDataPoint"""
  dataPointId: ID!

  """A description for the subdatapoint"""
  description: String

  """
          When true, this subdatapoint should be revealed in a data access request.
  When false, this field should be redacted.
  """
  accessRequestVisibilityEnabled: Boolean!

  """
          When true, this subdatapoint should be redacted during an erasure request.
  There normally is a choice of enabling hard deletion or redaction at the
  datapoint level, but if redaction is enabled, this column can be used
  to define which fields should be redacted..
  """
  erasureRequestRedactionEnabled: Boolean!

  """The category of personal data for this subdatapoint"""
  categories: [DataSubCategory!]!

  """Guessed subcategories by our classifier that are pending review"""
  pendingCategoryGuesses: [SubDataPointDataSubCategoryGuess!]!

  """The processing purposes for this subdatapoint"""
  purposes: [PurposeSubCategory!]!

  """The attribute values used to label this subdatapoint"""
  attributeValues: [AttributeValue!]!

  """
  The list of teams who are responsible for managing the parent data silo
  """
  dataSiloTeams: [TeamPreview!]!

  """The owners of the DataPoint that is parent of this SubDataPoint"""
  dataPointOwners: [UserPreview!]!

  """The owners of the DataSilo that is parent of this SubDataPoint"""
  dataSiloOwners: [UserPreview!]!

  """The vendor of the DataSilo that is parent of this SubDataPoint"""
  dataSiloVendor: VendorPreview

  """
  The list of teams who are responsible for managing the parent data point
  """
  dataPointTeams: [TeamPreview!]!

  """The content classification status for this SubDataPoint"""
  contentClassificationStatus: ContentClassificationStatus!

  """Whether or not we can refetch the samples for this SubDataPoint"""
  canRefetchSample: Boolean!

  """The organization's controllership of the subdatapoint"""
  controllership: Controllership

  """The last time the subdatapoint's categories were classified"""
  lastClassifiedAt: Date

  """
  The last time the subdatapoint's categories were schedule to be classified
  """
  lastRunAt: Date

  """The list of data subjects that are allowed for this sub-datapoint"""
  subjects: [DataSubject!]!

  """The type of retention schedule for this subdatapoint"""
  retentionType: RetentionType!

  """
  The number of days personal data is retained (for stated period retention types)
  """
  retentionPeriod: Int

  """S3 key for retrieving encrypted samples"""
  encryptedSamplesS3Key: String

  """
  Error message if there was an error encountered while fetching samples or classifying this subdatapoint
  """
  error: String

  """The encryptions to apply to this subdatapoint"""
  encryption: ColumnEncryptionType

  """The fully qualified ID of the subdatapoint"""
  subDataPointFQId: String!

  """The set of processing activities assigned to this subdatapoint"""
  processingActivities: [ProcessingActivityPreview!]!
}

"""An attribute value to label a resource"""
type AttributeValue {
  """The id for the attribute value"""
  id: ID!

  """The attribute key the attribute value belongs to"""
  attributeKey: AttributeKey!

  """The name for the attribute value"""
  name: String!

  """The description for the attribute value"""
  description: String!

  """The color label for the attribute value"""
  color: String

  """Whether attribute value can be deleted"""
  canDelete: Boolean!

  """The assessment form assigned to this attribute"""
  assessmentForm: AssessmentFormPreview

  """
  A secondary classification for attribute values of type "ASSESSMENT"
  """
  assessmentSecondaryType: AssessmentSecondaryType
}

"""The order for a AttributeValue query"""
input AttributeValueOrder {
  """The field that the AttributeValue nodes should be ordered by"""
  field: AttributeValueOrderField!

  """
  The direction in which to order the AttributeValue nodes by the specified field
  """
  direction: OrderDirection!
}

type AttributeValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AttributeValue"""
  nodes: [AttributeValue!]!

  """int"""
  totalCount: Int!
}

"""Input for filtering the list of attribute values"""
input AttributeValuesFiltersInput {
  """Filter by text"""
  text: String

  """Filter by the attribute value IDs"""
  ids: [ID!]

  """Filter by the attribute keys the attribute values belong to"""
  attributeKeys: [ID!]
}

"""A vendor with an attribute value assigned to it"""
type AttributeVendorResource implements AttributeResourceInterface {
  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The unique ID of the vendor"""
  id: ID!

  """The time the vendor was created"""
  createdAt: Date!

  """The title of the vendor"""
  title: String!

  """The slug of the vendor for templating"""
  slug: String!

  """The description of the vendor"""
  description: String!

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """Phone number for the vendor"""
  contactPhone: String

  """Address for the vendor"""
  address: String

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The business entity that the vendor is for"""
  businessEntity: BusinessEntityPreview

  """
  The static SaaS vendor that this vendor is tied to, used to update metadata
  """
  saaSVendor: SaaSVendorPreview
}

"""Inputs for filtering a list of audit events"""
input AuditEventFiltersInput {
  """The types of audit events"""
  codes: [AuditEventCode!]

  """The ids of the users responsible for triggering the events"""
  actorUserIds: [ID!]

  """Whether the event was triggered by a bot"""
  isAutomated: Boolean

  """Filter for events with a specific data silo ID"""
  dataSiloIds: [ID!]

  """Filter for events created before or on this date"""
  createdAtBefore: Date

  """Filter for events created after this date"""
  createdAtAfter: Date

  """Filter for audit events of type Message"""
  filterMessageProperties: [MessageProperties!]
}

"""An event recorded in the audit event log"""
type AuditEventPreviewRaw {
  """The id of the event"""
  id: ID!

  """The time the event occurred"""
  createdAt: Date!

  """The user responsible for triggering the event"""
  actorUser: UserPreview

  """The apiKey responsible for triggering the event"""
  actorApiKeyId: ID

  """The type of audit event"""
  code: AuditEventCode!

  """The original state of the data before a mutation, as stringified JSON"""
  beforeState: String

  """The new state of the data after a mutation, as stringified JSON"""
  afterState: String

  """Additional information about the event, as stringified JSON"""
  additionalContext: String

  """The data silo the event pertains to, if applicable"""
  dataSiloId: ID

  """The action item the event pertains to, if applicable"""
  actionItemId: ID

  """The data subcategory the event pertains to, if applicable"""
  dataSubCategoryId: ID

  """
  The processing purpose subcategory the event pertains to, if applicable
  """
  processingPurposeSubCategoryId: ID

  """The processing activity the event pertains to, if applicable"""
  processingActivityId: ID

  """The sub-datapoint the event pertains to, if applicable"""
  subDataPointId: ID

  """The unique UUID of the transaction where this was added"""
  transactionUuid: String!
}

type AuditEventsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditEventPreviewRaw"""
  nodes: [AuditEventPreviewRaw!]!

  """int"""
  totalCount: Int!
}

"""The counts of cookies regulated by airgap for a given run"""
type AuditorCookiesByAirgapRegulationResults {
  """The number of cookies regulated by airgap"""
  regulated: Int!

  """The number of cookies not regulated by airgap"""
  unregulated: Int!
}

"""The counts of data flows regulated by airgap for a given run"""
type AuditorDataFlowsByAirgapRegulationResults {
  """The number of data flows regulated by airgap"""
  regulated: Int!

  """The number of data flows not regulated by airgap"""
  unregulated: Int!
}

"""Input for retrieving a temporary link to download an auditor file"""
input AuditorFileInput {
  """ID of the auditor run"""
  auditorRunId: ID!

  """The key of the file to download"""
  fileKey: String!
}

type AuditorFileLinkPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  temporaryLink: String!
}

"""A single finding found during a Web Auditor run"""
type AuditorFinding {
  """The ID of this finding"""
  id: ID!

  """The message of the finding"""
  message: String

  """The class of the finding"""
  class: FindingClass!

  """Was the test a pass or a fail"""
  passed: Boolean!

  """The severity of the finding"""
  severity: FindingSeverity!

  """The id of the data flow that created this finding"""
  auditorRunDataFlowId: ID

  """The id of the cookie that created this finding"""
  auditorRunCookieId: ID

  """The associated data flows that created this finding"""
  auditorRunDataFlows: [AuditorRunDataFlow!]

  """The associated cookies that created this finding"""
  auditorRunCookies: [AuditorRunCookies!]
}

type AuditorFindingClassCountsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The counts of each finding for a given finding type"""
  findingCounts: AuditorFindingsByClassResults!
}

"""The Web Auditor Findings Count filters"""
input AuditorFindingClassCountsFiltersInput {
  """
  Filter passing or failing tests. If not specified, defaults to filtering for failing tests.
  """
  passed: Boolean
}

"""The Web Auditor Findings filters"""
input AuditorFindingFiltersInput {
  """Filter by a particular run"""
  runId: ID!

  """Filter by text"""
  text: String

  """Filter by finding class"""
  findingClass: [FindingClass!]

  """Filter by a cookie id """
  cookieId: ID

  """Filter by a data flow id """
  dataFlowId: ID

  """Filter by severity"""
  severity: [FindingSeverity!]

  """
  Filter passing or failing tests. If not specified, defaults to filtering for failing tests.
  """
  passed: Boolean
}

type AuditorFindingsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditorFinding"""
  nodes: [AuditorFinding!]!

  """int"""
  totalCount: Int!
}

"""The counts of each finding for a given finding type"""
type AuditorFindingsByClassResults {
  """The number of AirgapNotFound findings"""
  AirgapNotFound: Int!

  """The number of UnexpectedCookieStored findings"""
  UnexpectedCookieStored: Int!

  """The number of UnexpectedDataFlow findings"""
  UnexpectedDataFlow: Int!

  """The number of UnregulatedCookieStored findings"""
  UnregulatedCookieStored: Int!

  """The number of UnregulatedNetworkRequestMade findings"""
  UnregulatedNetworkRequestMade: Int!

  """The number of CookieMisclassified findings"""
  CookieMisclassified: Int!

  """The number of DataFlowMisclassified findings"""
  DataFlowMisclassified: Int!

  """The number of FacebookLDU findings"""
  FacebookLDU: Int!

  """The number of GoogleRDP findings"""
  GoogleRDP: Int!

  """The number of MicrosoftAdvertising findings"""
  MicrosoftAdvertising: Int!

  """The number of PinterestAds findings"""
  PinterestAds: Int!

  """The number of TikTokPixel findings"""
  TikTokPixel: Int!

  """The number of TwitterAds findings"""
  TwitterAds: Int!

  """The number of Other findings"""
  Other: Int!
}

type AuditorRunPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A single run of auditor with the results"""
  run: AuditorRunResults!
}

"""A single cookie object made during a Web Auditor run"""
type AuditorRunCookies {
  """The ID of this auditor cookie"""
  id: ID!

  """The name of the cookie"""
  name: String

  """The value of the cookie"""
  value: String

  """The domain of the cookie"""
  domain: String

  """The path of the cookie"""
  path: String

  """The amount of time until the cookie expires"""
  expiresDuration: String

  """If the cookie is HttpOnly"""
  httpOnly: Boolean

  """If the cookie is Secure"""
  secure: Boolean

  """The same-site policy of the cookie"""
  sameSite: SameSite!

  """The number of findings for this run"""
  failedFindingsCount: Int

  """The catalog of the service guess associated with this cookie"""
  guessCatalog: SelectableCatalog

  """The guess for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]

  """If the cookie is regulated by Airgap"""
  regulatedByAirgap: Boolean
}

type AuditorRunCookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditorRunCookies"""
  nodes: [AuditorRunCookies!]!

  """int"""
  totalCount: Int!
}

"""The Web Auditor Run Cookies filters"""
input AuditorRunCookiesFiltersInput {
  """Filter by a particular run"""
  runId: ID!

  """Filter by a cookie id """
  id: ID

  """Filter by text"""
  text: String

  """Filter by whether the cookie can be regulated by Airgap"""
  regulatedByAirgap: Boolean

  """Filter by the guesses for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]
}

"""A single run request made during a Web Auditor run"""
type AuditorRunDataFlow {
  """The ID of this run"""
  id: ID!

  """The URL requested"""
  requestEndpoint: String!

  """The resource type of the result"""
  resourceType: String!

  """The method of the request"""
  method: String!

  """If the request was a navigation to a new page"""
  isNavigationRequest: Boolean!

  """The headers of the request"""
  headers: String!

  """The post data of the request"""
  postData: String

  """The number of findings for this run"""
  failedFindingsCount: Int

  """The catalog of the service guess associated with this cookie"""
  guessCatalog: SelectableCatalog

  """The guess for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]

  """Filter by whether the cookie can be regulated by Airgap"""
  regulatedByAirgap: Boolean
}

type AuditorRunDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditorRunDataFlow"""
  nodes: [AuditorRunDataFlow!]!

  """int"""
  totalCount: Int!
}

"""The Web Auditor Run Data Flows filters"""
input AuditorRunDataFlowsFiltersInput {
  """Filter by a particular run"""
  runId: ID!

  """Filter by a data flow id """
  id: ID

  """The URL that was requested"""
  requestEndpoint: String

  """Filter by the request method"""
  method: String

  """Filter by the request resource type"""
  resourceType: String

  """Filter by text"""
  text: String

  """Filter by whether the network request can be regulated by Airgap"""
  regulatedByAirgap: Boolean

  """Filter by the guesses for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]
}

"""The Web Auditor Run filters"""
input AuditorRunFiltersInput {
  """Filter by a particular schedule"""
  scheduleId: ID

  """The URL that was scanned"""
  urlScanned: String

  """Filter by the status of the run"""
  status: AuditorRunStatus

  """Filter by text"""
  text: String
}

"""Input for running a single auditor run"""
input AuditorRunInput {
  """The URL to scan"""
  urlToScan: String!

  """The color scheme to use for the browser"""
  colorScheme: ColorScheme!

  """The type of the device to use for the run"""
  deviceType: String!

  """The steps the browser should take during the run"""
  browserSteps: String!

  """Whether to use the GPC signal for the run"""
  useGPC: Boolean!

  """What region to run the audit in"""
  region: AuditorGQLRegionEnum
}

"""Output from running a single auditor run"""
type AuditorRunResponse {
  """The ID of the auditor run"""
  runId: ID!
}

"""A single run of auditor with the results"""
type AuditorRunResults {
  """The ID of this run"""
  id: ID!

  """The ID of the organization that ran this auditor run"""
  organizationId: ID!

  """
  The ID of the auditor schedule this run was triggered by, if it was triggered by a schedule
  """
  auditorScheduleId: ID

  """The user that triggered the run, if any"""
  user: UserPreview

  """The ID of the API key"""
  apiKeyId: ID

  """The URL scanned in this run"""
  urlScanned: String!

  """The color scheme used for the browser"""
  colorScheme: ColorScheme!

  """The type of the device used for the run"""
  deviceType: String!

  """The HAR file key"""
  harFileKey: String

  """The key of the file containing the requests made during the run"""
  requestsFileKey: String

  """The key of the file containing the cookies stored during the run"""
  cookiesFileKey: String

  """The key of the screenshot taken when the page loaded"""
  screenshotFileKey: String

  """A PDF containing the results of the run"""
  pdfFileKey: String

  """The key to a video recording of the browser running the audit"""
  videoFileKey: String

  """The status of the run"""
  status: AuditorRunStatus!

  """
  If the run was a failure, this is the message to display to the user on why it failed
  """
  errorMessage: String

  """The user behavior simulation step that failed"""
  failedStep: Int

  """When the run was completed"""
  createdAt: Date!

  """When the run was started"""
  startedAt: Date

  """When the run was completed"""
  completedAt: Date

  """The steps the browser took during the run"""
  browserSteps: String!

  """The number of findings for this run"""
  failedFindingsCount: Int

  """Whether to use the GPC signal for the run"""
  useGPC: Boolean!

  """What region to run the audit in"""
  region: AuditorGQLRegionEnum!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

type AuditorRunsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditorRunResults"""
  nodes: [AuditorRunResults!]!

  """int"""
  totalCount: Int!
}

"""
A schedule for running the Web Auditor repeatedly over time on the same URL
"""
type AuditorSchedule {
  """The ID of this schedule"""
  id: ID!

  """The ID of the organization that owns this schedule"""
  organizationId: ID!

  """The user that created this schedule"""
  user: UserPreview

  """The API Key that created this schedule"""
  apiKeyId: ID

  """The URL to scan in jobs created by this schedule"""
  urlToScan: String!

  """The color scheme used for the browser"""
  colorScheme: ColorScheme!

  """The type of the device used for the run"""
  deviceType: String!

  """The steps the browser should take during the run"""
  browserSteps: String!

  """When the run was completed"""
  createdAt: Date!

  """When the first scan was scheduled to run"""
  scheduleStartAt: Date!

  """When the next scan is scheduled to run"""
  scheduledAt: Date!

  """
  How frequently the scan should be run. Needs to be a string because the number can be larger than the MAX_INT
  """
  scheduleFrequency: String!

  """Whether to use the GPC signal for the run"""
  useGPC: Boolean!

  """What region to run the audit in"""
  region: AuditorGQLRegionEnum

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""Input for creating an auditor schedule"""
input AuditorScheduleInput {
  """The URL to scan"""
  urlToScan: String!

  """The color scheme to use for the browser"""
  colorScheme: ColorScheme!

  """The type of the device to use for the run"""
  deviceType: String!

  """The steps the browser should take during the run"""
  browserSteps: String!

  """When the first scan was scheduled to run"""
  scheduleStartAt: Date!

  """
  How frequently the scan should be run. Needs to be a string because the number can be larger than the MAX_INT
  """
  scheduleFrequency: String!

  """Whether to use the GPC signal for the run"""
  useGPC: Boolean!

  """What region to run the audit in"""
  region: AuditorGQLRegionEnum
}

type AuditorSchedulesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AuditorSchedule"""
  nodes: [AuditorSchedule!]!

  """int"""
  totalCount: Int!
}

"""The Web Auditor Schedules filters"""
input AuditorSchedulesFiltersInput {
  """Filter by a particular schedule ID"""
  id: ID

  """The URL that is scanned by this schedule"""
  urlToScan: String

  """Filter by text"""
  text: String
}

"""The counts of each severity for a given run"""
type AuditorSeverityCountsResults {
  """The number of Informational severity findings"""
  Informational: Int!

  """The number of Low severity findings"""
  Low: Int!

  """The number of Medium severity findings"""
  Medium: Int!

  """The number of High severity findings"""
  High: Int!

  """The number of Critical severity findings"""
  Critical: Int!
}

"""The Base Hosts of each env"""
type BaseHosts {
  """The prod environment base hosts"""
  PROD: [String!]
}

"""
Represents a subset of the data subject request fields merged with fields from the relevant data silo to be consumed by the bulk request completion UI
"""
type BulkCompletionReducedRequest {
  """The unique ID of the request dataSilo"""
  id: ID!

  """The time the request was made"""
  createdAt: Date!

  """The time the request was last updated"""
  updatedAt: Date!

  """Link directly to request data silo view"""
  link: String!

  """Notes specific to this RequestDataSilo"""
  details: String!

  """Status of the RequestDataSilos"""
  status: VisualRequestDataSiloStatus!

  """The set of profiles that need to be uploaded for an ACCESS request."""
  accessRequestProfiles: [Profile!]!

  """Request specific metadata"""
  request: ReducedRequestPreview!
}

"""Filters that can be applied when looking up requests when logged in"""
input BulkCompletionReducedRequestAuthenticatedInput {
  """Filter for requests that have been resolved or not"""
  isResolved: Boolean!

  """the id for the data silo (required if token not specified)"""
  dataSiloId: ID

  """The id for the communication to filter by"""
  communicationId: ID

  """The requestType to filter by"""
  requestType: RequestAction
}

"""Filters that can be applied when looking up requests"""
input BulkCompletionReducedRequestInput {
  """The token to validate (required if not logged in)"""
  token: String

  """Filter for requests that have been resolved or not"""
  isResolved: Boolean!

  """the id for the data silo (required if token not specified)"""
  dataSiloId: ID

  """The id for the communication to filter by"""
  communicationId: ID

  """The requestType to filter by"""
  requestType: RequestAction
}

"""
Transparency & Consent Framework (TCF) Stack -combinations of purposes and features used to simplify understanding of consent managementwith additional information about whether the stack is in the bundle
"""
type BundleTCFStack {
  """The ID of the stack as used by TCF"""
  id: Int!

  """
  The name of the stack, e.g. "Precise geolocation data, and identification through device scanning"
  """
  name: String!

  """"""
  description: String!

  """Purposes grouped together in the stack"""
  purposes: [TCFPurpose!]

  """Special Features grouped together in the stack"""
  specialFeatures: [TCFSpecialFeature!]

  """Whether to include the stack in the TCF modal"""
  showInTcfModal: Boolean!

  """
  Whether the stack is unavailable for addition to the bundlebecause its purposes/special features are already covered by another stackor purposes/special features in the stack are not applicable to the bundle
  """
  availableForAddition: Boolean!
}

type BundleTcfStacksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BundleTCFStack"""
  nodes: [BundleTCFStack!]!

  """int"""
  totalCount: Int!
}

"""
A rolled up record consisting of all consent services corresponding a given bundle and TCF vendor id, union all non-TCF vendor consent services.
"""
type BundleTcfVendor {
  """The ID of the vendor as used by TCF (in postgres, its the tcfId field)"""
  id: String

  """The Postgres ID of the vendor"""
  pgId: ID

  """
  The name of the vendor, e.g. "Salesforce.com, Inc."
  """
  name: String

  """The longest potential duration for storage on a device"""
  cookieMaxAgeSeconds: Int

  """Whether the vendor uses cookie storage"""
  usesCookies: Boolean

  """
  True indicates the vendor may refresh cookie(s). False indicates the vendor does not refresh any time the browser reloads
  """
  cookieRefresh: Boolean

  """
  Indicates the vendor's use of non-cookie storage and access to information already stored on a user's device.
  """
  usesNonCookieAccess: Boolean

  """URL to Vendor Device Storage & Operational Disclosures"""
  deviceStorageDisclosureUrl: String

  """
  If present, vendor is considered deleted after this date/time and MUST NOT be established to users
  """
  deletedDate: Date

  """The TCF vendor name or catalog name of the associated consent services"""
  mergedName: String!

  """
  Whether or not this is a record of one or more rolled up TCF vendor consent services.
  """
  isIab: Boolean!

  """The bundle's consent services this vendor is associated with"""
  consentServices: [ConsentService!]!
}

"""Inputs to the show/hide vendor in the TCF UI endpoint"""
input BundleTCFVendorInput {
  """The id of the airgap bundle"""
  airgapBundleId: ID!

  """Whether or not the vendor is registered with the IAB"""
  isIab: Boolean

  """Substring to compare against the TCF vendor name"""
  vendorName: String

  """Substring to compare against the consent service unique name"""
  serviceName: String

  """TCF vendor id to match against"""
  iabId: Int
}

type BundleTcfVendorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BundleTcfVendor"""
  nodes: [BundleTcfVendor!]!

  """int"""
  totalCount: Int!
}

type BusinessEntitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BusinessEntity"""
  nodes: [BusinessEntity!]!

  """int"""
  totalCount: Int!
}

"""Filters for business entities"""
input BusinessEntitiesFiltersInput {
  """The ids of the business entities to return"""
  ids: [ID!]

  """Find any business entities are iLike a text string"""
  text: String

  """Filter by categories of personal data"""
  dataCategories: [DataCategoryType!]

  """Filter by specific subcategories of personal data"""
  dataSubCategoryIds: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """Filter by specific subcategory of processing purpose"""
  processingPurposeSubCategoryIds: [ID!]

  """Filter by ISO country code where the business entity is headquartered"""
  headquarterCountry: [IsoCountryCode!]

  """
  Filter by ISO country subdivision where the business entity is headquartered
  """
  headquarterSubDivision: [String!]

  """
  Filter by IDs of recipient categories associated with the catalogs of silos belonging to this business entity
  """
  saaSCategoryIds: [ID!]

  """Filter by data silos belonging to the business entity's vendors"""
  dataSiloIds: [ID!]

  """The ids of the users that own the business entity"""
  ownerIds: [ID!]

  """The attribute values used to label the business entity"""
  attributeValueIds: [ID!]

  """
  The ids of the teams that should be responsible for this business entity
  """
  teamIds: [ID!]
}

"""
A business entity is an affiliate organization or organization unit within a company.
"""
type BusinessEntity implements BusinessEntityInterface {
  """The unique ID of the business entity"""
  id: ID!

  """The time the business entity was created"""
  createdAt: Date!

  """The title of the business entity"""
  title: String!

  """The slug of the business entity for templating"""
  slug: String!

  """The description of the business entity"""
  description: String!

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """Address of entity"""
  address: String!

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String

  """
  The set of data categories assigned to the sub-datapoints of this business entity
  """
  dataSubCategories: [DataInventoryCategory!]!

  """
  The set of processing purposes assigned to the sub-datapoints of this business entity
  """
  processingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """The attribute values used to label this business entity"""
  attributeValues: [AttributeValue!]!

  """The vendors related to the business entity"""
  vendors: [VendorPreview!]!

  """The data silos related to the business entity"""
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """
  The pre-labeled recipient categories for catalogs associated with the business entity's data silos
  """
  catalogRecipients: [SaaSCategoryBase!]!

  """
  The list of teams who are responsible for managing this business entity
  """
  teams: [TeamPreview!]!

  """
  The list of individual users who are responsible for managing this business entity
  """
  owners: [UserPreview!]!
}

"""An interface for a business entity"""
interface BusinessEntityInterface {
  """The unique ID of the business entity"""
  id: ID!

  """The time the business entity was created"""
  createdAt: Date!

  """The title of the business entity"""
  title: String!

  """The slug of the business entity for templating"""
  slug: String!

  """The description of the business entity"""
  description: String!

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """Address of entity"""
  address: String!

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String
}

"""The order for a BusinessEntity query"""
input BusinessEntityOrder {
  """The field that the BusinessEntity nodes should be ordered by"""
  field: BusinessEntityOrderField!

  """
  The direction in which to order the BusinessEntity nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a business entity"""
type BusinessEntityPreview implements BusinessEntityInterface {
  """The unique ID of the business entity"""
  id: ID!

  """The time the business entity was created"""
  createdAt: Date!

  """The title of the business entity"""
  title: String!

  """The slug of the business entity for templating"""
  slug: String!

  """The description of the business entity"""
  description: String!

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """Address of entity"""
  address: String!

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String
}

type CancelRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

type CatalogPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An integration in the transcend catalog"""
  catalog: Catalog!
}

"""An integration in the transcend catalog"""
type Catalog implements CatalogPreviewInterface {
  """The Catalog id, from the database (not contentfulId)"""
  id: ID!

  """The url for the full logo image"""
  logo: String

  """The url for the square logo image"""
  logoSquare: String!

  """How many data silos of this type the org already has connected"""
  alreadyConnected: Int!

  """The plugins that are supported by this integration"""
  allowedPluginTypes: [PluginType!]!

  """The integration name of the underlying integration type"""
  aliasIntegrationName: String

  """The identifying name of the integration"""
  integrationName: String!

  """The title of the integration"""
  title: String!

  """The default description for the integration"""
  description: String!

  """Hero Image used to feature the catalog"""
  heroImageUrl: String

  """Indicates that datapoints are customizable"""
  dataPointsCustomizable: Boolean!

  """The status of the integration (whether it is fully integrated or not)"""
  integrationStatus: IntegrationStatus!

  """The action types that are allowed for this data silo type"""
  allowedActions: [RequestActionObjectResolver!]!

  """
  The default dataPoints that the integration supports, filtering out _default
  """
  dataPoints: [DefaultDataPoint!]!

  """The default dataPoints that the integration supports"""
  allDataPoints: [DefaultDataPoint!]!

  """
  Communicates information about unencrypted paths and why they are necessary
  """
  plaintextInformation: [PlaintextRequirement!]!

  """
  A representation of the HTML used to explain how to connect the integration
  """
  introMessage: String

  """
  A representation of the HTML used to explain an overview of how the integration works
  """
  businessUserOverview: String

  """
  A representation of the HTML used to explain how to manually process the integration
  """
  controllerManualInstructions: String

  """The TCF Vendor associated with this integration"""
  tcfVendor: TcfVendorPreview

  """The connect silo forms for this catalog member"""
  formConfigs: [FormConfig!]!

  """The plugin configuration forms for this catalog member"""
  pluginFormConfigs: PluginFormConfiguration

  """The pre-labeled recipient categories for this catalog."""
  recipients: [SaaSCategoryBase!]!

  """
  Whether or not the site-scanner recommends this integration for the given organization
  """
  isSuggested: Boolean!

  """
  Boolean indicating whether the tool supports the USP API. This is an API that relates to the do not sell/share requirement for US privacy laws.
  """
  hasUspApiSupport: Boolean

  """The minimum sombra version compatible with the integration"""
  minimumSombraVersion: String!

  """
  Indicates whether the integration is fully integrated, not just with prompt-a-vendor, but with an API integration
  """
  isComplete: Boolean!

  """Indicates whether a catalog entry is compatible with prompt-a-vendor"""
  isPromptAVendorCompatible: Boolean!

  """The email address to use in prompt-a-vendor integrations"""
  promptAVendorEmailAddress: String

  """The prompt a person template id"""
  promptEmailTemplateId: ID

  """The reasons why the integration was disqualified"""
  disqualificationReasons: [String!]

  """Other alternative integrations"""
  seeOtherIntegrations: [String!]

  """Other alternative integrations"""
  integrationConfig: IntegrationConfig

  """Boolean indicating whether the integration is featured"""
  isFeatured: Boolean

  """
  Select "yes" if Transcend Consent has built-in functionality for do not sell (FB pixel, Google Ads, etc.)
  """
  consentDoNotSellIntegration: Boolean

  """String with the background color for the featured hero card"""
  heroBackgroundColor: String

  """
  When true, Transcend has pre-labeled data flow tags for this integration
  """
  hasPrelabeledDataFlows: Boolean!

  """When true, Transcend has pre-labeled cookie tags for this integration"""
  hasPrelabeledCookies: Boolean!

  """
  When true, Transcend has pre-labeled datapoint metadata for this integration
  """
  hasPrelabeledDatapoints: Boolean!

  """When true, the data silo has the ability to resolve requests via email"""
  hasAvcFunctionality: Boolean!

  """When true, the data silo has the ability to resolve requests via API"""
  hasApiFunctionality: Boolean!

  """
  When true, the data silo has the ability to discover new data silos via API
  """
  hasSiloDiscoveryFunctionality: Boolean!

  """When true, the data silo has the ability to classify content"""
  hasContentClassificationFunctionality: Boolean!

  """When true, the data silo has plugins that can be enabled"""
  hasPlugins: Boolean!

  """
  Whether the email address listed has been verified by the Vendor for use fulfilling DSRs
  """
  avcEmailVerified: Boolean

  """The website URL for the integration"""
  website: String

  """Unique namespace for identifying this catalog entry in gradle"""
  gradleNamespace: String

  """Unique namespace for identifying this catalog entry in nuget"""
  nugetNamespace: String

  """Unique namespace for identifying this catalog entry in npm"""
  npmNamespace: String

  """Slug of the github organization that owns this catalog entry"""
  githubOrganizationName: String

  """The integration category"""
  integrationCategory: IntegrationCategory
}

"""Input for filtering catalogs"""
input CatalogFiltersInput {
  """Filter catalogs by their title"""
  text: String

  """Filter by the data silo type"""
  type: [String!]

  """Filter by connector type"""
  connectorType: ConnectorType

  """Filter by plugin type"""
  plugins: [PluginType!]

  """Filter by category"""
  categories: [IntegrationCategory!]
}

"""Input for fetching a catalog"""
input CatalogInput {
  """The name of the integration to fetch"""
  integrationName: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String
}

"""The order for a Catalog query"""
input CatalogOrder {
  """The field that the Catalog nodes should be ordered by"""
  field: CatalogOrderField!

  """
  The direction in which to order the Catalog nodes by the specified field
  """
  direction: OrderDirection!
}

"""A small set of fields required for previewing the catalog"""
type CatalogPreview implements CatalogPreviewInterface {
  """The Catalog id, from the database (not contentfulId)"""
  id: ID!

  """The url for the full logo image"""
  logo: String

  """The url for the square logo image"""
  logoSquare: String!
}

"""A small set of fields required for previewing the catalog"""
interface CatalogPreviewInterface {
  """The Catalog id, from the database (not contentfulId)"""
  id: ID!

  """The url for the full logo image"""
  logo: String

  """The url for the square logo image"""
  logoSquare: String!
}

type CatalogsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Catalog"""
  nodes: [Catalog!]!

  """int"""
  totalCount: Int!
}

"""Inputs for search catalogs by name"""
input CatalogSearchInput {
  """Filter by title or integration name of catalog"""
  text: String!

  """How many results to return (default is 10)"""
  limit: Int
}

"""An SSL certificate issued for the privacy center"""
type Certificate {
  """The unique ID of the SSL certificate"""
  id: ID!

  """
  The record name of the certificate that the organization needs to verify
  """
  recordName: String!

  """The record value that the organization needs to verify"""
  recordValue: String!

  """The unique infrastructure arn of the certificate"""
  arn: String!

  """The status of the certificate"""
  status: CertificateStatus!
}

type ChangePasswordPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The currently logged in user"""
  user: CurrentUser!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext
}

"""Input for changing the password when not logged in"""
input ChangePasswordInput {
  """The new password"""
  newPassword: String!

  """The token that was email to the forgot password email"""
  token: String!
}

"""Information provided with a valid reset password token"""
type ChangePasswordResult {
  """The id of the user"""
  id: ID!

  """The email of the user"""
  email: String!

  """
  When true, the user must check the terms and conditions before creating the account.
  """
  mustAcceptTerms: Boolean!

  """When true, this is the only user in the organization."""
  isOnlyOrganizationUser: Boolean!

  """Terms and conditions"""
  terms: String!

  """The name of the organization"""
  organizationName: String!

  """True if user is onboarded"""
  onboarded: Boolean!
}

type ChangePrimarySombraPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The sombra configuration"""
  sombra: Sombra!
}

type ChangeRequestDataSiloStatusPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The status of looking up a DSR in a data silo"""
  requestDataSilo: RequestDataSilo!
}

type ChangeRequestDataSiloStatusesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""
Verified token from privacy center email login for a child organization
"""
type ChildSessionEmailToken {
  """ID of the child organization"""
  organizationId: ID!

  """JWT session for the data subject for the child organization"""
  jwtSession: String!
}

"""A sub-step in the lifecycle of the DSR"""
type ChildStep implements StepInterface {
  """The id of the step is the request status"""
  id: String!

  """A description of what is happening at this step"""
  description: String!

  """The title message for the step"""
  title: String!

  """The icon to to display with the step"""
  icon: String!

  """The status of the step as it relates to the ant.design component"""
  status: StepStatus

  """The time that the step occurred"""
  time: Date
}

"""The percent of guesses in the categories high, medium,and low"""
type ClassificationConfidence {
  """The percent of guesses in the high category"""
  high: Int!

  """The percent of guesses in the medium category"""
  medium: Int!

  """The percent of guesses in the low category"""
  low: Int!
}

"""A data silo configured for classification"""
type ClassificationDataSilo implements DataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """All plugins associated with this data silo"""
  plugins: [Plugin!]!

  """The number of dataPoints this data silo has"""
  dataPointCount: Int

  """The simplified classification plugin status of the data silo"""
  simplifiedPluginStatus: SimplifiedPluginStatus!

  """
  Number of classified datapoints (auto-classified + user verified) in the data silo
  """
  classifiedDataPointsCount: Int!

  """
  Number of sensitive datapoints (auto-classified + user verified) in the data silo
  """
  sensitiveDataPointsCount: Int!

  """Count of files discovered by unstructured discovery plugin"""
  scannedObjectCount: Int

  """Number of files classified by unstructured discovery plugin"""
  classifiedScannedObjectCount: Int!

  """
  Number of files classified as sensitive by unstructured discovery plugin
  """
  sensitiveScannedObjectCount: Int!

  """Total volume of data scanned by unstructured discovery plugin in bytes"""
  scannedVolumeSize: String

  """A country's ISO code"""
  country: IsoCountryCode

  """A country subdivision ISO code"""
  countrySubDivision: String

  """
  The data sub categories that have sensitive categories associated with this data silo
  """
  sensitiveCategories: [DataSubCategory!]

  """
  All data sub categories (both confirmed and guessed) associated with this data silo
  """
  allDataSubCategories: [DataSubCategory!]

  """Discovery and Classification scan configuration for this data silo"""
  discoClassScanConfig: DiscoClassScanConfig
}

type ClassificationDataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ClassificationDataSilo"""
  nodes: [ClassificationDataSilo!]!

  """int"""
  totalCount: Int!
}

"""Summary statistics for classification data silos"""
type ClassificationDataSiloSummaryStatistics {
  """Total number of data silos"""
  totalDataSilos: Int!

  """Total number of structured data silos with sensitive data"""
  totalSensitiveStructuredDataSilos: Int!

  """Total number of unstructured data silos with sensitive data"""
  totalSensitiveUnstructuredDataSilos: Int!

  """Total number of data points"""
  totalDataPoints: Int!

  """Total number of classified data points"""
  totalClassifiedDataPoints: Int!

  """Total number of sensitive data points"""
  totalSensitiveDataPoints: Int!

  """Total number of files"""
  totalScannedObjects: Int!

  """Total number of classified files"""
  totalClassifiedScannedObjects: Int!

  """Total number of sensitive files"""
  totalSensitiveScannedObjects: Int!

  """Total number of disconnected data silos"""
  totalDisconnectedDataSilos: Int!

  """First disconnected data silo"""
  firstDisconnectedDataSilo: ClassificationDataSilo
}

type ClassifyCookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of CookieSuggestion"""
  cookieSuggestions: [CookieSuggestion!]!
}

"""Input to classify cookies to be created"""
input ClassifyCookiesInput {
  """The cookies to classify"""
  cookies: [UpdateOrCreateCookieInput!]!
}

type ClassifyDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataFlowSuggestion"""
  dataFlowSuggestions: [DataFlowSuggestion!]!
}

"""Input to classify for data flows to be created"""
input ClassifyDataFlowsInput {
  """The data flow entries to create"""
  dataFlows: [DataFlowInput!]!
}

"""Input for classifying arbitrary subDataPoints"""
input ClassifySubDataPointsInput {
  """The ID of the Organization to create an API key in"""
  organizationId: ID!

  """The subDataPoints to classify"""
  subDataPoints: [SubDataPointInput!]!

  """The classification methods to use for evaluation"""
  classificationMethods: [ClassificationMethod!]

  """The LLM features to use for evaluation"""
  llmFeatures: LLMFeaturesInput!

  """LLM template to use for evaluation"""
  llmTemplate: String
}

"""Output for classifying arbitrary subDataPoints"""
type ClassifySubDataPointsOutput {
  """Fully qualified ID of the subDataPoint"""
  subDataPointFQId: String!

  """The classification results"""
  guesses: [SubDataPointClassification!]!
}

type CloneWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration of a workflow - WIP"""
  workflowConfig: WorkflowConfig!
}

"""
Metadata about the cloudfront instance that the privacy center is deployed on
"""
type CloudFront {
  """The unique ID of the cloudfront"""
  id: ID!

  """
  The domain name for the hosted site on a Cloudfront CDN. Where the organization should point their domain
  """
  hostedDomainName: String!

  """The expected domain of the deployed privacy center"""
  deployDomainName: String!

  """Indicates if the cloudfront is deployed"""
  isDeployed: Boolean!

  """True if cloudfront DNS record is set"""
  isValidated: Boolean!
}

"""A code package that contains code submitted to a particular repository"""
type CodePackage {
  """The id of the code package"""
  id: ID!

  """The name of the code package"""
  name: String!

  """The description of the code package"""
  description: String!

  """The date the code package was created"""
  createdAt: Date!

  """The date the code package was last updated"""
  updatedAt: Date!

  """The date the code package was last seen reported"""
  lastSeenAt: Date!

  """The type of code package"""
  type: CodePackageType!

  """Relative path to where the code package lives within the repository"""
  relativePath: String!

  """The SDKs that the code package has within it"""
  softwareDevelopmentKits: [SoftwareDevelopmentKitForPackage!]!

  """The data silo that the code package relates to"""
  dataSilo: DataSiloPreview

  """The repository that code package resides in"""
  repository: RepositoryPreview!

  """The owners that maintain the code package"""
  owners: [UserPreview!]!

  """The teams that maintain the code package"""
  teams: [TeamPreview!]!

  """The number of prompt runs that this code package has ran"""
  promptRunCount: Int!
}

"""Inputs for filtering a list of code packages"""
input CodePackageFiltersInput {
  """The ids of the code packages"""
  ids: [ID!]

  """The ids of the owners that maintain the code packages"""
  ownerIds: [ID!]

  """The ids of the teams that maintain the code packages"""
  teamIds: [ID!]

  """The ids of the repositories that the code packages are made to"""
  repositoryIds: [ID!]

  """
  The ids of the software development kits that the code packages are made to
  """
  softwareDevelopmentKitIds: [ID!]

  """Filter by text (name, description, url)"""
  text: String

  """Filter by code package name"""
  name: String

  """Filter on exact code package names"""
  names: [String!]

  """Filter by whether or not the entry is linked to a consent application"""
  linkedToConsentApp: Boolean

  """The types of code package to include"""
  types: [CodePackageType!]
}

"""The order for a CodePackage query"""
input CodePackageOrder {
  """The field that the CodePackage nodes should be ordered by"""
  field: CodePackageOrderField!

  """
  The direction in which to order the CodePackage nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a code package instance"""
type CodePackagePreview {
  """The id of the code package"""
  id: ID!

  """The name of the code package"""
  name: String!

  """The description of the code package"""
  description: String!

  """The date the code package was created"""
  createdAt: Date!

  """The date the code package was last updated"""
  updatedAt: Date!

  """The date the code package was last seen reported"""
  lastSeenAt: Date!

  """The type of code package"""
  type: CodePackageType!

  """Relative path to where the code package lives within the repository"""
  relativePath: String!
}

type CodePackagesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of CodePackage"""
  nodes: [CodePackage!]!

  """int"""
  totalCount: Int!
}

"""A message that was sent on behalf of a data subject request"""
type Communication {
  """The unique ID of the communication"""
  id: ID!

  """The time the message was created at"""
  createdAt: Date!

  """The HTML template to send"""
  template: String!

  """The subject of the message"""
  subject: String!

  """Who sent the message"""
  from: String!

  """Who received the message"""
  to: String!

  """Hidden recipient"""
  bcc: String

  """The url of the profile picture to display as avatar"""
  avatarUrl: String!

  """Indicates if the communication can be toggled read/unread"""
  canToggleIsRead: Boolean!

  """Indicates that the email bounced and was not received"""
  bounced: Boolean!

  """Indicates if the message is unread"""
  read: Boolean!

  """The type of communication"""
  type: CommunicationMessage!

  """The user that sent the message when not automated"""
  user: UserPreview

  """Indicates if the message is unread"""
  isEncrypted: Boolean

  """The data silo ID of the communication"""
  RequestDataSiloId: ID

  """The list of attachment file names for the email"""
  attachmentFilenames: [String!]!
}

"""Input for sending a message to the data subject"""
input CommunicationInput {
  """The id of the request to send to"""
  requestId: ID!

  """The HTML email template to send"""
  template: String

  """The subject of the email"""
  subject: String
}

"""
A message that was sent on behalf of a data subject request with a reduced set of fields for the bulk requests UI
"""
type CommunicationMetadata {
  """The unique ID of the communication"""
  id: ID!

  """The time the message was created at"""
  createdAt: Date!
}

type CompileRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

"""Input to update component styles"""
input ComponentStylesInput {
  """
  Custom styling for "h1"
  """
  h1: String

  """
  Custom styling for "h2"
  """
  h2: String

  """
  Custom styling for "h3"
  """
  h3: String

  """
  Custom styling for "body"
  """
  body: String

  """
  Custom styling for "sideMenuText"
  """
  sideMenuText: String

  """
  Custom styling for "primaryButton"
  """
  primaryButton: String

  """
  Custom styling for "secondaryButton"
  """
  secondaryButton: String

  """
  Custom styling for "emailButton"
  """
  emailButton: String

  """
  Custom styling for "emailContainer"
  """
  emailContainer: String

  """
  Custom styling for "hero"
  """
  hero: String

  """
  Custom styling for "heroBackground"
  """
  heroBackground: String

  """
  Custom styling for "takeControlConfirmation"
  """
  takeControlConfirmation: String
}

"""The sombra configuration with associated models"""
type ConfiguredSombra implements SombraInterface {
  """The id of the sombra"""
  id: ID!

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  publicKeyECDH: String

  """The url of the Sombra instance that Transcend uses (transcend-ingress)"""
  url: String!

  """
  The title of the gateway, useful for a human-readable name when there are multiple gateways in an organization
  """
  title: String

  """
  The url of the Sombra instance that the client posts to when responding to a server silo
  """
  publicUrl: String!

  """
  When true, the sombra gateway is the primary instance in the organization
  """
  isPrimarySombra: Boolean!

  """
  The url of the Sombra instance that the customer should use (customer-ingress)
  """
  customerUrl: String!

  """The ip addresses of the sombra instance"""
  ipAddresses: [String!]!

  """The Sombra instance type"""
  hostedMethod: SombraHostedMethod!

  """The most recent version of Sombra available"""
  mostRecentSombra: String!

  """The semantic version that the sombra is on"""
  version: String

  """The tenant parameters config"""
  tenantParameters: TenantParamsInputSchema

  """The sombra audience"""
  audience: String!

  """The employee authentication methods"""
  employeeAuthenticationMethods: [SombraEmployeeAuthMethod!]

  """The data subject authentication methods"""
  dataSubjectAuthenticationMethods: [SombraDataSubjectAuthMethod!]

  """If the Sombra is accessed through Transcend's Reverse Tunnel"""
  isReverseTunneledSombra: Boolean!

  """The data silos associated ot the gateway"""
  dataSilos: [Resource!]!
}

"""The application (namespace) for storing consent data"""
type ConsentApplication {
  """ID of the consent application"""
  id: ID!

  """Unique name of this consent application"""
  name: String!

  """Description of this consent application"""
  description: String!

  """The code package associated with this consent application"""
  codePackage: CodePackagePreview

  """Number of SDKs associated with this consent application"""
  sdkCount: Int!
}

"""Input for filter consent application"""
input ConsentApplicationFiltersInput {
  """ID of the consent application"""
  ids: [ID!]

  """Filter the consent applications by name"""
  text: String
}

"""The application (namespace) for storing consent data"""
type ConsentApplicationPreview {
  """ID of the consent application"""
  id: ID!

  """Unique name of this consent application"""
  name: String!

  """Description of this consent application"""
  description: String!

  """The code package associated with this consent application"""
  codePackage: CodePackagePreview
}

type ConsentApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentApplication"""
  nodes: [ConsentApplication!]!

  """int"""
  totalCount: Int!
}

"""Input for creating or updating a consent application"""
input ConsentApplicationUpsertInput {
  """ID of the consent application"""
  id: ID

  """Unique name of this consent application"""
  name: String

  """Description of this consent application"""
  description: String

  """ID of the code package to associate with this consent application"""
  codePackageId: ID
}

"""Hosts found through telemetry or added by users"""
type ConsentHost {
  """The ID of this site record"""
  id: ID!

  """The host for the site"""
  host: String

  """
  Indicates how the row was added to the table; user ID or null (will display "Transcend Consent")
  """
  user: UserPreview

  """
  Indicates when telemetry data has been encountered from this site, and if so how old it is
  """
  lastDiscoveredAt: Date

  """Optional free text notes field"""
  description: String

  """
  The date the site was first added to the table, whether by telemetry or manually
  """
  createdAt: Date!

  """The date the site was deleted by the user, or reverted by telemetry"""
  deletedAt: Date
}

"""Record of consent preferences"""
input ConsentLastKeyInput {
  """user id"""
  userId: String!

  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """The timestamp of the last record returned"""
  timestamp: String

  """The timestamp of when the record was last updated"""
  updatedAt: String

  """The linked identifier for the last key; Used for pagination"""
  linkedIdentifier: String
}

"""Last key used for pagination"""
type ConsentLastKeySchema {
  """user id"""
  userId: String!

  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id)
  """
  partition: String!

  """The timestamp of the last record returned"""
  timestamp: String

  """The timestamp of when the record was last updated"""
  updatedAt: String

  """The linked identifier for the last key; Used for pagination"""
  linkedIdentifier: String
}

type ConsentManagerPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""The configuration and metadata for the consent manager (aka Airgap)."""
type ConsentManager {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """The name of this Consent Manager bundle."""
  name: String!

  """Whether the consent manager should regulate requests."""
  off: Boolean!

  """The state of this current Consent Manager bundle."""
  state: BundleDeployStatus!

  """The configuration for this Consent Manager."""
  configuration: ConsentManagerBundleConfig!

  """The absolute URL of where the consent manager JS bundle is hosted."""
  bundleURL: String!

  """
  The absolute URL of where the test bundle of the consent manager is hosted.
  """
  testBundleURL: String!

  """The onboarding status of this consent manager"""
  onboardingStatus: ConsentManagerOnboardingStatus!

  """
  When the Consent Manager was last deployed (may be undefined if never deployed)
  """
  lastDeployedAt: Date

  """The airgap.js core library version"""
  version: String!

  """
  Whether or not there is a later airgap.js version that this bundle can upgrade to
  """
  canUpdateVersion: Boolean!

  """Whether or not this consent manager uses the default TCF settings"""
  useDefaultTcfSettings: Boolean

  """
  The absolute URL of where the tcf ui bundle of the consent manager is hosted.
  """
  tcfUiBundleURL: String!

  """The selected consent partition"""
  partition: ConsentPartition

  """The custom domain from which to load airgap modules"""
  customDomain: String

  """
  Are the modules for this bundle hosted by Transcend, or is the customer hosting them?
  """
  isTranscendHosted: Boolean!

  """Whether to use experience-specific modules"""
  useModules: Boolean!

  """Whether to use IAB Consent Frameworks"""
  useIabFramework: Boolean!

  """The error was encountered during bundle deployment, if any"""
  deployError: String

  """
  The URL to send POST request notifications to whenever a deployment occurs
  """
  webhookUrl: String

  """Custom headers to include in outbound deployment webhook notification"""
  headers: [CustomHeader!]!

  """Custom JS script to run before airgap.js loads"""
  prefixScript: String

  """Custom JS script to run after airgap.js loads"""
  suffixScript: String
}

"""Configuration for the Consent Manager"""
type ConsentManagerBundleConfig {
  """Domains that a consent manager is allowed to run on."""
  domains: [String!]!

  """CSP protection configuration."""
  csp: CspOption!

  """The consent manager unknown request policy"""
  unknownRequestPolicy: UnknownRequestPolicy!

  """The consent manager unknown cookie policy"""
  unknownCookiePolicy: UnknownRequestPolicy!

  """The XDI sync endpoint for this airgap bundle"""
  syncEndpoint: String

  """The telemetry partitioning strategy"""
  telemetryPartitioning: TelemetryPartitionStrategy!

  """The Sampling Rate for telemetry sessions"""
  telemetrySampleRate: String

  """Client-side sampling rate for outgoing requests and cookie mutations"""
  reqCookieSampleRate: String

  """Client-side sampling rate for outgoing requests and cookie mutations"""
  eventSampleRate: String

  """Whether the site owner has signed the IAB agreement"""
  signedIabAgreement: SignedIabAgreementOption

  """Whether or not to use the US Privacy API"""
  uspapi: UspapiOption

  """The Shared XDI host sync groups config (JSON) for this airgap bundle"""
  syncGroups: String

  """Key used to partition consent records"""
  partition: String

  """The consent resolution precedence strategy"""
  consentPrecedence: ConsentPrecedenceOption!

  """Backend consent sync"""
  backendSync: BackendSyncOption

  """Backend consent sync endpoint URL"""
  backendSyncEndpoint: String

  """Whether to use the default settings for TCF"""
  useDefaultTcfSettings: Boolean

  """How the Consent Manager should partition telemetry data"""
  strategy: TelemetryPartitionStrategy
}

"""Configuration for the Consent Manager"""
input ConsentManagerBundleConfigInput {
  """
  Domains that a consent manager is allowed to run on. Defaults to the organization URI.
  """
  domains: [String!]

  """CSP protection configuration. Defaults to Lax."""
  csp: CspOption
}

type ConsentManagerConfigurationJsonPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration for the consent manager."""
  consentManagerConfigurationJson: ConsentManagerConfigurationJson!
}

"""The configuration for the consent manager."""
type ConsentManagerConfigurationJson {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """
  The JSON containing all the configurations for this Consent Manager Test bundle.
  """
  testConfigurationJson: String!

  """The JSON containing all the configurations for this Consent Manager."""
  configurationJson: String!

  """Whether to use IAB Consent Frameworks"""
  useIabFramework: Boolean!
}

"""The count of relevant consent manager labels"""
type ConsentManagerCount {
  """Number of items in state: LIVE"""
  LIVE: Int!

  """Number of items in state: NEEDS_REVIEW"""
  NEEDS_REVIEW: Int!
}

"""Style sheet encoding for consent manger ui"""
type ConsentManagerStyleItem {
  """Section header for style, used to group similar selectors"""
  header: String!

  """Comment for style selector"""
  comment: String!

  """The style selector"""
  selector: String!

  """The CSS string"""
  styles: String!

  """The media styles string"""
  mediaStyles: String
}

"""Input for updating consent-manager-ui stylesheet"""
input ConsentManagerStyleItemInput {
  """Section header for style, used to group similar selectors"""
  header: String!

  """Comment for style selector"""
  comment: String!

  """The style selector"""
  selector: String!

  """The CSS string"""
  styles: String!

  """The media styles string"""
  mediaStyles: String
}

type ConsentManagerThemePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The UI theme configuration associated with a consent manager bundle"""
  theme: ConsentManagerTheme!
}

"""The UI theme configuration associated with a consent manager bundle"""
type ConsentManagerTheme {
  """The ID of the associated Consent Manager bundle."""
  airgapBundleId: ID!

  """The button color"""
  primaryColor: String!

  """The type (text) color"""
  fontColor: String!

  """Custom styles for the consent manager UI"""
  styles: [ConsentManagerStyleItem!]!

  """The privacy policy URL"""
  privacyPolicy: String

  """
  The number of page views at which to prompt the default consent banner. To turn off auto-prompt, set this to 0.
  """
  prompt: Int!
}

"""A consent manager UI"""
type ConsentManagerUI {
  """The id of the consent manager UI"""
  id: ID!

  """The slug for this UI script"""
  name: String!

  """location for UI script"""
  scriptLocation: String!
}

type ConsentManagerUIsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentManagerUI"""
  nodes: [ConsentManagerUI!]!

  """int"""
  totalCount: Int!
}

"""The partition (namespace) for storing consent data"""
type ConsentPartition {
  """ID of the consent partition"""
  id: ID!

  """Human-readable name of this consent partition"""
  name: String!

  """
  Unique random string that will be used to partition consent data by airgap.js and consent-backend
  """
  partition: String!
}

"""Input for filter consent partition"""
input ConsentPartitionFiltersInput {
  """ID of the consent partition"""
  ids: [ID!]

  """Human-readable name of this consent partition"""
  name: String

  """Unique partition value"""
  partition: String
}

type ConsentPartitionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentPartition"""
  nodes: [ConsentPartition!]!

  """int"""
  totalCount: Int!
}

"""Response for consent preference request"""
type ConsentPreferenceResponseSombra {
  """Record of consent preferences"""
  nodes: [ConsentRecord!]!

  """Last key used for pagination for consent preferences"""
  lastKey: ConsentLastKeySchema

  """Error message for client"""
  clientErrorMessage: String
}

type ConsentPreferencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of EnrichedConsentRecordSchema"""
  nodes: [EnrichedConsentRecordSchema!]!

  """Last key used for pagination"""
  lastKey: ConsentLastKeySchema

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""Input for querying consent preferences"""
input ConsentPreferencesInput {
  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """The last record returned from previous requests; Used for pagination"""
  lastKey: ConsentLastKeyInput

  """
  Only return records with consent events before this timestamp; default is now
  """
  timestampBefore: String

  """Only return records with consent events after this timestamp"""
  timestampAfter: String

  """Only return records updated before this timestamp"""
  updatedBefore: String

  """Only return records updated after this timestamp"""
  updatedAfter: String
}

"""Input for updating a single consent preference"""
input ConsentPreferenceUpdateInput {
  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """Consent purposes"""
  purposes: [PurposeInput!]!

  """Metadata"""
  metadata: String

  """Last-modified for metadata timestamp (ISO 8601)"""
  metadataTimestamp: String
}

"""Record of consent preferences"""
type ConsentRecord {
  """encrypted identifier for user"""
  encryptedIdentifier: String!

  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """purposes"""
  purposes: [PurposeSchema!]!

  """Most recent consent event timestamp (ISO 8601)"""
  timestamp: String!

  """US IAB Privacy String"""
  usp: String

  """IAB GPP String, encoding both USP and USNAT"""
  gpp: String

  """IAB TCF String"""
  tcf: String

  """Airgap Version"""
  airgapVersion: String

  """Metadata"""
  metadata: String

  """Last-modified for metadata timestamp (ISO 8601)"""
  metadataTimestamp: String

  """Last record modification timestamp (ISO 8601)"""
  updatedAt: String

  """The identifiers for the user"""
  identifiers: [PreferenceStoreIdentifierSchema!]!
}

"""The SDK that should be governed based on user consent"""
type ConsentSdk {
  """ID of the consent SDK"""
  id: ID!

  """Unique identifier for this consent SDK"""
  slug: String!

  """Description of this consent SDK"""
  description: String

  """A list of tracking purposes associated with this SDK"""
  purposes: [TrackingPurpose!]!

  """The consent service this SDK belongs to"""
  consentService: ConsentServicePreview!

  """The consent app this SDK belongs to"""
  consentApplication: ConsentApplicationPreview!

  """The scanned SDK this consent SDK belongs to"""
  softwareDevelopmentKit: SoftwareDevelopmentKitPreview
}

"""Input for filtering consent SDKs"""
input ConsentSdkFiltersInput {
  """Filter the consent SDKs by fuzzy match on slug and description"""
  text: String

  """Filter the consent SDKs by their associated service"""
  consentServiceIds: [ID!]

  """Filter the consent SDKs by their associated application"""
  consentApplicationIds: [ID!]

  """Filter the consent SDKs by purpose ID"""
  purposeIds: [ID!]
}

type ConsentSdksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentSdk"""
  nodes: [ConsentSdk!]!

  """int"""
  totalCount: Int!
}

"""Input for creating or updating a consent SDK"""
input ConsentSdkUpsertInput {
  """Unique identifier for this consent SDK"""
  slug: String!

  """ID of the consent application this SDK belongs to"""
  consentApplicationId: ID

  """ID of the consent service this SDK belongs to"""
  consentServiceId: ID

  """
  The catalog integration name of the consent service this SDK belongs to. If one does not exist, we will automatically create a new consent service entry.
  """
  consentServiceCatalogName: String

  """Description of this consent SDK"""
  description: String

  """IDs of the tracking purposes associated with this SDK"""
  purposeIds: [ID!]

  """ID of the scanned SDK this consent SDK belongs to"""
  softwareDevelopmentKitId: ID
}

"""Metadata relating to a service regulated by our Consent Manager"""
type ConsentService implements ConsentServicePreviewInterface {
  """ID of the consent service"""
  id: ID!

  """Metadata about the service"""
  service: SelectableCatalog!

  """Unique name for this service"""
  name: String!

  """Description of this service"""
  description: String

  """
  Status of this service -- only live and not-junk services are included in the live airgap bundle
  """
  status: ConsentTrackerStatus!

  """
  Whether or not this consent service should be included in the live airgap bundle
  """
  isJunk: Boolean!

  """
  The number of live, not junk data flows found associated to the same catalog entry as this consent service
  """
  dataFlowCount: Int!

  """
  The number of live, not junk cookies found associated to the same catalog entry as this consent service
  """
  cookieCount: Int!

  """The number of SDKs found associated to the same catalog entry"""
  sdkCount: Int!

  """Whether or not to show this consent service in the TCF UI modal"""
  showInTcfModal: Boolean!
}

"""A small set of fields required for previewing the consent service"""
type ConsentServicePreview implements ConsentServicePreviewInterface {
  """ID of the consent service"""
  id: ID!

  """Metadata about the service"""
  service: SelectableCatalog!

  """Unique name for this service"""
  name: String!
}

"""Metadata relating to a service regulated by our Consent Manager"""
interface ConsentServicePreviewInterface {
  """ID of the consent service"""
  id: ID!

  """Metadata about the service"""
  service: SelectableCatalog!

  """Unique name for this service"""
  name: String!
}

type ConsentServicesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentService"""
  nodes: [ConsentService!]!

  """int"""
  totalCount: Int!
}

"""Sites found through telemetry or added by users"""
type ConsentSite {
  """
  Indicates when telemetry data was most recently encountered from this site, if it was encountered
  """
  lastDiscoveredAt: Date

  """The eTLD+1 of the URL telemetry was emitted from"""
  site: String!

  """
  The time when telemetry from the site was first encountered (or when the site was added manually)
  """
  createdAt: Date!

  """List of encountered hosts that are descendant to the site"""
  hosts: [ConsentHost!]!
}

type ConsentSitesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentSite"""
  nodes: [ConsentSite!]!

  """int"""
  totalSiteCount: Int!

  """int"""
  totalHostCount: Int!
}

"""Preview of action with subset of fields"""
type ConsentWorkflowActionPreview {
  """The unique id of the action"""
  id: ID!

  """The display title of the request action with associated translations"""
  subjectTitle: Message!

  """The type of action"""
  type: RequestAction!
}

"""Settings for triggering a consent workflow"""
input ConsentWorkflowSettingsInput {
  """
  Additional custom fields to include as metadata with the consent change event
  """
  attributes: [AttributeInput!]

  """The data silos to process for this request"""
  dataSiloIds: [ID!]

  """The ID of the email template to send"""
  emailReceiptTemplateId: ID

  """
  The set of data silo IDs that should NOT be processed. When specified, the default set of data silos will be calculated and then these IDs will be subtracted from that list.
  """
  ignoreDataSiloIds: [ID!]

  """When true, no emails should be sent to the data subject"""
  isSilent: Boolean

  """When true, request is a test request"""
  isTest: Boolean

  """When true, do not send a receipt email"""
  skipSendingReceipt: Boolean

  """When true, skip any waiting period associated with the workflow."""
  skipWaitingPeriod: Boolean

  """Whether to skip workflow trigger associated for this purpose. """
  skipWorkflowTrigger: Boolean
}

"""Preview of data subject with subset of fields"""
type ConsentWorkflowSubjectPreview {
  """The UUID for the data subject configuration"""
  id: ID!

  """The display title for the data subject class"""
  title: DefinedMessage!

  """
  The unique name of the data subject classification within the organization
  """
  type: String!

  """Whether the data subject is currently turned on"""
  active: Boolean!

  """The icon to display with the data subject"""
  icon: String
}

"""The Consent Workflow Trigger"""
type ConsentWorkflowTrigger {
  """ID of the consent Workflow Trigger"""
  id: ID!

  """The name of the consent workflow trigger"""
  name: String!

  """The condition to trigger the consent workflow"""
  triggerCondition: String!

  """The action associated to the consent workflow trigger"""
  action: ConsentWorkflowActionPreview!

  """The data-subject associated to the consent workflow trigger"""
  subject: ConsentWorkflowSubjectPreview!

  """If a DSR is triggered, is it a silent request"""
  isSilent: Boolean!

  """If workflow is allowed to be triggered for unauthenticated users"""
  allowUnauthenticated: Boolean!

  """If the trigger is active"""
  isActive: Boolean!

  """The set of data silos that are configured for this workflow"""
  dataSilos: [DataSiloPreview!]!

  """The set of datapoints that are configured for this workflow"""
  dataPoints: [DataPointPreviewWithDataSilo!]!
}

"""Marketing purposes id with matching state"""
input ConsentWorkflowTriggerPurposeInput {
  """ID of the purpose"""
  purposeId: ID

  """The state of the purpose to trigger the workflow"""
  matchingState: Boolean!
}

type ConsentWorkflowTriggersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentWorkflowTrigger"""
  nodes: [ConsentWorkflowTrigger!]!

  """int"""
  totalCount: Int!
}

"""The filter options to fetch consent workflow triggers"""
input ConsentWorkflowTriggersFilterInput {
  """Filter the consent workflow triggers by purpose IDs"""
  purposeIds: [ID!]

  """Filter the consent workflow triggers by tracking types"""
  trackingTypes: [String!]

  """Filter the consent workflow triggers by text"""
  text: String

  """Filter the consent workflow triggers by action ID"""
  actionIds: [ID!]

  """Filter the consent workflow triggers by subject ID"""
  dataSubjectIds: [ID!]

  """Filter the consent workflow triggers that are active"""
  isActive: Boolean

  """Filter the consent workflow triggers that trigger DSR in silent mode"""
  isSilent: Boolean

  """
  Filter the consent workflow triggers that are allowed for unauthenticated users
  """
  allowUnauthenticated: Boolean
}

type ContentClassificationDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataPointHierarchyItem"""
  nodes: [DataPointHierarchyItem!]!

  """int"""
  totalCount: Int!
}

"""
Input for filtering dataPoints for a data silo that has the classification plugin enabled
"""
input ContentClassificationDataPointsFiltersInput {
  """Filter by data silos the datapoints belong to"""
  dataSiloId: ID!
}

"""The order for a ContentClassificationDataPoint query"""
input ContentClassificationDataPointOrder {
  """
  The field that the ContentClassificationDataPoint nodes should be ordered by
  """
  field: ContentClassificationDataPointOrderField!

  """
  The direction in which to order the ContentClassificationDataPoint nodes by the specified field
  """
  direction: OrderDirection!
}

"""A data silo configured for content classification"""
type ContentClassificationDataSilo implements DataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """The number of subdatapoints this data silo has"""
  subDataPointCount: Int!

  """All plugins associated with this data silo"""
  plugins: [Plugin!]!

  """Discovery and Classification scan configuration for this data silo"""
  discoClassScanConfig: DiscoClassScanConfig
}

"""
Inputs for determining what content classification data silos to filter
"""
input ContentClassificationDataSiloFiltersInput {
  """Filter by data silo ids"""
  ids: [ID!]

  """Filter by text (title of data silo)"""
  text: String

  """Filter by the data silo type"""
  type: [String!]

  """Filter for data silos that are deleted"""
  isDeleted: Boolean

  """Filter by whether plugin(s) are enabled"""
  pluginsEnabled: Boolean

  """Filter by the assigned owner IDs"""
  owners: [ID!]

  """Filter by the assigned team IDs"""
  teams: [ID!]

  """Filter by ISO country"""
  country: [IsoCountryCode!]

  """Filter by ISO country subdivision"""
  countrySubDivision: [String!]

  """Filter by simplified plugin status"""
  simplifiedPluginStatus: [SimplifiedPluginStatus!]

  """Filter by classification plugin type"""
  classificationPluginTypes: [ClassificationPluginType!]

  """Filter by whether the data silo has any sensitive categories"""
  hasSensitiveData: Boolean
}

"""The configuration for content classification plugins"""
type ContentClassificationPluginConfigurationSchema {
  """Whether to support non-null sampling configuration."""
  nonNullSampling: Boolean!
}

type ContentClassificationSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ContentClassificationDataSilo"""
  nodes: [ContentClassificationDataSilo!]!

  """int"""
  totalCount: Int!
}

"""A legal contract"""
type Contract {
  """The id of the contract"""
  id: ID!

  """The title of the contract"""
  name: String!

  """The description of the contract"""
  description: String!

  """The date the contract was created"""
  createdAt: Date!

  """The date the contract was last updated"""
  updatedAt: Date!

  """The content of the contract"""
  content: String!

  """The user who uploaded this contract"""
  uploader: UserPreview

  """The API key who uploaded this contract"""
  apiKey: ApiKeyPreview

  """The user who last edited the contract"""
  lastEditor: UserPreview

  """The number of times this contract has been scanned"""
  contractScanCount: Int!
}

"""Inputs for filtering a list of contracts"""
input ContractFiltersInput {
  """The ids of the contracts"""
  ids: [ID!]

  """The ids of the users that uploaded the contracts"""
  uploaderIds: [ID!]

  """The ids of the users that edited the contracts"""
  lastEditorIds: [ID!]

  """The ids of the API keys that uploaded the contracts"""
  apiKeyIds: [ID!]

  """Filter by text (name, description, content of the contract)"""
  text: String

  """Fuzzy search by name by name of contact"""
  name: String

  """Fuzzy search file contents"""
  content: String
}

"""The order for a Contract query"""
input ContractOrder {
  """The field that the Contract nodes should be ordered by"""
  field: ContractOrderField!

  """
  The direction in which to order the Contract nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a contract"""
type ContractPreview {
  """The id of the contract"""
  id: ID!

  """The title of the contract"""
  name: String!

  """The description of the contract"""
  description: String!

  """The date the contract was created"""
  createdAt: Date!

  """The date the contract was last updated"""
  updatedAt: Date!
}

type ContractsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Contract"""
  nodes: [Contract!]!

  """int"""
  totalCount: Int!
}

"""An instance of scanning a group of contracts"""
type ContractScan {
  """The id of the contract scan"""
  id: ID!

  """The name of the contract scan"""
  name: String!

  """The date the contract scan was created"""
  createdAt: Date!

  """The date the contract scan was last updated"""
  updatedAt: Date!

  """The status of the contract scan"""
  status: ContractScanStatus!

  """The user who created this contract scan"""
  user: UserPreview

  """The total number of contracts in this contract scan"""
  contractCount: Int!

  """
  The total number of prompt runs that are created for this contract scan
  """
  createdPromptRunCount: Int!

  """The prompts that were applied in this contract scan"""
  prompts: [PromptPreview!]!

  """The contracts that were scanned in this contract scan"""
  contracts: [ContractPreview!]!

  """
  The total number of prompt runs that ran successfully for this contract scan
  """
  completedPromptRunCount: Int!

  """
  Indicator of whether this contract scan encountered errors while running prompts
  """
  errorPromptRunCount: Int!
}

"""Inputs for filtering contract scans"""
input ContractScanFiltersInput {
  """The ids of the contract scans"""
  ids: [ID!]

  """The statuses of the contract scans"""
  statuses: [ContractScanStatus!]

  """The ids of the users who created the contracts can"""
  userIds: [ID!]

  """The ids of the contracts that were scanned"""
  contractIds: [ID!]

  """The ids of the prompts that were applied"""
  promptIds: [ID!]

  """Filter by name of contract scan"""
  text: String
}

"""The order for a ContractScan query"""
input ContractScanOrder {
  """The field that the ContractScan nodes should be ordered by"""
  field: ContractScanOrderField!

  """
  The direction in which to order the ContractScan nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a contract scan"""
type ContractScanPreview {
  """The id of the contract scan"""
  id: ID!

  """The name of the contract scan"""
  name: String!

  """The date the contract scan was created"""
  createdAt: Date!

  """The date the contract scan was last updated"""
  updatedAt: Date!
}

type ContractScansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ContractScan"""
  nodes: [ContractScan!]!

  """int"""
  totalCount: Int!
}

"""An Airgap cookie config"""
type Cookie {
  """The ID of this cookie"""
  id: ID!

  """The description for this cookie"""
  description: String

  """Name or regex matching the name of this cookie"""
  name: String!

  """The tracking purposes that apply to this cookie"""
  trackingPurposes: [String!]!

  """A list of tracking purposes associated with this cookie"""
  purposes: [TrackingPurpose!]!

  """The aggregated relative frequency of this cookie"""
  frequency: Float!

  """The SaaS tool associated with these cookies"""
  service: Catalog

  """Whether Airgap should ignore this cookie"""
  isJunk: Boolean!

  """Whether this cookie name is a regex"""
  isRegex: Boolean!

  """The source of this cookie, (scanned or manually entered)"""
  source: ConsentTrackerSource!

  """The status of this cookie"""
  status: ConsentTrackerStatus!

  """The time the cookie was created"""
  createdAt: Date!

  """The time the cookie was last updated"""
  updatedAt: Date!

  """List of places this cookie was encountered"""
  encounters: [String!]

  """The last time this particular cookie was encountered"""
  lastDiscoveredAt: Date

  """List of domains associated with this cookie"""
  domains: [CookieDomain!]!

  """The attribute values used to label this cookie"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this cookie
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this cookie"""
  teams: [TeamPreview!]!

  """Whether or not this cookie has a pending telemetry metadata sync"""
  pendingTelemetryMetadataSync: Boolean!

  """The number of times this cookie has been seen"""
  occurrences: Float!

  """
  The number of milliseconds after which the cookie is expired by the browser
  """
  maxAge: Float
}

"""A domain associated with an Airgap cookie"""
type CookieDomain {
  """The ID of this cookie domain"""
  id: ID!

  """The domain value"""
  domain: String!

  """The last time this particular cookie was encountered"""
  lastDiscoveredAt: Date

  """The number of occurrences for this cookie-host pair"""
  occurrences: Int!
}

"""The order for a Cookie query"""
input CookieOrder {
  """The field that the Cookie nodes should be ordered by"""
  field: CookieOrderField!

  """
  The direction in which to order the Cookie nodes by the specified field
  """
  direction: OrderDirection!
}

type CookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Cookie"""
  nodes: [Cookie!]!

  """int"""
  totalCount: Int!
}

"""Filters that can be applied when querying for cookies"""
input CookiesFiltersInput {
  """Filter for cookies that have a certain tracking purposes"""
  trackingPurposes: [String!]

  """Filter for cookies of a certain purpose"""
  purposeIds: [ID!]

  """Filter cookies by text"""
  text: String

  """
  Filter for cookies marked as "junk"
  """
  isJunk: Boolean

  """Filter for cookies by their source"""
  source: ConsentTrackerSource

  """Filter for a cookie's status"""
  status: ConsentTrackerStatus

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """Filter by the attribute values used to label the cookies"""
  attributeValueIds: [ID!]

  """Filter for cookies by their associated service"""
  service: String

  """Filter for regex cookie matchers (or an exact name match)"""
  isRegex: Boolean

  """
  Whether or not to show cookies with zero activity in the past 1 day. Defaults to false.
  """
  showZeroActivity: Boolean

  """Filter for cookies by when they were created"""
  createdAt: String

  """Filter for cookies by when they were last encountered"""
  lastDiscoveredAt: String

  """Filter for cookies by the urls they have been encountered at"""
  encounters: String

  """Filter for cookies by the domains associated with a cookie"""
  domains: String

  """
  Filter for cookies with a minimum number of times the cookie has been seen
  """
  minOccurrences: Int

  """Filter for cookies that match a real cookie name"""
  matchesCookie: String
}

type CookieStatsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  liveCount: Int!

  """int"""
  needReviewCount: Int!

  """int"""
  junkCount: Int!

  """float"""
  liveActivity: Float!

  """float"""
  needReviewActivity: Float!

  """float"""
  junkActivity: Float!
}

"""Suggestions for certain cookie fields based on user inputted name"""
type CookieSuggestion {
  """Name or regex matching the name of this cookie"""
  name: String!

  """The suggestion of whether this cookie name is a regex"""
  isRegex: Boolean!

  """
  The suggested tracking purposes for this cookie based on name classification
  """
  purposes: [TrackingPurpose!]!

  """The suggested SaaS tool for this cookie based on name classification"""
  service: Catalog

  """The suggested description for this cookie"""
  description: String
}

"""Information about a cookie for the public Tracking Technology page"""
type CookieSummary {
  """Name or regex matching the name of this cookie"""
  name: String!

  """The tracking purposes that apply to this cookie"""
  trackingPurposes: [String!]!

  """
  The number of milliseconds after which the cookie is expired by the browser
  """
  maxAge: Float
}

type CreateActionItemCollectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A collection of action items"""
  created: GlobalActionItemCollection!
}

"""Input needed to create or update action item collections"""
input CreateActionItemCollectionInput {
  """The title of the action item collection"""
  title: String!

  """The description of the action item collection"""
  description: String!

  """The hidden state of the action item collection"""
  hidden: Boolean!

  """The product line that the action item collection relates to"""
  productLine: TranscendProduct!
}

type CreateActionItemsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for bulk creating one or more action items"""
input CreateActionItemsInput {
  """The title of this action item"""
  title: String!

  """The type of this action item"""
  type: ActionItemCode!

  """The idemId for this action item"""
  itemId: String

  """The priority override for this action item"""
  priorityOverride: ActionItemPriorityOverride

  """Is this action item resolved?"""
  resolved: Boolean

  """The ids of the teams assigned to this action item"""
  assigneesTeamIds: [ID!]

  """The names of the teams that should be responsible for this action item"""
  assigneesTeamNames: [String!]

  """The unique ids of the users to assign to this action item"""
  assigneesUserIds: [ID!]

  """
  The emails of the users to assign to this action item. These emails must have matching users on Transcend.
  """
  assigneesUserEmails: [String!]

  """The list of collections to add this action item to"""
  collectionIds: [ID!]

  """The date this action item is due"""
  dueDate: Date

  """The user specified notes about the action item"""
  notes: String

  """The user specified link for the action item"""
  link: String

  """
  The id of the customer experience action item, used for syncing of onboarding checklists
  """
  customerExperienceActionItemId: String
}

type CreateActionItemSubscriptionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ActionItemSubscription"""
  actionItemSubscriptions: [ActionItemSubscription!]!
}

"""Input for creating user or org level actionItemSubscriptions"""
input CreateActionItemSubscriptionsInput {
  """Whether the subscriptions in this input are org level or user level"""
  orgLevelSubscriptions: Boolean

  """Subscriptions to create"""
  subscriptions: [ActionItemSubscriptionInput!]!
}

type CreateAgentPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An LLM-based agent, capable of performing tasks autonomously"""
  agent: Agent!
}

type CreateAgentFilePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A legal agentFile"""
  agentFile: AgentFile!
}

"""Input for creating an agent file"""
input CreateAgentFileInput {
  """The name of the agent file"""
  name: String!

  """The description of the agent file"""
  description: String

  """Date that the file was uploaded to the remote system"""
  fileUploadedAt: Date!

  """ID of the file in remote system"""
  fileId: String!

  """
  The name of the initial file, when this file is a chunk of another file
  """
  initialFileName: String

  """Size of the file in bytes"""
  size: Int!

  """Purpose of the file"""
  purpose: PromptFilePurpose!

  """The ids of the agents that have access to the file"""
  agentIds: [ID!]

  """The names of the agents that have access to the file"""
  agentNames: [String!]

  """The remote ids of the agents that have access to the file"""
  agentRemoteIds: [String!]

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The email address of employee that ran the prompt"""
  runByEmployeeEmail: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String
}

type CreateAgentFunctionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A legal agentFunction"""
  agentFunction: AgentFunction!
}

"""Input for creating an agent function"""
input CreateAgentFunctionInput {
  """The name of the agent function"""
  name: String!

  """The description of the agent function"""
  description: String

  """The JSON schema definition of the function parameters"""
  parameters: String!

  """The ids of the agents that have access to the function"""
  agentIds: [ID!]

  """The names of the agents that have access to the function"""
  agentNames: [String!]

  """The remote ids of the agents that have access to the function"""
  agentRemoteIds: [String!]
}

"""Input for creating an agent"""
input CreateAgentInput {
  """The name of the agent"""
  name: String!

  """The ID of the agent in the remote system"""
  agentId: String!

  """The instructions of the agent"""
  instructions: String!

  """The description of the agent"""
  description: String

  """Whether agent has code interpreter enabled"""
  codeInterpreterEnabled: Boolean!

  """Whether agent has code retrieval enabled"""
  retrievalEnabled: Boolean!

  """
  The ID of the prompt to use for this agent. This or promptTitle must be specified.
  """
  promptId: ID

  """
  The title of the prompt to use for this agent. This or promptId must be specified.
  """
  promptTitle: String

  """
  The ID of the large language model to use for this agent. This or largeLanguageModelName & largeLanguageModelVersion must be specified.
  """
  largeLanguageModelId: ID

  """The name of the large language model that the agent is based on"""
  largeLanguageModelName: String

  """The client of the large language model that the agent is based on"""
  largeLanguageModelClient: LargeLanguageModelClient

  """The unique ids of the users to assign as owners of this agent"""
  ownerIds: [ID!]

  """The emails of user that manage the agent"""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this agent"""
  teamIds: [ID!]

  """The names of the teams that maintain the agent"""
  teamNames: [String!]

  """The IDs of the files to assign to this agent"""
  fileIds: [String!]

  """The unique ids of the files to assign to this agent"""
  agentFileIds: [ID!]

  """The unique ids of the functions to assign to this agent"""
  agentFunctionIds: [ID!]

  """The agent function definitions for the agent"""
  agentFunctions: [AgentFunctionInput!]

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The email address of employee that ran the prompt"""
  runByEmployeeEmail: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String
}

type CreateApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A newly created api key that exposes the key for one time only"""
  apiKey: CreatedApiKey!
}

type CreateApplicationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A service or application that executes some code - typically tracked for the purposes of AI governance
  """
  application: Application!
}

"""Input for creating a application"""
input CreateApplicationInput {
  """The name of the application"""
  name: String!

  """The description of the application"""
  description: String

  """The IDs of owners that maintain the application"""
  ownerIds: [ID!]

  """The emails of owners that maintain the application"""
  ownerEmails: [String!]

  """The IDs of owners that maintain the application"""
  teamIds: [ID!]

  """The names of team that maintain the application"""
  teamNames: [String!]

  """The IDs of pathfinder instances that the application has access to"""
  pathfinderIds: [ID!]

  """
  The names of the pathfinder instances that the application has access to
  """
  pathfinderNames: [String!]

  """The IDs of prompts that the application is calling"""
  promptIds: [ID!]

  """The titles of prompts that the application is calling"""
  promptTitles: [String!]

  """The IDs of agents that the application has been seen interacting with"""
  agentIds: [ID!]

  """
  The names of agents that the application has been seen interacting with
  """
  agentNames: [String!]

  """
  The remote IDs of agents that the application has been seen interacting with
  """
  agentRemoteIds: [String!]
}

type CreateAssessmentEmailSetPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An assessment email set"""
  assessmentEmailSet: AssessmentEmailSet!
}

"""Input for creating an assessment email set"""
input CreateAssessmentEmailSetInput {
  """The title of the assessment email set"""
  title: String!

  """The description of the assessment email set"""
  description: String

  """The ids of the templates to associate with the email set"""
  templateIds: [ID!]
}

"""Input for creating an assessment form comment"""
input CreateAssessmentFormCommentInput {
  """The content of the assessment form comment"""
  content: String!

  """The ID of the form that the comment refers to"""
  assessmentFormId: ID!

  """Update the status while adding the comment"""
  formStatus: AssessmentFormStatus

  """The ID of the event that the comment refers to"""
  assessmentEventId: ID
}

type CreateAssessmentFormCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormComment"""
  assessmentFormComments: [AssessmentFormComment!]!
}

"""Input for bulk creating assessment form comments"""
input CreateAssessmentFormCommentsInput {
  """The list of assessment form comments to create"""
  assessmentFormComments: [CreateAssessmentFormCommentInput!]!
}

"""Input for creating an assessment form"""
input CreateAssessmentFormInput {
  """The id of the group this assessment form belongs to"""
  assessmentGroupId: ID!

  """The internal label of the assessment form"""
  title: String

  """The IDs of the users assigned to fill out this assessmentForm"""
  assigneeIds: [ID!]

  """
  The emails of the external users assigned to review this assessmentForm
  """
  externalAssigneeEmails: [String!]

  """A list of internal and external users to assign to the form sections."""
  sectionAssignees: [AssessmentFormSectionAssigneesInput!]

  """The rows to sync assessment answers back to"""
  syncRows: [AssessmentFormSyncRowsInput!]

  """
  Whether the form title is an internal label only, and the group title should be used in communications with assignees
  """
  titleIsInternal: Boolean

  """
  The configurations for the form's triggers. If omitted, the triggers are not copied from the parent template!
  """
  triggerConfigurations: [AssessmentFormTriggerInput!]

  """Whether to enable the triggers copied from the parent template"""
  isTriggerEnabled: Boolean
}

type CreateAssessmentFormsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormRaw"""
  assessmentForms: [AssessmentFormRaw!]!
}

"""Input for creating multiple assessment forms"""
input CreateAssessmentFormsInput {
  """The assessment forms to create"""
  assessmentForms: [CreateAssessmentFormInput!]!
}

type CreateAssessmentFormTemplatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A template for creating assessment forms with questions and answers."""
  assessmentFormTemplate: AssessmentFormTemplateRaw!
}

"""Input for creating an Assessment Form Template"""
input CreateAssessmentFormTemplateInput {
  """The title of the Assessment Form Template"""
  title: String!

  """The description of the Assessment Form Template"""
  description: String

  """The status of the Assessment Form Template"""
  status: AssessmentFormTemplateStatus

  """The sections belonging to this template"""
  sections: [AssessmentSectionInput!]

  """
  The id of the parent Assessment Form Template if creating from an existing template
  """
  parentId: ID

  """The method by which the assessment form template was created"""
  source: AssessmentFormTemplateSource

  """The retention schedule for the Assessment Form Template"""
  retentionSchedule: CreateAssessmentFormTemplateRetentionScheduleInput

  """The email template set used for notifications"""
  assessmentEmailSetId: ID

  """The trigger configurations of the template"""
  triggers: [AssessmentTriggerInput!]
}

"""
Input for creating the retention schedule for an assessment form template
"""
input CreateAssessmentFormTemplateRetentionScheduleInput {
  """The duration of the retention schedule in days"""
  durationDays: Int

  """The operation to perform on the retention schedule"""
  operation: RetentionScheduleOperation
}

type CreateAssessmentFormTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment form that can be filled out by users"""
  assessmentForm: AssessmentFormRaw!
}

"""
Input that external users can creating an assessment form with an auth token.
"""
input CreateAssessmentFormTokenInput {
  """The internal label of the assessment form."""
  title: String

  """The email of the external user creating the form."""
  email: String!

  """The token to validate"""
  token: String!

  """
  Whether to force allowing multiple assessments for the same email address.
  """
  forceSend: Boolean
}

type CreateAssessmentGroupPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Group of assessment forms"""
  assessmentGroup: AssessmentGroup!
}

"""Input for creating an assessment group"""
input CreateAssessmentGroupInput {
  """The title of the assessment group"""
  title: String!

  """The description of the assessment group"""
  description: String

  """The template that all forms created within this group will use"""
  assessmentFormTemplateId: ID!

  """Whether to enable the form triggers by default"""
  isTriggerEnabled: Boolean
}

"""Input for creating an assessment question comment"""
input CreateAssessmentQuestionCommentInput {
  """The content of the assessment question"""
  content: String!

  """The ID of the question that the comment refers to"""
  assessmentQuestionId: ID!
}

type CreateAssessmentQuestionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionComment"""
  assessmentQuestionComments: [AssessmentQuestionComment!]!
}

"""Input for bulk creating assessment question comments"""
input CreateAssessmentQuestionCommentsInput {
  """The list of assessment question comments to create"""
  assessmentQuestionComments: [CreateAssessmentQuestionCommentInput!]!
}

"""Input for creating an assessment question"""
input CreateAssessmentQuestionInput {
  """The title of the assessment question"""
  title: String!

  """The type of the assessment question"""
  type: AssessmentQuestionType!

  """The sub-type of the assessment question"""
  subType: AssessmentQuestionSubType

  """The placeholder of the assessment question"""
  placeholder: String

  """The description of the assessment question"""
  description: String

  """Whether the assessment question is required"""
  isRequired: Boolean

  """
  The logic for determining whether this question should show in the assessment form
  """
  displayLogic: DisplayLogicInput

  """The logic for determining the risk score for the assessment question"""
  riskLogic: [RiskLogicInput!]

  """The IDs of the risk categories the risk score applies to"""
  riskCategoryIds: [ID!]

  """The ID of the risk framework the risk score applies to"""
  riskFrameworkId: ID

  """The possible answer options to this question"""
  answerOptions: [AssessmentAnswerOptionInput!]

  """The mime types allowed for the file question"""
  allowedMimeTypes: [String!]

  """
  Used to identify the question within a form or template so it can be referenced in conditional logic.
  """
  referenceId: String!

  """Whether the question allows selecting Other"""
  allowSelectOther: Boolean

  """The data inventory model that this assessment question syncs to"""
  syncModel: AssessmentSyncModel

  """
  The column of the data inventory that this assessment question syncs to
  """
  syncColumn: AssessmentSyncColumn

  """The ID of the attributeKey used to respond this question."""
  attributeKeyId: ID

  """The ID of the assessment section under which to add this question"""
  assessmentSectionId: ID!
}

type CreateAssessmentQuestionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionRaw"""
  assessmentQuestions: [AssessmentQuestionRaw!]!
}

type CreateAssessmentSectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment section that belongs to a template or a form"""
  assessmentSection: AssessmentSectionRaw!
}

"""Input for creating an assessment section comment"""
input CreateAssessmentSectionCommentInput {
  """The content of the assessment section"""
  content: String!

  """The ID of the section that the comment refers to"""
  assessmentSectionId: ID!
}

type CreateAssessmentSectionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentSectionComment"""
  assessmentSectionComments: [AssessmentSectionComment!]!
}

"""Input for bulk creating assessment section comments"""
input CreateAssessmentSectionCommentsInput {
  """The list of assessment section comments to create"""
  assessmentSectionComments: [CreateAssessmentSectionCommentInput!]!
}

"""Input for creating an assessment section"""
input CreateAssessmentSectionInput {
  """The title of the assessment section"""
  title: String!

  """The ID of the assessment form template under which to add this section"""
  assessmentFormTemplateId: ID!

  """The questions belonging to this group"""
  questions: [AssessmentQuestionInput!]
}

type CreateAttributeKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An attribute key to house attribute values"""
  attributeKey: AttributeKey!
}

"""Input for creating a new attribute key"""
input CreateAttributeKeyInput {
  """Name of the attributeKey"""
  name: String!

  """Description of the attribute key"""
  description: String

  """The views this attribute key is enabled on"""
  enabledOn: [AttributeSupportedResourceType!]

  """The type of this attribute key"""
  type: AttributeKeyType!

  """
  The associated assessment form template for this attribute key, if it is of type "Assessment"
  """
  assessmentFormTemplateId: ID
}

type CreateAttributeValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AttributeValue"""
  attributeValues: [AttributeValue!]!
}

"""Input for creating attribute values"""
input CreateAttributeValuesInput {
  """Name of the attribute value"""
  name: String!

  """The description for the attribute value"""
  description: String

  """The attribute key the attribute value belongs to"""
  attributeKeyId: ID!

  """The color label for the attribute value"""
  color: String

  """Whether attribute value can be deleted"""
  canDelete: Boolean
}

type CreateAuditorSchedulePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A schedule for running the Web Auditor repeatedly over time on the same URL
  """
  results: AuditorSchedule!
}

type CreateBusinessEntityPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A business entity is an affiliate organization or organization unit within a company.
  """
  businessEntity: BusinessEntity!
}

"""Input for creating a business entity"""
input CreateBusinessEntityInput {
  """The title of the business entity"""
  title: String!

  """The description of the business entity"""
  description: String

  """Address of entity"""
  address: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String

  """The attribute values used to label this business entity"""
  attributes: [AttributeInput!]

  """
  The ids of the teams that should be responsible for this business entity
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this business entity
  """
  teamNames: [String!]

  """
  The unique ids of the users to assign as owners of this business entity
  """
  ownerIds: [ID!]

  """
  The email addresses of the users to assign as owners of this business entity
  """
  ownerEmails: [String!]
}

type CreateCodePackagePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A code package that contains code submitted to a particular repository"""
  codePackage: CodePackage!
}

"""Input for creating a code package"""
input CreateCodePackageInput {
  """The name of the code package"""
  name: String!

  """The description of the code package"""
  description: String

  """The type of code package"""
  type: CodePackageType!

  """Relative path to where the code package lives within the repository"""
  relativePath: String!

  """The ID of the repository that code package resides in"""
  repositoryId: ID

  """The name of the repository that code package resides in"""
  repositoryName: String

  """
  The ids of the software development kits that the code packages are related to
  """
  softwareDevelopmentKitIds: [ID!]

  """The IDs of owners that maintain the code package"""
  ownerIds: [ID!]

  """The emails of owners that maintain the code package"""
  ownerEmails: [String!]

  """The IDs of owners that maintain the code package"""
  teamIds: [ID!]

  """The names of team that maintain the code package"""
  teamNames: [String!]
}

type CreateConsentManagerPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""The input for creating a new consent manager (aka Airgap)."""
input CreateConsentManagerInput {
  """
  The name of this Consent Manager bundle. Defaults to the organization uri.
  """
  name: String

  """The ID of the associated privacy center"""
  privacyCenterId: ID!

  """
  True means your consent manager will only report telemetry data and does not regulate requests. Defaults to true.
  """
  off: Boolean

  """The configuration for this Consent Manager."""
  configuration: ConsentManagerBundleConfigInput

  """
  The URL to send POST request notifications to whenever a deployment occurs
  """
  webhookUrl: String

  """Custom headers to include in outbound deployment webhook"""
  headers: [CustomHeaderInput!]
}

type CreateConsentManagerUiPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A consent manager UI"""
  ui: ConsentManagerUI!
}

"""Input used to create a new record for a custom UI module for Airgap"""
input CreateConsentManagerUIInput {
  """The slug for this UI script"""
  name: String!

  """location for UI script"""
  scriptLocation: String!
}

type CreateConsentPartitionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The partition (namespace) for storing consent data"""
  consentPartition: ConsentPartition!
}

"""Input for creating a new consent partition"""
input CreateConsentPartitionInput {
  """The ID of the airgap bundle"""
  id: ID!

  """Human-readable name of this consent partition"""
  name: String!
}

type CreateContractPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A legal contract"""
  contract: Contract!
}

"""Input for creating a contract"""
input CreateContractInput {
  """The name of the contract"""
  name: String!

  """The description of the contract"""
  description: String

  """The content of the contract"""
  content: String!
}

type CreateContractScanPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An instance of scanning a group of contracts"""
  contractScan: ContractScan!
}

"""Input for creating a contract scan"""
input CreateContractScanInput {
  """The name of the contract scan"""
  name: String!

  """The prompts that should be run over the contracts"""
  promptIds: [ID!]

  """The contracts that should be scanned"""
  contractIds: [ID!]
}

"""A newly created api key that exposes the key for one time only"""
type CreatedApiKey implements ApiKeyInterface {
  """The plain text api key"""
  apiKey: String!

  """The unique id of the api key"""
  id: ID!

  """The title of the api key"""
  title: String!

  """The api key preview"""
  preview: String!

  """The time the api key was created"""
  createdAt: Date!

  """The time the api key was last used"""
  lastUsedAt: Date

  """The age of the api key in days"""
  age: Int!

  """The cycle status of the api key (for indicating need to refresh)"""
  status: ApiKeyStatus!

  """The user that created the API key"""
  user: UserPreview

  """The scopes associated with the api key"""
  scopes: [ScopePreview!]!

  """The data silos connected to the API Key"""
  dataSilos: [Resource!]!
}

type CreateDataCollectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A collection of data that the organization holds"""
  dataCollection: DataCollection!
}

type CreateDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataFlow"""
  dataFlows: [DataFlow!]!
}

"""Input to create new data flow entries"""
input CreateDataFlowInput {
  """The airgap bundle to create the data flows for"""
  airgapBundleId: ID!

  """The data flow entries to create"""
  dataFlows: [DataFlowInput!]!

  """
  Whether or not to drop matching data flows in triage if it is covered by any of the data flows being added. Defaults to false.
  """
  dropMatchingDataFlowsInTriage: Boolean

  """Invoke service classifier if integration unknown"""
  classifyService: Boolean
}

"""Input for creating a new data processing subcategory"""
input CreateDataInventorySubCategoryInput {
  """The name of the subcategory"""
  name: String!

  """The category of personal data subcategory is nested in"""
  category: DataCategoryType!

  """Description of category"""
  description: String

  """
  The unique ids of the users to assign as owners of this data sub category
  """
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this data sub category"""
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this data sub category
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this data sub category
  """
  teamNames: [String!]

  """The identifier that is linked to this data category"""
  identifierId: ID

  """The name of the identifier that is linked to this data category"""
  identifierName: String

  """The attribute values used to label this data sub category"""
  attributes: [AttributeInput!]

  """The sensitive categories that are related to this data category"""
  sensitiveCategoryIds: [ID!]
}

type CreateDataReportPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An exportable data inventory report"""
  dataReport: DataReportRaw!
}

"""Input for creating a data report"""
input CreateDataReportInput {
  """The title of the data report"""
  title: String!

  """The names of the tables included in this data report"""
  tables: [DataReportExportableTables!]!

  """The filters the user applied to each table in the report"""
  filters: DataReportFilterInput!

  """The columns that the user hid from each table in the report"""
  hiddenColumns: DataReportHiddenColumnsInput!

  """The ID of the user who created this report"""
  creatorId: ID!
}

type CreateDataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSilo"""
  dataSilos: [DataSilo!]!
}

"""Input for creating data silos without any connection details"""
input CreateDataSilosInput {
  """
  The integration name (has to match the integrationName as it appears in our catalog)
  """
  name: String!

  """The ID of the plugin that found this recommendation"""
  pluginId: ID

  """The unique identifier for the resource"""
  resourceId: String

  """The AWS Region for data silo if applicable"""
  region: String

  """The ISO country code for the AWS Region if applicable"""
  country: String

  """The ISO country subdivision code for the AWS Region if applicable"""
  countrySubDivision: String

  """
  Countries and country subdivisions to which this data silo transfers data
  """
  transferRegions: [RegionInput!]

  """The IDs of SaaS categories to assign to this data silo"""
  saaSCategoryIds: [ID!]

  """The custom title of the data silo recommendation."""
  title: String

  """The custom description of the data silo."""
  description: String

  """The plaintext for the resource."""
  plaintextContext: String

  """Update the associated business entities for the data silo"""
  businessEntityIds: [ID!]

  """Update the associated business entity titles for the data silo"""
  businessEntityTitles: [String!]

  """The ID of the sombra to use for communication with this data silo"""
  sombraId: ID

  """The organization's controllership of the data silo"""
  controllerships: [Controllership!]

  """The plugin configurations for the recommendation"""
  pluginConfigurations: String
}

type CreateDataSubCategoryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Detailed info about a data processing subcategory"""
  dataSubCategory: DataSubCategory!
}

type CreateEmailSenderAddressPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Email addresses from which Transcend can send emails"""
  address: EmailSenderAddress!
}

"""Input to update email sender addresses"""
input CreateEmailSenderAddressInput {
  """The internal name of this email address"""
  name: String!

  """The priority of this email address"""
  priority: Int!

  """The customer domain name"""
  fromPrefix: String

  """The customer domain name"""
  replyTo: String

  """The customer domain name"""
  alias: String

  """The customer domain name"""
  displayName: String

  """The request attribute value ids corresponding to this email address"""
  attributeValues: [ID!]

  """The privacy centers to which this email address is assigned"""
  privacyCenters: [ID!]
}

type CreateEnricherPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An enricher is takes in an identifier, and resolves additional identifiers keyed to the input identifier.
  """
  enricher: Enricher!
}

type CreateExperiencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A set of transcend configurations for an organization defined set of regions
  """
  experience: Experience!
}

"""Input used to create a new experience for an organization"""
input CreateExperienceInput {
  """Name of the experience"""
  name: String!

  """Display name of the experience"""
  displayName: String

  """Regions to be included/not included in this experience"""
  regions: [RegionInput!]!

  """Whether listed regions are excluded or included in experience"""
  operator: RegionsOperator

  """
  If data subject linked to multiple experiences, display priority for experiences. Lower number, higher priority.
  """
  displayPriority: Int!

  """The view state to display on transcend.showConsentManager()"""
  viewState: InitialViewState!

  """The UI module to use (overrides View State if appropriate)"""
  ui: String

  """The purposes associated with this experience"""
  purposes: [ID!]!

  """
  The purposes associated with this experience that are default opted out
  """
  optedOutPurposes: [ID!]!

  """A list of browser languages that this experience applies to"""
  browserLanguages: [String!]

  """A list of browser time zones that this experience applies to"""
  browserTimeZones: [String!]

  """Set of iab signals to communicate"""
  iabSignals: [IABSignal!]

  """Number of months after which consent values will expire"""
  consentExpiry: Int

  """Action taken when the user's consent has expired"""
  onConsentExpiry: OnConsentExpiry

  """Whether the regional experience is active for an organization"""
  isActive: Boolean
}

type CreateIdentifierPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  The internal configuration of the identifier, view from the identifier's perspective on the /settings page.
  """
  identifier: Identifier!
}

"""Create a new legal hold"""
input CreateLegalHoldInput {
  """The legal holds to create"""
  legalHolds: [LegalHoldInput!]!
}

type CreateLegalHoldsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LegalHold"""
  legalHolds: [LegalHold!]!
}

type CreateLegalMatterPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An individual on a legal matter"""
  legalMatter: LegalMatter!
}

"""Create a new legal matter"""
input CreateLegalMatterInput {
  """The title of the legal matter"""
  title: String!

  """The description of the legal matter"""
  description: String!
}

type CreateOnPremiseSombraPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The sombra configuration"""
  sombra: Sombra!
}

"""Input for creating a new consent application"""
input CreateOrUpdateConsentApplicationInput {
  """The list of consent applications to create or update"""
  consentApplications: [ConsentApplicationUpsertInput!]!
}

type CreateOrUpdateConsentApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentApplication"""
  nodes: [ConsentApplication!]!
}

"""Input for creating a new consent SDKs"""
input CreateOrUpdateConsentSdkInput {
  """ID of the airgap bundle this SDK belongs to"""
  airgapBundleId: ID!

  """The list of consent SDKs to create or update"""
  consentSdks: [ConsentSdkUpsertInput!]!
}

type CreateOrUpdateConsentSdksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentSdk"""
  nodes: [ConsentSdk!]!
}

type CreateOrUpdateConsentServicesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentService"""
  nodes: [ConsentService!]!
}

"""Input for creating or updating a list of consent services"""
input CreateOrUpdateConsentServicesInput {
  """ID of the airgap bundle that this consent service belongs to"""
  airgapBundleId: ID!

  """The list of consent services to create or update"""
  consentServices: [UpsertConsentServiceInput!]!
}

type CreateOrUpdateConsentSitePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Hosts found through telemetry or added by users"""
  consentHost: ConsentHost!
}

"""Data used to create or update a consent site record"""
input CreateOrUpdateConsentSiteInput {
  """The ID of this site"""
  id: ID

  """Filters based on the site"""
  site: String

  """Filters based on the host"""
  host: String

  """Optional free text notes field"""
  description: String

  """ID of the airgap bundle that this consent site belongs to"""
  airgapBundleId: ID!
}

type CreateOrUpdateConsentWorkflowTriggerPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The Consent Workflow Trigger"""
  consentWorkflowTrigger: ConsentWorkflowTrigger!
}

"""Input for updating a Consent Workflow Trigger"""
input CreateOrUpdateConsentWorkflowTriggerInput {
  """ID of the consent workflow trigger to update"""
  id: ID

  """The name of the consent workflow trigger"""
  name: String

  """The condition to trigger the consent workflow"""
  triggerCondition: String

  """The action associated to the consent workflow trigger"""
  actionId: ID

  """The data-subject associated to the consent workflow trigger"""
  dataSubjectId: ID

  """The set of data silos that are configured for this workflow"""
  dataSiloIds: [ID!]

  """
  The list of purposes(Tracking and Marketing purposes) associated with this Consent Workflow Trigger
  """
  consentWorkflowTriggerPurposes: [ConsentWorkflowTriggerPurposeInput!]

  """If a DSR is triggered, is it a silent request"""
  isSilent: Boolean

  """If workflow is allowed to be triggered for unauthenticated users"""
  allowUnauthenticated: Boolean

  """If the trigger is active"""
  isActive: Boolean
}

type CreateOrUpdateOrganizationPreferencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A preference for a user or organization"""
  preference: PreferenceRaw!
}

"""Input for creating or updating a preference"""
input CreateOrUpdatePreferenceInput {
  """The preferences for all tables"""
  tables: TablesPreferencesInput!
}

"""Input for creating or updating a single preference option value"""
input CreateOrUpdatePreferenceOptionValueInput {
  """The id of the preference option"""
  id: ID

  """The title of the preference option"""
  title: String!

  """The slug of the preference option"""
  slug: String
}

type CreateOrUpdatePreferenceOptionValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PreferenceOptionValue"""
  preferenceOptionValues: [PreferenceOptionValue!]!
}

"""Input for creating or updating multiple preference option values"""
input CreateOrUpdatePreferenceOptionValuesInput {
  """The preference option values to create or update"""
  preferenceOptionValues: [CreateOrUpdatePreferenceOptionValueInput!]!
}

type CreateOrUpdatePreferenceTopicPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Preference topic configuration on the Admin Dashboard."""
  preferenceTopic: PreferenceTopic!
}

"""Input for upserting a preference"""
input CreateOrUpdatePreferenceTopicInput {
  """The ID of the preference topic to upsert"""
  id: ID

  """The display name of this preference topic"""
  title: String

  """The slug of the preference topic"""
  slug: String

  """The type of preference topic"""
  type: PreferenceTopicType

  """preference topic description (used in preference Store UI) """
  displayDescription: String

  """Whether the preference topic should be shown in the privacy center"""
  showInPrivacyCenter: Boolean

  """
  The default configuration for this preference topic when the purpose is opted in or out
  """
  defaultConfiguration: String

  """The purpose this preference topic is associated with"""
  purposeId: ID

  """The options this preference topic is associated with"""
  preferenceOptionValueIds: [ID!]
}

type CreateOrUpdateUserPreferencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A preference for a user or organization"""
  preference: PreferenceRaw!
}

type CreatePathfinderPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A pathfinder service that has access to particular large language models
  """
  pathfinder: Pathfinder!
}

"""Input for creating a pathfinder"""
input CreatePathfinderInput {
  """The name of the pathfinder"""
  name: String!

  """The URL of the pathfinder"""
  url: String

  """The IDs of the applications that interact with the pathfinder service"""
  applicationIds: [ID!]

  """
  The names of the applications that interact with the pathfinder service
  """
  applicationNames: [String!]

  """
  The IDs of the pathfinder policies that should be applied to this pathfinder instance
  """
  pathfinderPolicyIds: [ID!]

  """
  The names of the pathfinder policies that should be applied to this pathfinder instance
  """
  pathfinderPolicyNames: [String!]

  """
  The IDs of the large language models that this pathfinder instance has access to
  """
  largeLanguageModelIds: [ID!]

  """The list of large language models to upsert for this pathfinder"""
  largeLanguageModelInputs: [LargeLanguageModelInput!]

  """The IDs of the agents that should be created for this pathfinder"""
  agentIds: [ID!]

  """The names of the agents that should be created for this pathfinder"""
  agentNames: [String!]

  """
  The remote IDs of the agents that should be created for this pathfinder
  """
  agentRemoteIds: [String!]
}

type CreatePathfinderPolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A policy that is applied to a pathfinder service"""
  pathfinderPolicy: PathfinderPolicy!
}

"""Input for creating a pathfinder policy"""
input CreatePathfinderPolicyInput {
  """The name of the pathfinder policy"""
  name: String!

  """The type of pathfinder policy"""
  type: PathfinderPolicyType!

  """The description of the pathfinder policy"""
  description: String

  """The ids of the data sub categories that the policy applies to"""
  dataSubCategoryIds: [ID!]

  """
  The data sub categories that the policy applies to, with the id and name
  """
  dataSubCategoryInputs: [DataSubCategoryInput!]

  """The response text of the pathfinder policy"""
  response: String

  """The ids of the pathfinders that the policy applies to"""
  pathfinderIds: [ID!]

  """The names of the pathfinders that the policy applies to"""
  pathfinderNames: [String!]
}

"""Create Privacy Center Access Token Input"""
input CreatePrivacyCenterAccessTokenInput {
  """The core identifier of the user"""
  coreIdentifier: String

  """The email of the user"""
  email: String!

  """The subject type of the user"""
  subjectType: String!

  """The scope associated with the token"""
  scopes: [SombraStandardScopes!]!

  """The expiration time of the token"""
  expiresIn: Int
}

type CreatePrivacyCenterAccessTokensPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PrivacyCenterAccessToken"""
  nodes: [PrivacyCenterAccessToken!]!
}

"""Create Privacy Center Access Tokens Input"""
input CreatePrivacyCenterAccessTokensInput {
  """The input records to create privacy center access tokens"""
  records: [CreatePrivacyCenterAccessTokenInput!]!
}

type CreateProcessingActivityPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A processing activity of the organization"""
  processingActivity: ProcessingActivity!
}

"""Input for creating a processing activity"""
input CreateProcessingActivityInput {
  """The title of the processing activity"""
  title: String!

  """The description of the processing activity"""
  description: String!
}

"""Input for creating a new Purpose of Processing subcategory"""
input CreateProcessingPurposeCategoryInput {
  """The name of the subcategory"""
  name: String!

  """The parent purpose of processing the subcategory is nested in"""
  purpose: ProcessingPurpose!

  """Description of the Purpose of Processing subcategory"""
  description: String

  """
  The unique ids of the users to assign as owners of this processing purpose
  """
  ownerIds: [ID!]

  """
  The email addresses of the users to assign as owners of this processing purpose
  """
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this processing purpose
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this processing purpose
  """
  teamNames: [String!]

  """The attribute values used to label this vendor"""
  attributes: [AttributeInput!]
}

type CreateProcessingPurposeSubCategoryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Details about a subcategory of a purpose of processing"""
  processingPurposeSubCategory: PurposeSubCategory!
}

type CreatePromptPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An HTML-based prompt for editable prompts with HTML content"""
  prompt: Prompt!
}

type CreatePromptGroupPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Group for a template that can be composed into a prompt"""
  promptGroup: PromptGroup!
}

"""Input for creating a prompt group"""
input CreatePromptGroupInput {
  """The new title of the prompt group"""
  title: String

  """The description of the prompt group """
  description: String

  """The ids of the prompt in the group"""
  promptIds: [ID!]

  """The titles of the prompts in the group"""
  promptTitles: [String!]

  """The unique ids of the users to assign as owners of this prompt group"""
  ownerIds: [ID!]

  """
  The unique emails of the users to assign as owners of this prompt group
  """
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this prompt group"""
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this prompt group
  """
  teamNames: [String!]
}

"""Input for creating an Prompt"""
input CreatePromptInput {
  """The title of the prompt"""
  title: String!

  """The content of the prompt"""
  content: String!

  """
  The expected mode in which response text is returned - commonly set to json_object to return JSON data
  """
  responseFormat: PromptResponseFormat

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """The status of the prompt"""
  status: PromptStatus

  """The ID of the user requesting this prompt"""
  reviewerId: ID

  """The email of the user requesting this prompt"""
  reviewerEmail: String

  """The unique ids of the users to assign as owners of this prompt"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this prompt"""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this prompt"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this prompt"""
  teamNames: [String!]

  """The ids of the large language models that work well with this prompt"""
  largeLanguageModelIds: [ID!]

  """
  The inputs of the large language models that work well with this prompt
  """
  largeLanguageModelInputs: [LargeLanguageModelInput!]

  """The ids of the prompt groups that this prompt should be a part of"""
  promptGroupIds: [ID!]

  """The titles of the prompt groups that this prompt should be a part of"""
  promptGroupTitles: [String!]
}

type CreatePromptPartialPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Partial for a template that can be composed into a prompt"""
  promptPartial: PromptPartial!
}

"""Input for creating a prompt partial"""
input CreatePromptPartialInput {
  """The title of the prompt partial"""
  title: String!

  """The content of the prompt partial"""
  content: String!

  """The unique ids of the users to assign as owners of this partial prompt"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this partial prompt"""
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this partial prompt
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this partial prompt
  """
  teamNames: [String!]
}

type CreatePromptThreadPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A thread that was contains context that a large language model will run against
  """
  promptThread: PromptThread!
}

"""Input for creating a prompt thread"""
input CreatePromptThreadInput {
  """The ID of the thread in the remote system"""
  threadId: String!

  """The ts of the slack message is the thread is a slack conversation"""
  slackMessageTs: String

  """The ID of the slack team if the thread is a slack conversation"""
  slackTeamId: String

  """The ID of the slack channel if the thread is a slack conversation"""
  slackChannelId: String

  """The name of the slack channel if the thread is a slack conversation"""
  slackChannelName: String

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The email address of employee that ran the prompt"""
  runByEmployeeEmail: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String
}

type CreatePullRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A pull request that contains code submitted to a particular repository"""
  pullRequest: PullRequest!
}

"""Input for creating a pull request"""
input CreatePullRequestInput {
  """The title of the pull request"""
  title: String!

  """The description of the pull request"""
  description: String

  """The URL of the pull request"""
  url: String!

  """The ID of the pull request in the remote tool"""
  remoteId: String!

  """The ID of the repository that the pull request is for"""
  repositoryId: ID

  """The name of the repository"""
  repositoryName: String

  """The IDs of users that made the pull request"""
  userIds: [ID!]

  """The emails of users that made the pull request"""
  userEmails: [String!]
}

type CreatePurposePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A tracking purpose"""
  purpose: TrackingPurpose!
}

"""Input used to create a new consent purpose for an organization"""
input CreatePurposeInput {
  """The display name of this tracking purpose"""
  name: String!

  """Tracking purpose description (used in Consent Manager UI) """
  description: String!

  """The tracking purpose type associated with the site."""
  trackingType: String!

  """Privacy signals that should opt the user out of this tracking purpose"""
  optOutSignals: [UserPrivacySignalEnum!]

  """Whether this purpose should be shown in the Consent Manager UI"""
  showInConsentManager: Boolean

  """
  The order in which the purpose is displayed compared to other purposes in the list
  """
  displayOrder: Int

  """Whether this purpose should be configurable by the user """
  configurable: Boolean

  """Whether the purpose is active for an organization"""
  isActive: Boolean

  """
  The authentication level require by user to update the marketing purpose
  """
  authLevel: PreferenceStoreAuthLevel

  """
  Whether this purpose should be shown in the communication preferences page of the privacy center
  """
  showInPrivacyCenter: Boolean
}

type CreateRepositoryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A repository where code is stored"""
  repository: Repository!
}

"""Input for creating a repository"""
input CreateRepositoryInput {
  """The name of the repository"""
  name: String!

  """The description of the repository"""
  description: String

  """The URL of the repository"""
  url: String!

  """The unique ids of the users to assign as owners of this repository"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this repository."""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this repository"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this repository"""
  teamNames: [String!]
}

"""Create a retention schedule policy"""
input CreateRetentionScheduleInput {
  """The duration of the retention schedule in days"""
  durationDays: Int!

  """The operation to perform on the retention schedule"""
  operation: RetentionScheduleOperation!

  """The type of the retention schedule"""
  type: RetentionScheduleType!
}

type CreateRiskCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskCategory"""
  riskCategories: [RiskCategory!]!
}

"""Input for creating multiple risk categories"""
input CreateRiskCategoriesInput {
  """The id of the risk framework to create the risk categories in"""
  riskFrameworkId: ID!

  """The risk categories to create."""
  riskCategories: [CreateRiskCategoryInput!]!
}

"""Input for creating a risk category"""
input CreateRiskCategoryInput {
  """The display name of the risk category"""
  title: String!

  """A description of what kinds of risk this risk category represents"""
  description: String
}

"""Input for creating a risk framework"""
input CreateRiskFrameworkInput {
  """The display name of the risk framework"""
  title: String!

  """A description of what this risk framework represents"""
  description: String

  """
  The risk levels associated with this risk framework, sorted lowest to highest risk
  """
  riskLevels: [CreateRiskLevelInput!]!

  """The risk categories associated with this risk framework"""
  riskCategories: [CreateRiskCategoryInput!]!

  """
  The risk matrix columns associated with this risk framework, sorted lowest to highest
  """
  riskMatrixColumns: [CreateRiskMatrixColumnInput!]

  """
  The risk matrix rows associated with this risk framework, sorted lowest to highest
  """
  riskMatrixRows: [CreateRiskMatrixRowInput!]

  """
  The titles of risk levels that correspond to a particular risk matrix column and row combinationThe first index is the risk matrix row index, and the second index is the risk matrix column index.
  """
  riskMatrix: [[String!]!]

  """The title of the risk matrix columns in this framework"""
  riskMatrixRowTitle: String

  """The title of the risk matrix columns in this framework"""
  riskMatrixColumnTitle: String
}

type CreateRiskFrameworksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskFramework"""
  riskFrameworks: [RiskFramework!]!
}

"""Input for creating multiple risk frameworks"""
input CreateRiskFrameworksInput {
  """The risk frameworks to create."""
  riskFrameworks: [CreateRiskFrameworkInput!]!
}

"""Input for creating a risk level"""
input CreateRiskLevelInput {
  """The display name of the risk level"""
  title: String!

  """The color associated with risk level"""
  color: String!
}

"""Input for creating a risk matrix column"""
input CreateRiskMatrixColumnInput {
  """The display name of the risk matrix column"""
  title: String!
}

"""Input for creating a risk matrix row"""
input CreateRiskMatrixRowInput {
  """The display name of the risk matrix row"""
  title: String!
}

"""
Input for creating the sitescan results found by the sitescanner service
"""
input CreateScanCookiePurposesInput {
  """The url that the sitescan was run on"""
  url: String!

  """The organization that initiated the sitescan"""
  organizationId: ID!

  """The sitescan results found by the sitescanner"""
  results: [SitescannerCookieInput!]!
}

"""
Input for creating the sitescan results found by the sitescanner service
"""
input CreateScanDomainPurposesInput {
  """The url that the sitescan was run on"""
  url: String!

  """The organization that initiated the sitescan"""
  organizationId: ID!

  """The sitescan results found by the sitescanner"""
  results: [SitescannerResponseInput!]!
}

type CreateSensitiveCategoryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A sensitive category of the organization"""
  sensitiveCategory: SensitiveCategory!
}

"""Input for creating a sensitive category"""
input CreateSensitiveCategoryInput {
  """The title of the sensitive category"""
  title: String!

  """The color of the sensitive category"""
  color: String!

  """The description of the sensitive category"""
  description: String!
}

type CreateSoftwareDevelopmentKitPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A software development kit that contains code submitted to a particular repository
  """
  softwareDevelopmentKit: SoftwareDevelopmentKit!
}

"""Input for creating a software development kit"""
input CreateSoftwareDevelopmentKitInput {
  """The name of the software development kit"""
  name: String!

  """The description of the software development kit"""
  description: String

  """The type of dependency"""
  codePackageType: CodePackageType!

  """The URL of the software development kit"""
  repositoryUrl: String

  """The documentation links of the software development kit"""
  documentationLinks: [String!]

  """
  The IDs of the code packages that the software development kit is used on
  """
  codePackageIds: [ID!]

  """
  The name of the integration in the catalog that the software development kit relates to
  """
  catalogIntegrationName: String

  """
  The names of the code packages that the software development kit is used on
  """
  codePackageNames: [String!]

  """The IDs of users that manage the software development kit"""
  ownerIds: [ID!]

  """The emails of users that manage the software development kit"""
  ownerEmails: [String!]

  """The IDs of teams that manage the software development kit"""
  teamIds: [ID!]

  """The names of teams that manage the software development kit"""
  teamNames: [String!]
}

type CreateSubDataPointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A property of a datapoint, corresponding to a single piece of personal data
  """
  subDataPoint: SubDataPoint!
}

"""Input for creating a single subdatapoint"""
input CreateSubDataPointInput {
  """The name of the subdatapoint"""
  name: String!

  """A description for the subdatapoint"""
  description: String

  """The ID of the datapoint to associate with this subDataPoint"""
  dataPointId: ID!

  """The IDs of the subcategories to associate with this subdatapoint"""
  dataSubCategories: [ID!]!

  """The IDs of the sub-purposes to associate with this subdatapoint"""
  processingPurposeSubCategories: [ID!]!

  """
          When true, this subdatapoint should be revealed in a data access request.
  When false, this field should be redacted.
  """
  accessRequestVisibilityEnabled: Boolean

  """
          When true, this subdatapoint should be redacted during an erasure request.
  There normally is a choice of enabling hard deletion or redaction at the
  datapoint level, but if redaction is enabled, this column can be used
  to define which fields should be redacted..
  """
  erasureRequestRedactionEnabled: Boolean

  """The attribute values associated with this subdatapoint"""
  attributes: [AttributeInput!]

  """The organization's controllership of the subdatapoint"""
  controllership: Controllership

  """The type of retention schedule for this subdatapoint"""
  retentionType: RetentionType

  """
  The number of days personal data is retained (for stated period retention types)
  """
  retentionPeriod: Int
}

type CreateSubjectPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The internal configuration for a data subject"""
  subject: DataSubjectInternal!
}

"""Input for creating a data subject"""
input CreateSubjectInput {
  """
  The unique name of the data subject classification within the organization
  """
  type: String!

  """The display message used on the privacy center"""
  title: String!

  """The classification of data subject"""
  subjectClass: DataSubjectClass!

  """
  The admin dashboard form for this data subject should result all requests in silent mode when true. This is useful for admin-only workflows.
  """
  adminDashboardDefaultSilentMode: Boolean

  """The actions to allow for this data subject"""
  actions: [RequestAction!]

  """
  The instructions that should be shown in the modal as the data subject attempts to login
  """
  loginInstructions: String

  """
  The instructions that should be shown in the modal to instruct the data subject to make the request another way
  """
  disabledInstructions: String

  """The URL where the data subject can login"""
  redirectUrl: String

  """The organization's oauthClientId associated with subjects of this type"""
  oauthClientId: String

  """The oauthScope used to get context for data subjects of this type."""
  oauthScope: String

  """
  The unique ids of the users to assign as owners of this data subject and requests made to this data subject.
  """
  ownerIds: [ID!]

  """
  The ids of the teams that should be responsible for this data subject and requests made to this data subject.
  """
  teamIds: [ID!]

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type CreateTeamPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An existing team of users.
  The team can be assigned scopes and all users in that team will inherit the scopes
  """
  team: Team!
}

type CreateTemplatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An email template to send and receive communication with the data subject
  """
  template: Template!
}

type CreateVendorPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A vendor of the organization"""
  vendor: Vendor!
}

"""Input for creating a vendor"""
input CreateVendorInput {
  """The title of the vendor"""
  title: String!

  """The description of the vendor"""
  description: String!

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """A phone number for the vendor"""
  contactPhone: String

  """The address of the vendor"""
  address: String

  """The unique ids of the users to assign as owners of this vendor"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this vendor"""
  ownerEmails: [String!]

  """The business entity that the vendor is assigned to"""
  businessEntityId: ID

  """The business entity that the vendor is assigned to"""
  businessEntityTitle: String

  """The ids of the teams that should be responsible for this vendor"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this vendor"""
  teamNames: [String!]

  """The attribute values used to label this vendor"""
  attributes: [AttributeInput!]
}

type CreateWorkflowPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration of a workflow - WIP"""
  workflowConfig: WorkflowConfig!
}

"""Input for creating a new workflow"""
input CreateWorkflowInput {
  """The title of the workflow"""
  title: String!

  """The action of the workflow"""
  actionType: RequestAction!
}

type CurrentEmailSenderAddressesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of EmailSenderAddress"""
  nodes: [EmailSenderAddress!]!
}

"""Input to the current email sender addresses endpoint"""
input CurrentEmailSenderAddressesInput {
  """The id of the privacy center for which to fetch"""
  privacyCenterId: ID
}

"""The currently logged in user"""
type CurrentUser implements UserInterface {
  """The unique ID of the user"""
  id: ID!

  """The email address of the user"""
  email: String!

  """The name of the user"""
  name: String!

  """The time the user was created"""
  createdAt: Date!

  """The method by which that user logs in"""
  loginMethod: UserLoginMethod!

  """The profile picture of the user"""
  profilePicture: String!

  """Indicates if user can reveal multi tenant sombra secret"""
  canRevealMultiTenantSombraSecret: Boolean!

  """Indicates if the user is an admin of the organization"""
  isAdmin: Boolean!

  """Indicates if the user has been successfully onboarded"""
  onboarded: Boolean!

  """The language that is selected for the current user"""
  locale: String!

  """The organization that the user belongs to"""
  organization: Organization!

  """The roles that the user can assume in the other organizations"""
  roles: [Role!]!

  """Indicates if user has permissions to initiate a sombra deploy"""
  hasSombraTransferAbility: Boolean @deprecated(reason: "This field is deprecated")

  """The id of the parent role if applicable"""
  parentRole: UserPreview

  """The teams the user is associated with"""
  teams: [TeamPreview!]!

  """The hashed user ID for intercom identity verification"""
  intercomId: String

  """A hash of the primary user email address, used for analytics"""
  analyticsId: String
}

"""Custom Function"""
type CustomFunction {
  """Custom Function ID"""
  id: ID!

  """The last time function code or context was modified"""
  lastModifiedAt: Date!

  """Signed Code JWT"""
  signedCodeJwt: String!

  """Signed Code Context JWT"""
  signedCodeContextJwt: String!
}

"""Error emitted for a custom function execution"""
type CustomFunctionExecutionError {
  """Error message"""
  message: String!
}

"""Log emitted for a custom function execution"""
type CustomFunctionExecutionLog {
  """Log message"""
  message: String!

  """stdout or stderr"""
  file: String!
}

"""
Payload that allows users to override specific parts of the custom functiondefinition without needing to persist changes.
"""
type CustomFunctionExecutionOverridePayload {
  """
  Base64 string representation of a stringified JSON with the overridden environment variables.
  """
  environment: String
}

"""Profiling information for a custom function execution"""
type CustomFunctionExecutionProfile {
  """Execution time in milliseconds"""
  timeMs: Float!

  """List of spawn arguments"""
  spawnArgs: [String!]!

  """Unix epoch in milliseconds representing start time"""
  start: String!

  """Unix epoch in milliseconds representing end time"""
  end: String!
}

"""Custom function execution result"""
type CustomFunctionExecutionResult {
  """Profiling information"""
  profile: CustomFunctionExecutionProfile!

  """Logs"""
  logs: [CustomFunctionExecutionLog!]!

  """
  When the Deno process exits with a non-zero exit code, or the Deno process otherwise fails to execute on Sombra.
  """
  error: CustomFunctionExecutionError

  """Exit code of the Deno process"""
  exitCode: Int!
}

"""Inputs to get and filter custom functions"""
input CustomFunctionFilterInput {
  """Custom Function ID"""
  id: ID

  """Filter by Data Silo ID"""
  dataSiloId: ID
}

type CustomFunctionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of CustomFunction"""
  nodes: [CustomFunction!]!

  """int"""
  totalCount: Int!
}

"""Custom headers to include in outbound webhook"""
type CustomHeader {
  """The name of the header to set"""
  name: String!

  """The value of the header"""
  value: String!

  """The header contains a secret"""
  isSecret: Boolean!
}

"""Custom headers to include in outbound webhook"""
input CustomHeaderInput {
  """The name of the header to set"""
  name: String!

  """The value of the header"""
  value: String!

  """The header contains a secret"""
  isSecret: Boolean!
}

type CustomSyncEndpointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SyncEndpointCustomDomain"""
  nodes: [SyncEndpointCustomDomain!]!

  """int"""
  totalCount: Int!
}

"""A way in which the organization applies the data they collect"""
type DataApplication implements MenuTabInterface {
  """The unique id"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String

  """A brief overview of the data application"""
  description: DefinedMessage!

  """The method in which the data application is gathered"""
  method: String!

  """The static type underlying the data application"""
  staticType: String

  """The color to display in the admin dashboard select input"""
  color: String!
}

type DataCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataCategoryInterface"""
  nodes: [DataCategoryInterface!]!

  """int"""
  totalCount: Int!
}

"""A category of data, rended to data subjected on the privacy center"""
type DataCategory implements MenuTabInterface {
  """The unique tab identifier"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String

  """
  The underlying static type from which this data category was created. Defaults to null
  """
  staticType: String

  """Data category method"""
  method: String

  """
  The data collection data categories that should be displayed as children of this data category
  """
  children: [DataCollection!]!
}

"""Input for filtering the list of data categories"""
input DataCategoryFiltersInput {
  """Filter by text"""
  text: String

  """Filter by dataSilo"""
  dataSiloId: ID

  """Include fallback sub-categories (default: false)"""
  includeFallback: Boolean

  """The unique ids of the users assigned as owners of this data category"""
  ownerIds: [ID!]

  """The ids of the teams that should be responsible for this data category"""
  teamIds: [ID!]

  """
  Filter by IDs of recipient categories associated with the catalogs of silos whose subdatapoints have this data subcategory
  """
  saaSCategoryIds: [ID!]

  """
  Filter by the type of retention schedule for subdatapoints with this data subcategory
  """
  retentionTypes: [RetentionType!]

  """The attribute values used to label the data category"""
  attributeValueIds: [ID!]
}

"""Interface for a data category, either top-level or subcategory"""
interface DataCategoryInterface {
  """The ID for the subcategory"""
  id: ID!

  """The name of the subcategory"""
  name: String

  """The category of personal data"""
  category: DataCategoryType!

  """The slug of the category for templating"""
  slug: String!

  """The regex used to identify this data subcategory"""
  regex: String

  """Description of (sub)category"""
  description: String

  """Number of data points within (sub)category"""
  dataPointCount: Int!

  """The attribute values used to label this subcategory"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this data sub category
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this data sub category
  """
  teams: [TeamPreview!]!
}

"""A tab list of data categories grouped by method"""
type DataCategoryMethodMenu implements MenuTabInterface {
  """The unique tab identifier"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String

  """Data category method"""
  method: String! @deprecated(reason: "Removing this feature")

  """
  The data categories that should be displayed as children of this method grouping
  """
  children: [DataCategory!]! @deprecated(reason: "Removing this feature")
}

"""A collection of data that the organization holds"""
type DataCollection implements MenuTabInterface {
  """The id of the data collection"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String

  """The underlying static type of the data collection"""
  staticType: DataCollectionStaticType

  """The data application associated with the data collection"""
  dataApplications: [DataApplication!] @deprecated(reason: "Data applications are being removed")

  """The category that the data collection belongs under"""
  dataCategoryId: ID @deprecated(reason: "Data categories are being removed")

  """A brief overview of the data collection"""
  description: DefinedMessage @deprecated(reason: "Descriptions are being removed")
}

"""Input for updating or creating a data collection"""
input DataCollectionInput {
  """The id of the data collection to update, else create new"""
  id: ID

  """The title of the data collection"""
  title: String!

  """The icon used to display the data practice data collection"""
  icon: String

  """The underlying static type of the data collection"""
  staticType: DataCollectionStaticType
}

"""The number of request files for a data collection"""
type DataCollectionRequestFileCount {
  """The data collection id"""
  id: ID!

  """The number of request files for the data collection"""
  count: Int

  """Whether the data collection has request files"""
  hasRequestFiles: Boolean!
}

type DataCollectionsRequestFileCountPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataCollectionRequestFileCount"""
  requestFileCounts: [DataCollectionRequestFileCount!]!
}

"""Input for a DataCollectionsRequestFileCount query"""
input DataCollectionsRequestFileCountInput {
  """The id of the request to find request files for"""
  requestId: ID!
}

"""An Airgap data flow config"""
type DataFlow {
  """The ID of this data flow"""
  id: ID!

  """The description for this data flow"""
  description: String

  """The value of this data flow"""
  value: String!

  """The type of this data flow"""
  type: DataFlowScope!

  """The tracking types that apply to this data flow"""
  trackingType: [String!]!

  """A list of tracking purposes associated with this data flow"""
  purposes: [TrackingPurpose!]!

  """The relative frequency of this data flow"""
  frequency: Float!

  """The SaaS tool associated with these data flows"""
  service: Catalog

  """Whether Airgap should ignore this data flow"""
  isJunk: Boolean!

  """The source of this data flow, (scanned or manually entered)"""
  source: ConsentTrackerSource!

  """The status of this data flow"""
  status: ConsentTrackerStatus!

  """The time the request was made"""
  createdAt: Date!

  """The time the request was last updated"""
  updatedAt: Date!

  """Places this data flow was encountered"""
  encounters: [String!]

  """The last time this particular data flow was encountered"""
  lastDiscoveredAt: Date

  """The attribute values used to label this data flow"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this data flow
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data flow"""
  teams: [TeamPreview!]!

  """Whether or not this data flow has a pending telemetry metadata sync"""
  pendingTelemetryMetadataSync: Boolean!

  """The number of times this data flow has been seen"""
  occurrences: Float!
}

"""Input for a new data flow"""
input DataFlowInput {
  """The value for the data flow"""
  value: String!

  """The type of this data flow"""
  type: DataFlowScope!

  """The tracking types that apply to this data flow"""
  trackingType: [String!]

  """The purposes that apply to this data flow"""
  purposeIds: [ID!]

  """The description for this data flow"""
  description: String

  """The name of the SaaS tool associated with this data flow"""
  service: String

  """Whether Airgap should ignore this data flow"""
  isJunk: Boolean

  """The status of this data flow"""
  status: ConsentTrackerStatus

  """The attribute values used to label this data flow"""
  attributes: [AttributeInput!]
}

"""The order for a DataFlow query"""
input DataFlowOrder {
  """The field that the DataFlow nodes should be ordered by"""
  field: DataFlowOrderField!

  """
  The direction in which to order the DataFlow nodes by the specified field
  """
  direction: OrderDirection!
}

type DataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataFlow"""
  nodes: [DataFlow!]!

  """int"""
  totalCount: Int!
}

"""The services (SaaS tools) that have configured data flows"""
type DataFlowService {
  """The SaaS tool associated with these data flows"""
  service: Catalog

  """The types of data flows configured for this service"""
  types: [DataFlowScope!]!

  """The tracking types that apply to data flows for this service"""
  trackingTypes: [String!]!

  """A list of tracking purposes associated with this data flow"""
  purposes: [TrackingPurpose!]!

  """The number of data flows configured for this service"""
  count: Int!

  """Whether this grouping contains only junk data flows"""
  isJunk: Boolean!
}

type DataFlowServicesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataFlowService"""
  nodes: [DataFlowService!]!

  """int"""
  totalCount: Int!
}

"""Filters that can be applied when searching up data flow services"""
input DataFlowServicesFiltersInput {
  """Filter for services that have data flows of a certain rule"""
  trackingTypes: [String!]

  """Filter for services that have data flows of a certain purpose"""
  purposes: [ID!]

  """Filter data flows by text"""
  text: String

  """
  Filter for data flows marked as "junk"
  """
  isJunk: Boolean

  """Filter for a data flow's status"""
  status: ConsentTrackerStatus

  """
  Whether or not to show data flows with zero activity in the past 3 days. Defaults to false.
  """
  showZeroActivity: Boolean
}

"""Filters that can be applied when querying for data flows"""
input DataFlowsFiltersInput {
  """
  Filter for data flows that are associated with a particular integration (or empty string for unassociated data flows)
  """
  service: String

  """Filter data flows by text"""
  text: String

  """Filter for services that have data flows of a certain rule"""
  trackingTypes: [String!]

  """Filter for services that have data flows of a certain purpose"""
  purposes: [ID!]

  """
  Filter for data flows marked as "junk"
  """
  isJunk: Boolean

  """
  Whether or not to show data flows with zero activity in the past 3 days. Defaults to false.
  """
  showZeroActivity: Boolean

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """Filter by the attribute values used to label the data flows"""
  attributeValueIds: [ID!]

  """Filter for data flows by their source"""
  source: ConsentTrackerSource

  """Filter for a data flow's status"""
  status: ConsentTrackerStatus

  """Filter for a data flow based on type"""
  type: DataFlowScope

  """The list of plugins that found this data silo"""
  discoveredBy: [ID!]

  """Filter for data flows by when they were created"""
  createdAt: String

  """Filter for data flows by when they were last encountered"""
  lastDiscoveredAt: String

  """Filter for data flows by the places they have been encountered"""
  encounters: String

  """
  Filter for data flows with a minimum number of times the data flow has been seen
  """
  minOccurrences: Int

  """Filter for data flows that match a specific url"""
  matchesUrl: String
}

type DataFlowStatsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  liveCount: Int!

  """int"""
  needReviewCount: Int!

  """int"""
  junkCount: Int!

  """float"""
  liveActivity: Float!

  """float"""
  needReviewActivity: Float!

  """float"""
  junkActivity: Float!
}

"""
Suggestions for certain data flow fields based on the user inputted value
"""
type DataFlowSuggestion {
  """The value of this data flow"""
  value: String!

  """The type of this data flow"""
  type: DataFlowScope!

  """The suggested service associated for this data flow"""
  service: Catalog

  """The suggested tracking purposes associated for this data flow"""
  trackingType: [String!]!

  """The suggested description for this data flow"""
  description: String
}

"""Information about a data flow for the public Tracking Technology page"""
type DataFlowSummary {
  """The value of this data flow"""
  value: String!

  """The tracking types that apply to this data flow"""
  trackingPurposes: [String!]!
}

"""Metadata on a top-level data processing category"""
type DataInventoryCategory implements DataCategoryInterface {
  """The ID for the subcategory"""
  id: ID!

  """The name of the subcategory"""
  name: String

  """The category of personal data"""
  category: DataCategoryType!

  """The slug of the category for templating"""
  slug: String!

  """The regex used to identify this data subcategory"""
  regex: String

  """Description of (sub)category"""
  description: String

  """Number of data points within (sub)category"""
  dataPointCount: Int!

  """The attribute values used to label this subcategory"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this data sub category
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this data sub category
  """
  teams: [TeamPreview!]!
}

"""A data silo used in building a data lineage graph"""
type DataLineageDataSilo {
  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A preview of the attached catalog"""
  catalog: CatalogPreview!

  """The id of the data silo that receives data from this data silo"""
  receiverDataSiloId: ID
}

"""
The interface for a data silo in the datamap, viewed on the datamap page
"""
interface DatamapDataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """The SaaS categories for this data silo"""
  saaSCategories: [SaaSCategoryBase!]!

  """The default policy for visibility setting when creating subdatapoints"""
  defaultAccessRequestVisibility: Boolean!

  """
  When true, the data silo is configured to communicate with an email address to manually fulfil requests
  """
  hasEmailEnabled: Boolean!

  """
  The number of requests that are active and have encountered an error processing
  """
  errorCount: Int!

  """The number of subdatapoints this data silo has"""
  subDataPointCount: Int!

  """
  The number of data flows found associated to the same catalog entry as this data silo
  """
  dataFlowCount: ConsentManagerCount!

  """
  The number of cookies found associated to the same catalog entry as this data silo
  """
  cookieCount: ConsentManagerCount!

  """
  The email address that should be notified whenever new requests are made
  """
  notifyEmailAddress: String

  """The URL of the webhook to notify on manual action"""
  notifyWebhookUrl: String

  """The list of data subjects that are blocked for this data silo"""
  subjectBlocklist: [DataSubject!]!

  """The list of data subjects that are not blocked for this data silo"""
  subjects: [DataSubject!]!

  """The attribute values used to label this data silo"""
  attributeValues: [AttributeValue!]!

  """Freeform notes about the data silo"""
  notes: String!

  """A freeform note talking about data retention policy at high level"""
  dataRetentionNote: String!

  """A link to the DPA for this data silo or a note about the status"""
  dataProcessingAgreementLink: String

  """A link to the website of the data silo, if applicable."""
  websiteUrl: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this data silo (often a third party contact)"""
  contactEmail: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus!

  """Whether the integration is recommended for consent manager purposes"""
  recommendedForConsent: ConsentManagerConnectionStatus!

  """Whether the integration is recommended for privacy request purposes"""
  recommendedForPrivacy: PrivacyRequestConnectionStatus!

  """Whether the data silo has personal data in it"""
  hasPersonalData: HasPersonalDataStatus!

  """Whether the data silo has been deprecated"""
  deprecationState: DataSiloDeprecationState!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The vendor that the data silo is for"""
  vendor: VendorPreview

  """The identifiers that can key the data silo"""
  identifiers: [WiredIdentifier!]!

  """The list of data silos that receive data from this data silo"""
  receiverDataSilos: [DataSiloPreview!]!

  """The controllership values assigned to this data silo"""
  controllerships: [Controllership!]!

  """
  The controllership values assigned to the sub-datapoints of this data silo
  """
  subDataPointControllerships: [Controllership!]!

  """the template to use for the prompt-a-vendor email"""
  promptEmailTemplate: Template

  """
  The frequency with which we should be sending emails for this data silo, in milliseconds.
  """
  promptAVendorEmailSendFrequency: Int!

  """
  The type of emails to send for this data silo, i.e. send an email for each DSR, across all open DSRs, or per profile in a DSR.
  """
  promptAVendorEmailSendType: PromptAVendorEmailSendType!

  """
  Indicates whether prompt-a-vendor emails should include a list of identifiers in addition to a link to the bulk processing UI.
  """
  promptAVendorEmailIncludeIdentifiersAttachment: Boolean!

  """
  Indicates what kind of link to generate as part of the emails sent out for this PaV silo.
  """
  promptAVendorEmailCompletionLinkType: PromptAVendorEmailCompletionLinkType!

  """
  The resolver to use with a custom silo. This does not apply to non-server silos.
  """
  customSiloConnectionStrategy: CustomSiloConnectionStrategy

  """
  The updated frequency with which we should retry sending emails for this data silo, in milliseconds. Needs to be a string because the number can be larger than the MAX_INT
  """
  manualWorkRetryFrequency: String!

  """The data actions configured for this data silo"""
  connectedActions: [RequestActionObjectResolver!]!

  """
  A list of data silos that the parent data silo depends on completing before it runs
  """
  dependentDataSilos: [DataSiloPreview!]!

  """The API keys that have access to this data silo"""
  apiKeys: [ApiKeyPreview!]!

  """The business entities assigned directly to the data silo"""
  businessEntities: [BusinessEntityPreview!]!
}

"""
A sub-categorization of data with a data silo, from internal perspective
"""
type DataPoint implements DataPointInterface {
  """The unique ID of the datapoint"""
  id: ID!

  """The display title of the datapoint"""
  title: DefinedMessage

  """A brief overview of the datapoint"""
  description: DefinedMessage

  """The identifying name/key of the datapoint"""
  name: String!

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """The slug of the datapoint for templating"""
  slug: String!

  """The id of the data silo that contains the datapoint"""
  dataSiloId: ID!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """
  The allowed mime types for the datapoint. Empty list implies all mime types allowed
  """
  allowedMimeTypes: [String!]!

  """
  The set of data categories assigned to the sub-datapoints of this datapoint
  """
  dataSubCategories: [DataInventoryCategory!]!

  """
  Whether or not the datapoint can be deleted. Datapoints that are managed by Transcend cannot be deleted.
  """
  canDelete: Boolean!

  """Settings for datapoint actions"""
  actionSettings: [DataPointActionSetting!]!

  """Method for redacting data in an erasure request"""
  erasureRedactionMethod: ErasureRedactionMethod

  """The query to pass to a database integration to resolve a specific DSR"""
  dbIntegrationQueries: [DbIntegrationQuery!]

  """The data collection that the datapoint is associated with"""
  dataCollection: DataCollection

  """The data silo for this datapoint"""
  dataSilo: DataSiloPreview!

  """The hierarchy of levels associated with this datapoint"""
  path: [String!]!

  """The number of subdatapoints this datapoint has beneath it"""
  subDataPointCount: Int!

  """The number of subdatapoints set to be returned in an access request"""
  accessRequestVisibilityCount: Int!

  """The number of subdatapoints set to be redacted in an erasure request"""
  erasureRequestRedactionCount: Int!

  """
  The number of confirmed personal data subdatapoints beneath this datapoint
  """
  confirmedPersonalDataCount: Int!

  """
  The number of guessed personal data subdatapoints beneath this datapoint
  """
  guessedPersonalDataCount: GuessedPersonalDataCount!

  """The export mode of the datapoint"""
  exportMode: DataPointExportMode!

  """
  The list of individual users who are responsible for managing this datapoint
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this datapoint"""
  teams: [TeamPreview!]!

  """The description that comes from a plugin result"""
  scannedDescription: String

  """Whether description has been manually updated by user"""
  descriptionWasManuallyUpdated: Boolean

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!

  """The workflow config for this data point"""
  workflowDataPoint: WorkflowDataPoint
}

"""A setting for a datapoint/action pair"""
type DataPointActionSetting {
  """The type of action"""
  type: RequestActionObjectResolver!

  """True if that datapoint is currently on for the action"""
  active: Boolean!

  """True if that datapoint is allowed to be configured for this data silo"""
  allowed: Boolean!
}

"""Input for filtering a list of datapoints"""
input DataPointFiltersInput {
  """The text to filter the datapoints by"""
  text: String

  """Filter by data silos the datapoints belong to"""
  dataSilos: [ID!]

  """Filter by datapoint IDs"""
  ids: [ID!]

  """Filter by the assigned owner IDs"""
  owners: [ID!]

  """Show datapoints with approved SQL statements"""
  showApprovedSqlQueries: Boolean

  """Show datapoints with suggested SQL statements"""
  showSuggestedSqlQueries: Boolean

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """Filter by enabled actions"""
  enabledActions: [RequestAction!]

  """
  Filter by category of personal data assigned to the datapoints' sub-datapoints
  """
  categories: [DataCategoryType!]

  """
  Filter by the IDs of confirmed data subcategories assigned to the datapoints' sub-datapoints
  """
  subCategoryIds: [ID!]

  """Filter by the IDs of data collections to which the datapoints belong"""
  dataCollectionIds: [ID!]

  """Filter to datapoints that are missing required fields"""
  missingRequiredFields: Boolean

  """The ids of the attribute values to update"""
  attributeValueIds: [ID!]

  """Filter by datapoint level IDs"""
  dataPointLevelIds: [ID!]

  """Filter by datapoints included in a given workflow"""
  workflowId: ID

  """Filter by workflow group. Must also specify workflowId"""
  workflowGroup: Int

  """Filter data points by data point level name"""
  dataPointLevelName: String
}

type DataPointHierarchyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataPointHierarchyItem"""
  nodes: [DataPointHierarchyItem!]!

  """int"""
  totalCount: Int!
}

"""Input for filtering a hierarchy of datapoints"""
input DataPointHierarchyFiltersInput {
  """The text to filter the datapoints by"""
  text: String

  """Filter by datapoint level IDs"""
  dataPointLevelIds: [ID!]

  """Filter by data silos the datapoints belong to"""
  dataSiloId: ID!

  """Filter by parent datapoint level ID"""
  parentLevelId: ID

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """Filter by the attribute values used to label the data hierarchy item"""
  attributeValueIds: [ID!]
}

"""
A sub-categorization of data with a data silo, from internal perspective
"""
type DataPointHierarchyItem {
  """The unique ID of the datapoint or the datapoint level"""
  id: String!

  """The identifying name/key of the datapoint"""
  name: String!

  """The display title of the datapoint"""
  title: DefinedMessage

  """The metadata for the object"""
  metadata: DataPointHierarchyItemMetadata

  """The path to this hierarchy item"""
  path: [String!]

  """Is this item a datapoint or a folder?"""
  isDataPoint: Boolean!

  """The total number subdatapoints beneath this hierarchy item"""
  subDataPointsCount: Int!

  """
  The number subdatapoints beneath this hierarchy item that have at least one category assigned
  """
  confirmedSubDataPointsCount: Int!

  """
  The number of confirmed personal data subdatapoints beneath this hierarchy item
  """
  confirmedPersonalDataCount: Int!

  """
  The number of guessed personal data subdatapoints beneath this hierarchy item
  """
  guessedPersonalDataCount: GuessedPersonalDataCount!

  """
  The list of individual users who are responsible for managing this datapoint level
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this processing purpose sub category
  """
  teams: [TeamPreview!]!

  """The ID of the data silo that contains the item"""
  dataSiloId: ID

  """The description of the data point"""
  description: String

  """The attribute values used to label this dataPointHierarchyItem"""
  attributeValues: [AttributeValue!]!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType
}

"""Metadata for a hierarchy item"""
type DataPointHierarchyItemMetadata {
  """The number of rows in the object"""
  rowCount: Int!
}

type DataPointHierarchyPathPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataPointHierarchyItem"""
  pathSegments: [DataPointHierarchyItem!]!
}

"""Input for filtering a hierarchy of datapoints"""
input DataPointHierarchyPathFiltersInput {
  """Filter by data silos the datapoints belong to"""
  dataSiloId: ID!

  """Filter by parent datapoint level ID"""
  parentLevelId: ID

  """Add the current datapoint"""
  dataPointId: ID
}

"""A datapoint is a granular piece of data with a data silo"""
interface DataPointInterface {
  """The unique ID of the datapoint"""
  id: ID!

  """The display title of the datapoint"""
  title: DefinedMessage

  """A brief overview of the datapoint"""
  description: DefinedMessage

  """The identifying name/key of the datapoint"""
  name: String!

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """The slug of the datapoint for templating"""
  slug: String!

  """The id of the data silo that contains the datapoint"""
  dataSiloId: ID!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """
  The allowed mime types for the datapoint. Empty list implies all mime types allowed
  """
  allowedMimeTypes: [String!]!
}

"""
Additional metadata collected by transcend about this particular datapoint
"""
type DataPointMetadata implements DataPointMetadataInterface {
  """URL references to documentation about the datapoint"""
  references: [String!]

  """
        When provided, the datapoint is known to be a subjective lookup and will
      require a person to manually verify the results.
  This is expected to be a list of JSON paths, encoding which fields in the request file should be previewed for redaction.
  """
  subjectivePaths: [String!]

  """
    When provided, there is some sort of limitation to the datapoint that employees
  should be aware of.
  """
  employeeDescription: String
}

"""
Additional metadata collected by transcend about this particular datapoint
"""
interface DataPointMetadataInterface {
  """URL references to documentation about the datapoint"""
  references: [String!]

  """
        When provided, the datapoint is known to be a subjective lookup and will
      require a person to manually verify the results.
  This is expected to be a list of JSON paths, encoding which fields in the request file should be previewed for redaction.
  """
  subjectivePaths: [String!]

  """
    When provided, there is some sort of limitation to the datapoint that employees
  should be aware of.
  """
  employeeDescription: String
}

"""The order for a DataPoint query"""
input DataPointOrder {
  """The field that the DataPoint nodes should be ordered by"""
  field: DataPointOrderField!

  """
  The direction in which to order the DataPoint nodes by the specified field
  """
  direction: OrderDirection!
}

"""
Previews associated datapoint information. Used as download file metadata
"""
type DataPointPreview implements DataPointInterface {
  """The unique ID of the datapoint"""
  id: ID!

  """The display title of the datapoint"""
  title: DefinedMessage

  """A brief overview of the datapoint"""
  description: DefinedMessage

  """The identifying name/key of the datapoint"""
  name: String!

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """The slug of the datapoint for templating"""
  slug: String!

  """The id of the data silo that contains the datapoint"""
  dataSiloId: ID!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """
  The allowed mime types for the datapoint. Empty list implies all mime types allowed
  """
  allowedMimeTypes: [String!]!
}

"""Previews associated datapoint information with associated data silo"""
type DataPointPreviewWithDataSilo implements DataPointInterface {
  """The unique ID of the datapoint"""
  id: ID!

  """The display title of the datapoint"""
  title: DefinedMessage

  """A brief overview of the datapoint"""
  description: DefinedMessage

  """The identifying name/key of the datapoint"""
  name: String!

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """The slug of the datapoint for templating"""
  slug: String!

  """The id of the data silo that contains the datapoint"""
  dataSiloId: ID!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """
  The allowed mime types for the datapoint. Empty list implies all mime types allowed
  """
  allowedMimeTypes: [String!]!

  """The data silo for this datapoint"""
  dataSilo: DataSiloPreview!
}

type DataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataPoint"""
  nodes: [DataPoint!]!

  """int"""
  totalCount: Int!
}

"""
Input for updating/creating a subDatapoint as part of updating/creating a datapoint
"""
input DataPointSubDataPointInput {
  """The name of the subdatapoint"""
  name: String!

  """A description for the subdatapoint"""
  description: String

  """
          When true, this subdatapoint should be revealed in a data access request.
  When false, this field should be redacted
  """
  accessRequestVisibilityEnabled: Boolean

  """
          When true, this subdatapoint should be redacted during an erasure request.
  There normally is a choice of enabling hard deletion or redaction at the
  datapoint level, but if redaction is enabled, this column can be used
  to define which fields should be redacted.
  """
  erasureRequestRedactionEnabled: Boolean

  """The category of personal data for this subdatapoint"""
  categories: [DataSubCategoryInput!]

  """The processing purposes for this subdatapoint"""
  purposes: [PurposeSubCategoryInput!]

  """The attribute values used to label this subdatapoint"""
  attributes: [AttributeInput!]
}

"""The summarization for a datapoint against a specific RequestDataSilo"""
type DataPointSummary {
  """The unique database id of the datapoint"""
  id: ID!

  """Name of the datapoint"""
  name: String!

  """The slug of the datapoint for templating"""
  slug: String!

  """
  Usually only relevant for database silos, where datapoints can be uniquely identified by listing out the schemas that they belong to. The list of schema names MUST appear in order e.g., ["ANALYTICS","public"] is different from ["public","ANALYTICS"]
  """
  path: [String!]!

  """The title of the datapoint"""
  title: LocalizedMessage

  """The description of the datapoint"""
  description: LocalizedMessage

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """
  The accumulated status for the datapoint in the context of the RequestDataSilo
  """
  status: ProfileDataPointStatus

  """True if the datapoint supports redaction"""
  isRedactDataPoint: Boolean!

  """The number of request files associated with the RequestDataSilo."""
  fileCount: Int!

  """
  Associated Profile Data Point, if a profile Id is specified in the original query
  """
  profileDataPoint: ProfileDataPoint

  """The export type of the datapoint"""
  exportMode: DataPointExportMode!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """The allowed mime types for the datapoint"""
  allowedMimeTypes: [String!]!
}

"""The filters the applied to the exported data"""
input DataReportFilterInput {
  """The input for determining what data silos to filter"""
  DATA_INVENTORY_DATA_SILOS: DataSiloFiltersInput!

  """The input for determining what subdatapoints to filter"""
  DATA_INVENTORY_DATA_POINTS: SubDataPointFiltersInput!

  """The input for determining what vendors to filter"""
  DATA_INVENTORY_VENDORS: VendorsFiltersInput!

  """The input for determining what data subcategories to filter"""
  DATA_INVENTORY_DATA_CATEGORIES: DataSubCategoryFiltersInput!

  """The input for determining what processing purposes to filter"""
  DATA_INVENTORY_PURPOSES: ProcessingPurposeCategoryFiltersInput!

  """The input for determining what business entities to filter"""
  DATA_INVENTORY_BUSINESS_ENTITIES: BusinessEntitiesFiltersInput!
}

"""Input for filtering a list of data reports"""
input DataReportFiltersInput {
  """Filter by dataReport IDs"""
  ids: [ID!]

  """Filter by text"""
  text: String

  """Filter by IDs of users who created the data reports"""
  creatorIds: [ID!]

  """Filter by exact match for title"""
  title: String
}

"""Interface for data report hidden columns"""
input DataReportHiddenColumnsInput {
  """The data silos columns that were hidden"""
  DATA_INVENTORY_DATA_SILOS: [String!]!

  """The subdatapoints columns that were hidden"""
  DATA_INVENTORY_DATA_POINTS: [String!]!

  """The vendors columns that were hidden"""
  DATA_INVENTORY_VENDORS: [String!]!

  """The data subcategories columns that were hidden"""
  DATA_INVENTORY_DATA_CATEGORIES: [String!]!

  """The processing purpose columns that were hidden"""
  DATA_INVENTORY_PURPOSES: [String!]!

  """The business entities columns that were hidden"""
  DATA_INVENTORY_BUSINESS_ENTITIES: [String!]!
}

"""Record of which tables have invalid filter values stored"""
type DataReportInvalidFilters {
  """The data silos filter properties that are no longer valid"""
  DATA_INVENTORY_DATA_SILOS: [String!]!

  """The subdatapoints filter properties that are no longer valid"""
  DATA_INVENTORY_DATA_POINTS: [String!]!

  """The vendors filter properties that are no longer valid"""
  DATA_INVENTORY_VENDORS: [String!]!

  """The data subcategories filter properties that are no longer valid"""
  DATA_INVENTORY_DATA_CATEGORIES: [String!]!

  """The processing purpose filter properties that are no longer valid"""
  DATA_INVENTORY_PURPOSES: [String!]!

  """The business entities filter properties that are no longer valid"""
  DATA_INVENTORY_BUSINESS_ENTITIES: [String!]!
}

"""Record of which tables have invalid filter values stored"""
type DataReportMissingAttributes {
  """Count of the missing attribute values found in the data silos filter"""
  DATA_INVENTORY_DATA_SILOS: [String!]

  """
  Count of the missing attribute values found in the subdatapoints filter
  """
  DATA_INVENTORY_DATA_POINTS: [String!]

  """Count of the missing attribute values found in the vendors filter"""
  DATA_INVENTORY_VENDORS: [String!]

  """
  Count of the missing attribute values found in the data subcategories filter
  """
  DATA_INVENTORY_DATA_CATEGORIES: [String!]

  """
  Count of the missing attribute values found in the processing purpose filter
  """
  DATA_INVENTORY_PURPOSES: [String!]

  """
  Count of the missing attribute values found in the business entities filter
  """
  DATA_INVENTORY_BUSINESS_ENTITIES: [String!]
}

"""An exportable data inventory report"""
type DataReportRaw {
  """The id of the data report"""
  id: ID!

  """The title of the data report"""
  title: String!

  """The names of the tables included in this data report"""
  tables: [DataReportExportableTables!]!

  """A JSON blob of the filters applied to each table in the report"""
  filters: String!

  """
  A JSON blob of the columns that the user hid from each table in the report
  """
  hiddenColumns: String!

  """The user who created this data report"""
  creator: UserPreview

  """
  Whether the filters in the data report are out of sync with the current filter definition
  """
  invalidFilters: DataReportInvalidFilters!

  """Count of missing attribute values per table found in the filters"""
  missingAttributes: DataReportMissingAttributes
}

"""The order for a DataReportRaw query"""
input DataReportRawOrder {
  """The field that the DataReportRaw nodes should be ordered by"""
  field: DataReportRawOrderField!

  """
  The direction in which to order the DataReportRaw nodes by the specified field
  """
  direction: OrderDirection!
}

type DataReportsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataReportRaw"""
  nodes: [DataReportRaw!]!

  """int"""
  totalCount: Int!
}

type DataRetentionSchedulePolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Configurable retention policy to manage an organizations data"""
  retentionSchedule: RetentionSchedule!
}

"""
A place in the organization where data sits. This could be a database, SaaS tool, filing cabinet, etc.
"""
type DataSilo implements DatamapDataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """The SaaS categories for this data silo"""
  saaSCategories: [SaaSCategoryBase!]!

  """The default policy for visibility setting when creating subdatapoints"""
  defaultAccessRequestVisibility: Boolean!

  """
  When true, the data silo is configured to communicate with an email address to manually fulfil requests
  """
  hasEmailEnabled: Boolean!

  """
  The number of requests that are active and have encountered an error processing
  """
  errorCount: Int!

  """The number of subdatapoints this data silo has"""
  subDataPointCount: Int!

  """
  The number of data flows found associated to the same catalog entry as this data silo
  """
  dataFlowCount: ConsentManagerCount!

  """
  The number of cookies found associated to the same catalog entry as this data silo
  """
  cookieCount: ConsentManagerCount!

  """
  The email address that should be notified whenever new requests are made
  """
  notifyEmailAddress: String

  """The URL of the webhook to notify on manual action"""
  notifyWebhookUrl: String

  """The list of data subjects that are blocked for this data silo"""
  subjectBlocklist: [DataSubject!]!

  """The list of data subjects that are not blocked for this data silo"""
  subjects: [DataSubject!]!

  """The attribute values used to label this data silo"""
  attributeValues: [AttributeValue!]!

  """Freeform notes about the data silo"""
  notes: String!

  """A freeform note talking about data retention policy at high level"""
  dataRetentionNote: String!

  """A link to the DPA for this data silo or a note about the status"""
  dataProcessingAgreementLink: String

  """A link to the website of the data silo, if applicable."""
  websiteUrl: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this data silo (often a third party contact)"""
  contactEmail: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus!

  """Whether the integration is recommended for consent manager purposes"""
  recommendedForConsent: ConsentManagerConnectionStatus!

  """Whether the integration is recommended for privacy request purposes"""
  recommendedForPrivacy: PrivacyRequestConnectionStatus!

  """Whether the data silo has personal data in it"""
  hasPersonalData: HasPersonalDataStatus!

  """Whether the data silo has been deprecated"""
  deprecationState: DataSiloDeprecationState!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The vendor that the data silo is for"""
  vendor: VendorPreview

  """The identifiers that can key the data silo"""
  identifiers: [WiredIdentifier!]!

  """The list of data silos that receive data from this data silo"""
  receiverDataSilos: [DataSiloPreview!]!

  """The controllership values assigned to this data silo"""
  controllerships: [Controllership!]!

  """
  The controllership values assigned to the sub-datapoints of this data silo
  """
  subDataPointControllerships: [Controllership!]!

  """the template to use for the prompt-a-vendor email"""
  promptEmailTemplate: Template

  """
  The frequency with which we should be sending emails for this data silo, in milliseconds.
  """
  promptAVendorEmailSendFrequency: Int!

  """
  The type of emails to send for this data silo, i.e. send an email for each DSR, across all open DSRs, or per profile in a DSR.
  """
  promptAVendorEmailSendType: PromptAVendorEmailSendType!

  """
  Indicates whether prompt-a-vendor emails should include a list of identifiers in addition to a link to the bulk processing UI.
  """
  promptAVendorEmailIncludeIdentifiersAttachment: Boolean!

  """
  Indicates what kind of link to generate as part of the emails sent out for this PaV silo.
  """
  promptAVendorEmailCompletionLinkType: PromptAVendorEmailCompletionLinkType!

  """
  The resolver to use with a custom silo. This does not apply to non-server silos.
  """
  customSiloConnectionStrategy: CustomSiloConnectionStrategy

  """
  The updated frequency with which we should retry sending emails for this data silo, in milliseconds. Needs to be a string because the number can be larger than the MAX_INT
  """
  manualWorkRetryFrequency: String!

  """The data actions configured for this data silo"""
  connectedActions: [RequestActionObjectResolver!]!

  """
  A list of data silos that the parent data silo depends on completing before it runs
  """
  dependentDataSilos: [DataSiloPreview!]!

  """The API keys that have access to this data silo"""
  apiKeys: [ApiKeyPreview!]!

  """The business entities assigned directly to the data silo"""
  businessEntities: [BusinessEntityPreview!]!

  """
  Whether the integration counts towards the allotment of integrations in the contract
  """
  isPaidIntegration: Boolean!

  """When true, the subdatapoint settings are enabled"""
  privacyRequestSubdatapointEnabled: Boolean!

  """The user that is being notified"""
  users: [UserPreview!]!

  """The plaintext context parameters"""
  plaintextContext: [PlaintextContext!]!

  """The form items that must be reconnected, if applicable"""
  reconnectFormItems: [String!]

  """The plaintext paths that have been approved by the client"""
  allowedPlaintextPaths: [String!]!

  """The business entity that is inherited from the vendor"""
  businessEntity: BusinessEntityPreview

  """The number of open requests pertaining to this silo"""
  openRequestCount: Int!

  """Time this data silo's prompt-a-vendor email should start being sent"""
  promptAVendorEmailStartAt: Date!

  """The template ID of the email template used for notifications."""
  promptEmailTemplateId: ID

  """The datetime to send the next email for this data silo."""
  promptAVendorEmailScheduledAt: Date

  """True if the data silo has outstanding database query suggestions"""
  databaseQuerySuggestionCount: Int!

  """
  The updated start time when we should start retrying emails for this data silo, in ISO format.
  """
  manualWorkRetryStartAt: Date

  """The set of data categories assigned to this data silo"""
  dataSubCategories: [DataSubCategoryPreview!]!

  """The set of processing activities assigned to this data silo"""
  processingActivities: [ProcessingActivityPreview!]!

  """The set of processing purposes assigned to this data silo"""
  processingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """
  The set of data categories assigned to the sub-datapoints of this data silo
  """
  subDataPointDataSubCategories: [DataSubCategoryPreview!]!

  """
  The set of processing activities assigned to the sub-datapoints of this data silo
  """
  subDataPointProcessingActivities: [ProcessingActivityPreview!]!

  """
  The set of processing purposes assigned to the sub-datapoints of this data silo
  """
  subDataPointProcessingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """The regions where data is transferred to"""
  transferRegions: [Region!]!

  """Data silos discovered when scanning this data silo"""
  silosDiscovered: [SilosDiscoveredPreview!]

  """sombra associated with this data silo"""
  sombraId: ID

  """
  The associated sombra to this integration - when not specified, the default sombra is used
  """
  sombra: SombraPreview

  """
  The identifier mappings for this data silo, if it has a DB or looker enricher attached to it
  """
  enricherIdentifierMappings: [SignedIdentifierPath!]!

  """Workflow configs that are associated with this data silo"""
  workflowConfigId: ID

  """The sensitive categories that are related to this data silo"""
  sensitiveCategories: [SensitiveCategory!]
}

"""Preview of a data silo in a list"""
type DataSiloBulkPreview implements DatamapDataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """The SaaS categories for this data silo"""
  saaSCategories: [SaaSCategoryBase!]!

  """The default policy for visibility setting when creating subdatapoints"""
  defaultAccessRequestVisibility: Boolean!

  """
  When true, the data silo is configured to communicate with an email address to manually fulfil requests
  """
  hasEmailEnabled: Boolean!

  """
  The number of requests that are active and have encountered an error processing
  """
  errorCount: Int!

  """The number of subdatapoints this data silo has"""
  subDataPointCount: Int!

  """
  The number of data flows found associated to the same catalog entry as this data silo
  """
  dataFlowCount: ConsentManagerCount!

  """
  The number of cookies found associated to the same catalog entry as this data silo
  """
  cookieCount: ConsentManagerCount!

  """
  The email address that should be notified whenever new requests are made
  """
  notifyEmailAddress: String

  """The URL of the webhook to notify on manual action"""
  notifyWebhookUrl: String

  """The list of data subjects that are blocked for this data silo"""
  subjectBlocklist: [DataSubject!]!

  """The list of data subjects that are not blocked for this data silo"""
  subjects: [DataSubject!]!

  """The attribute values used to label this data silo"""
  attributeValues: [AttributeValue!]!

  """Freeform notes about the data silo"""
  notes: String!

  """A freeform note talking about data retention policy at high level"""
  dataRetentionNote: String!

  """A link to the DPA for this data silo or a note about the status"""
  dataProcessingAgreementLink: String

  """A link to the website of the data silo, if applicable."""
  websiteUrl: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this data silo (often a third party contact)"""
  contactEmail: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus!

  """Whether the integration is recommended for consent manager purposes"""
  recommendedForConsent: ConsentManagerConnectionStatus!

  """Whether the integration is recommended for privacy request purposes"""
  recommendedForPrivacy: PrivacyRequestConnectionStatus!

  """Whether the data silo has personal data in it"""
  hasPersonalData: HasPersonalDataStatus!

  """Whether the data silo has been deprecated"""
  deprecationState: DataSiloDeprecationState!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The vendor that the data silo is for"""
  vendor: VendorPreview

  """The identifiers that can key the data silo"""
  identifiers: [WiredIdentifier!]!

  """The list of data silos that receive data from this data silo"""
  receiverDataSilos: [DataSiloPreview!]!

  """The controllership values assigned to this data silo"""
  controllerships: [Controllership!]!

  """
  The controllership values assigned to the sub-datapoints of this data silo
  """
  subDataPointControllerships: [Controllership!]!

  """the template to use for the prompt-a-vendor email"""
  promptEmailTemplate: Template

  """
  The frequency with which we should be sending emails for this data silo, in milliseconds.
  """
  promptAVendorEmailSendFrequency: Int!

  """
  The type of emails to send for this data silo, i.e. send an email for each DSR, across all open DSRs, or per profile in a DSR.
  """
  promptAVendorEmailSendType: PromptAVendorEmailSendType!

  """
  Indicates whether prompt-a-vendor emails should include a list of identifiers in addition to a link to the bulk processing UI.
  """
  promptAVendorEmailIncludeIdentifiersAttachment: Boolean!

  """
  Indicates what kind of link to generate as part of the emails sent out for this PaV silo.
  """
  promptAVendorEmailCompletionLinkType: PromptAVendorEmailCompletionLinkType!

  """
  The resolver to use with a custom silo. This does not apply to non-server silos.
  """
  customSiloConnectionStrategy: CustomSiloConnectionStrategy

  """
  The updated frequency with which we should retry sending emails for this data silo, in milliseconds. Needs to be a string because the number can be larger than the MAX_INT
  """
  manualWorkRetryFrequency: String!

  """The data actions configured for this data silo"""
  connectedActions: [RequestActionObjectResolver!]!

  """
  A list of data silos that the parent data silo depends on completing before it runs
  """
  dependentDataSilos: [DataSiloPreview!]!

  """The API keys that have access to this data silo"""
  apiKeys: [ApiKeyPreview!]!

  """The business entities assigned directly to the data silo"""
  businessEntities: [BusinessEntityPreview!]!

  """The set of data categories assigned to this data silo"""
  dataSubCategories: [DataSubCategoryPreview!]!

  """The set of processing activities assigned to this data silo"""
  processingActivities: [ProcessingActivityPreview!]!

  """The set of processing purposes assigned to this data silo"""
  processingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """
  The set of data categories assigned to the sub-datapoints of this data silo
  """
  subDataPointDataSubCategories: [DataSubCategoryPreview!]!

  """
  The set of processing activities assigned to the sub-datapoints of this data silo
  """
  subDataPointProcessingActivities: [ProcessingActivityPreview!]!

  """
  The set of processing purposes assigned to the sub-datapoints of this data silo
  """
  subDataPointProcessingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """Data silos discovered when scanning this data silo"""
  silosDiscovered: [SilosDiscoveredPreview!]

  """The regions where data is transferred to"""
  transferRegions: [Region!]!

  """
  Super Categories associated with data subcategories assigned to this data silo
  """
  dataSiloSuperCategories: [AttributeValue!]!

  """
  Super Categories associated with data subcategories assigned to this data silo's subdatapoints
  """
  subDataPointSuperCategories: [AttributeValue!]!

  """Workflow configs that are associated with this data silo"""
  workflowConfigId: ID

  """The sensitive categories that are related to this data silo"""
  sensitiveCategories: [SensitiveCategory!]
}

"""The order for a DataSiloBulkPreview query"""
input DataSiloBulkPreviewOrder {
  """The field that the DataSiloBulkPreview nodes should be ordered by"""
  field: DataSiloBulkPreviewOrderField!

  """
  The direction in which to order the DataSiloBulkPreview nodes by the specified field
  """
  direction: OrderDirection!
}

"""
Input for filtering the communications for a particular request data silo
"""
input DataSiloCommunicationFilterInput {
  """The ID of the request to get messages for"""
  requestId: ID!

  """The ID of the request data silo to filter to"""
  requestDataSiloId: ID!
}

type DataSiloCommunicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Communication"""
  nodes: [Communication!]!

  """int"""
  totalCount: Int!
}

"""number of data silos in each country"""
type DataSilosCountForSingleCountry {
  """country code for corresponding data silos"""
  countryCode: String!

  """number of silos"""
  count: Int!
}

"""all countries and their corresponding data silos"""
type DataSilosByCountry {
  """list of countries and their data silos"""
  dataSiloCountsByCountry: [DataSilosCountForSingleCountry!]!

  """The last time the data was fetched"""
  cachedAt: Date
}

"""Input for dataSiloCountsByCountry endpoint"""
input DataSiloCountsByCountryInput {
  """Should ignore the cache and force a fetch?"""
  forceRefetch: Boolean
}

"""
The key for a `DataSiloDiscoPluginRecommendation` document from DynamoDB
"""
type DataSiloDiscoPluginRecommendationKey {
  """The ID of the plugin that found this recommendation"""
  pluginId: ID!

  """The unique identifier for the resource"""
  resourceId: String!

  """ID of the organization the resource belongs to"""
  organizationId: ID!

  """
  The status of the recommendation, concatenated with the latest run time
  """
  statusLatestRunTime: String!

  """The AWS Region for data silo if applicable"""
  region: String

  """The ISO country code for the AWS Region if applicable"""
  country: String

  """The ISO country subdivision code for the AWS Region if applicable"""
  countrySubDivision: String

  """The custom title of the data silo recommendation."""
  title: String

  """The plaintext for the resource."""
  plaintextContext: String
}

"""
The key for a `DataSiloDiscoPluginRecommendation` document from DynamoDB that can be passed as input
"""
input DataSiloDiscoPluginRecommendationKeyInput {
  """The ID of the plugin that found this recommendation"""
  pluginId: ID!

  """The unique identifier for the resource"""
  resourceId: String!

  """ID of the organization the resource belongs to"""
  organizationId: ID!

  """
  The status of the recommendation, concatenated with the latest run time
  """
  statusLatestRunTime: String!

  """The AWS Region for data silo if applicable"""
  region: String

  """The ISO country code for the AWS Region if applicable"""
  country: String

  """The ISO country subdivision code for the AWS Region if applicable"""
  countrySubDivision: String

  """The custom title of the data silo recommendation."""
  title: String

  """The plaintext for the resource."""
  plaintextContext: String
}

"""Inputs for determining what data silos to filter"""
input DataSiloFiltersInput {
  """Filter by text (title or description of data silo)"""
  text: String

  """Filter on direct title matches. Data silo titles are unique"""
  titles: [String!]

  """Filter by the data silo type"""
  type: [String!]

  """Filter for data silos that support a specific request action"""
  actions: [RequestAction!]

  """Filter for sender data silo IDs"""
  ids: [ID!]

  """Filter for data silos that are live"""
  isLive: Boolean

  """
  Filter for data silos that count against the contract integration count
  """
  isPaidIntegration: Boolean

  """Filter for data silos where datapoints are customizable"""
  canCustomizeDataPoints: Boolean

  """Filter for data silos that are deleted"""
  isDeleted: Boolean

  """Filter by the connection state"""
  connectionState: [DataSiloConnectionState!]

  """Filter by plugin type"""
  plugins: [PluginType!]

  """Filter by whether plugin(s) are enabled"""
  pluginsEnabled: Boolean

  """Filter by the assigned owner IDs"""
  owners: [ID!]

  """Filter by the assigned vendor IDs"""
  vendors: [ID!]

  """Filter by the assigned team IDs"""
  teams: [ID!]

  """Filter by the SaaS Category/recipient category IDs"""
  saaSCategoryIds: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """Filter by specific subcategory of processing purpose"""
  processingPurposeSubCategoryIds: [ID!]

  """Filter by the IDs of the data silos that receive data from this silo"""
  receiverDataSiloIds: [ID!]

  """Filter by the status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """
  Filter by whether the data silo is recommended for consent manager purposes
  """
  recommendedForConsent: ConsentManagerConnectionStatus

  """
  Filter by whether the data silo is recommended for privacy request purposes
  """
  recommendedForPrivacy: PrivacyRequestConnectionStatus

  """Filter by whether the data silo has personal data in it"""
  hasPersonalData: HasPersonalDataStatus

  """Filter by whether the data silo has been deprecated"""
  deprecationState: DataSiloDeprecationState

  """Filter by ids of data subjects included in this data silo"""
  dataSubjectIds: [ID!]

  """Filter by the attribute values used to label the data silos"""
  attributeValueIds: [ID!]

  """A list of fields for which to include null"""
  includeNulls: [DataSiloNullableFilters!]

  """Filter by ISO country"""
  country: [IsoCountryCode!]

  """Filter by ISO country subdivision"""
  countrySubDivision: [String!]

  """Filter by transfer regions"""
  transferRegions: [RegionInput!]

  """Filter by connector type"""
  connectorType: ConnectorType

  """Filter for data silo discovered by IDs"""
  discoveredBy: [ID!]

  """Filter by the associated business entities"""
  businessEntityIds: [ID!]

  """Filter by the associated vendor business entities"""
  vendorBusinessEntityIds: [ID!]

  """Filter by categories of personal data"""
  dataCategories: [DataCategoryType!]

  """Filter by specific subcategories of personal data"""
  dataSubCategoryIds: [ID!]

  """Filter by controllerships assigned to subdatapoints of this data silo"""
  controllerships: [Controllership!]

  """Filter by the associated workflow config"""
  workflowConfigId: ID

  """Filter by data silos not associated with a workflow config"""
  notAssociatedWithWorkflowConfigId: ID

  """Filter by the associated sensitive categories"""
  sensitiveCategoryIds: [ID!]

  """Filter by the associated processing activities"""
  processingActivityIds: [ID!]

  """Filter by Custom Silo Connection Strategy"""
  customSiloConnectionStrategy: String
}

"""Inputs for connecting server/skip/saas/promptAPerson data silos"""
input DataSiloInput {
  """The name of the integration connecting"""
  name: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields).
  The datapoints and everything else are still captured by the catalog enshrined in the "name" field.
  """
  outerType: String

  """The title of the data silo"""
  title: String

  """The description of the data silo"""
  description: String

  """The URL to send POST request notifications to"""
  url: String

  """The default policy for visibility setting when creating subdatapoints"""
  defaultAccessRequestVisibility: Boolean

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeaderInput!]

  """The id of the existing api key to attach to"""
  apiKeyId: ID

  """The id of template to use when prompting via email"""
  promptEmailTemplateId: ID

  """
  The email of the person that should be notified (an account will be created)
  """
  notifyEmailAddress: String

  """
  Indicates whether prompt-a-vendor emails should include a list of identifiers in addition to a link to the bulk processing UI.
  """
  promptAVendorEmailIncludeIdentifiersAttachment: Boolean

  """The webhook URL to notify for manual actions"""
  notifyWebhookUrl: String

  """The names of the identifiers that the data silo should be connected to"""
  identifiers: [String!]

  """Whether the data silo should be live"""
  isLive: Boolean

  """
  The IDs of the data silo that this data silo depends on during a deletion request.
  """
  dependedOnDataSiloIds: [ID!]

  """
  The titles of the data silo that this data silo depends on during a deletion request.
  """
  dependedOnDataSiloTitles: [String!]

  """the list of subject IDs to block list from this data silo"""
  dataSubjectBlockListIds: [ID!]

  """The unique ids of the users to assign as owners of this data silo"""
  ownerIds: [ID!]

  """The vendor that the data silo is assigned to"""
  vendorId: ID

  """The emails of the users to assign as owners of this data silo."""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this data silo"""
  teams: [ID!]

  """The names of the teams that should be responsible for this data silo"""
  teamNames: [String!]

  """The ids of the data silos that receive data from this data silo"""
  receiverDataSiloIds: [ID!]

  """The form input plaintext"""
  plaintextContext: [PlaintextContextInput!]

  """ISO country where data silo has data"""
  country: IsoCountryCode

  """ISO country where data silo has data"""
  countrySubDivision: String

  """
  User-defined key-value pairs that can be used to track additional metadata about your silo
  """
  attributes: [AttributeInput!]
}

"""The interface for identifying data silo details"""
interface DataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!
}

type DataSiloLineagePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataLineageDataSilo"""
  nodes: [DataLineageDataSilo!]!
}

"""Inputs for determining what data silos to filter"""
input DataSiloLineageFiltersInput {
  """Filter for data silo IDs"""
  ids: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """Filter by specific subcategory of processing purpose"""
  processingPurposeSubCategoryIds: [ID!]

  """Filter by categories of personal data"""
  dataCategories: [DataCategoryType!]

  """Filter by specific subcategories of personal data"""
  dataSubCategoryIds: [ID!]

  """
  Include in the results data silos that have no sender or receiver relationships
  """
  includeUnconnected: Boolean
}

"""Configurations for a data silo plugin"""
type DataSiloPluginConfiguration {
  """Whether the plugin is enabled by default"""
  defaultEnabled: Boolean
}

"""Configurations for each data silo plugins"""
type DataSiloPluginConfigurations {
  """Configuration for a data silo discovery plugin"""
  DATA_SILO_DISCOVERY: DataSiloPluginConfiguration

  """Configuration for a schema discovery plugin"""
  SCHEMA_DISCOVERY: DataSiloPluginConfiguration

  """Configuration for a content classification plugin"""
  CONTENT_CLASSIFICATION: DataSiloPluginConfiguration

  """Configuration for an unstructured data discovery plugin"""
  UNSTRUCTURED_DATA_DISCOVERY: DataSiloPluginConfiguration

  """Configuration for an unstructured data sampling plugin"""
  UNSTRUCTURED_DATA_SAMPLING: DataSiloPluginConfiguration
}

type DataSiloPluginRecommendationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SiloDiscoveryRecommendation"""
  nodes: [SiloDiscoveryRecommendation!]!
}

"""DataSiloPluginRecommendation Input"""
input DataSiloPluginRecommendationInput {
  """The plugin to toggle"""
  pluginId: ID!

  """The dataSilo type"""
  type: String
}

"""Preview of a data silo"""
type DataSiloPreview implements DataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!
}

type DataSiloRateLimitsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RateLimitConfig"""
  dataSiloRateLimits: [RateLimitConfig!]!
}

"""A data silo with a reduced set of fields"""
type DataSiloReduced {
  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """The type of data silo"""
  type: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """Sombra metadata"""
  sombra: SombraPreview!
}

"""Inputs for fetching a specific data silo with reduced fields"""
input DataSiloReducedQueryInput {
  """data silo id"""
  id: String

  """data silo token"""
  token: String
}

type DataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSiloBulkPreview"""
  nodes: [DataSiloBulkPreview!]!

  """int"""
  totalCount: Int!
}

"""Input for DataSilosForSingleCountry endpoint"""
input DataSilosForSingleCountryInput {
  """country code for which you are fetching data silos"""
  countryCode: String!
}

"""High level summary metrics for a data silo"""
type DataSiloSummary {
  """
  The total number of privacy requests that have been successfully resolved against this data silo.
  """
  requestsSucceededTotal: Int!

  """
  The total number of privacy requests that are actively waiting for completion.
  """
  requestsAwaitingTotal: Int!

  """The total number of privacy requests that are queued."""
  requestsQueuedTotal: Int!

  """
  The total number of privacy requests that are experiencing some error state.
  """
  requestsErrorsTotal: Int!

  """The total number of plugins that are experiencing errors"""
  pluginErrorsTotal: Int

  """The total number of lookup processes that are experiencing errors."""
  lookupProcessErrorsTotal: Int

  """The total number of records that have been indexed."""
  lookupProcessIndexedTotal: Int
}

type DataSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSubCategory"""
  nodes: [DataSubCategory!]!

  """int"""
  totalCount: Int!
}

"""Detailed info about a data processing subcategory"""
type DataSubCategory implements DataCategoryInterface {
  """The ID for the subcategory"""
  id: ID!

  """The name of the subcategory"""
  name: String!

  """The category of personal data"""
  category: DataCategoryType!

  """The slug of the category for templating"""
  slug: String!

  """The regex used to identify this data subcategory"""
  regex: String

  """Description of (sub)category"""
  description: String

  """Number of data points within (sub)category"""
  dataPointCount: Int!

  """The attribute values used to label this subcategory"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this data sub category
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this data sub category
  """
  teams: [TeamPreview!]!

  """Whether the subcategory is a default subcategory"""
  isDefault: Boolean!

  """
  The headquarter regions assigned to vendors that have subdatapoints with this data subcategory
  """
  vendorHeadquarterLocations: [String!]!

  """
  The regions assigned to data silos that have subdatapoints with this data subcategory
  """
  dataSiloRegions: [String!]!

  """
  The type of retention schedule for subdatapoints with this data subcategory, or the number of days data is retained for, if type is stated period
  """
  subDataPointRetentionSchedules: [String!]!

  """
  The pre-labeled recipient categories for catalogs associated with data silos whose subdatapoints have this data subcategory
  """
  catalogRecipients: [SaaSCategoryBase!]!

  """The data silos related to the data subcategory"""
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """The identifier that is linked to this data category"""
  identifier: WiredIdentifier

  """The sensitive categories that are related to this data category"""
  sensitiveCategories: [SensitiveCategory!]
}

"""Input for filtering the list of data categories"""
input DataSubCategoryFiltersInput {
  """Filter by text"""
  text: String

  """Filter by dataSilo"""
  dataSiloId: ID

  """Include fallback sub-categories (default: false)"""
  includeFallback: Boolean

  """
  The unique ids of the users assigned as owners of this data subcategory
  """
  ownerIds: [ID!]

  """
  The ids of the teams that should be responsible for this data subcategory
  """
  teamIds: [ID!]

  """
  Filter by IDs of recipient categories associated with the catalogs of silos whose subdatapoints have this data subcategory
  """
  saaSCategoryIds: [ID!]

  """
  Filter by the type of retention schedule for subdatapoints with this data subcategory
  """
  retentionTypes: [RetentionType!]

  """The attribute values used to label the data subcategory"""
  attributeValueIds: [ID!]

  """Filter by list of dataSubCategory ids"""
  ids: [ID!]

  """Filter by status of guess"""
  status: SubDataPointDataSubCategoryGuessStatus

  """Filter by data silos whose subdatapoints have this data subcategory"""
  dataSiloIds: [ID!]

  """The sensitive category values associated with the data subcategory"""
  sensitiveCategoryIds: [ID!]
}

"""Detailed info about a data processing subcategory"""
input DataSubCategoryInput {
  """The name of the subcategory"""
  name: String!

  """The category of personal data"""
  category: DataCategoryType!
}

"""Subset of fields for a data subcategory"""
type DataSubCategoryPreview {
  """The ID for the subcategory"""
  id: ID!

  """The name of the subcategory"""
  name: String

  """The category of personal data"""
  category: DataCategoryType!

  """The slug of the category for templating"""
  slug: String!

  """The regex used to identify this data subcategory"""
  regex: String
}

"""A data category that is classified in a set of unstructured text"""
type DataSubCategoryTextMatch {
  """Data category that was matched"""
  category: DataSubCategoryPreview!

  """The list of matching values for that category"""
  values: [TextCategoryPreview!]!
}

"""
A data subject classification that the organization will accept requests for
"""
type DataSubject implements DataSubjectInterface {
  """The UUID for the data subject configuration"""
  id: ID!

  """
  The unique name of the data subject classification within the organization
  """
  type: String!

  """The icon to display with the data subject"""
  icon: String!

  """The classification of data subject"""
  subjectClass: DataSubjectClass!

  """The display title for the data subject class"""
  title: DefinedMessage!

  """
  The instructions that should be shown in the modal as the data subject attempts to login
  """
  loginInstructions: DefinedMessage

  """
  The instructions that should be shown in the modal to instruct the data subject to make the request another way
  """
  disabledInstructions: DefinedMessage

  """The URL where the data subject can login"""
  redirectUrl: DefinedMessage

  """The organization's oauthClientId associated with subjects of this type"""
  oauthClientId: String

  """The oauthScope used to get context for data subjects of this type."""
  oauthScope: String

  """The oauth response type"""
  responseType: String

  """The actions allowed for this data subject"""
  actions: [Action!]!
}

type DataSubjectCommunicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Communication"""
  nodes: [Communication!]!

  """int"""
  totalCount: Int!
}

type DataSubjectConsentPreferencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentRecord"""
  nodes: [ConsentRecord!]!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type DataSubjectDownloadCekPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""
The configuration for a data subject that the organization supports, displayed on the privacy center
"""
interface DataSubjectInterface {
  """The UUID for the data subject configuration"""
  id: ID!

  """
  The unique name of the data subject classification within the organization
  """
  type: String!

  """The icon to display with the data subject"""
  icon: String!

  """The classification of data subject"""
  subjectClass: DataSubjectClass!

  """The display title for the data subject class"""
  title: DefinedMessage!

  """
  The instructions that should be shown in the modal as the data subject attempts to login
  """
  loginInstructions: DefinedMessage

  """
  The instructions that should be shown in the modal to instruct the data subject to make the request another way
  """
  disabledInstructions: DefinedMessage

  """The URL where the data subject can login"""
  redirectUrl: DefinedMessage

  """The organization's oauthClientId associated with subjects of this type"""
  oauthClientId: String

  """The oauthScope used to get context for data subjects of this type."""
  oauthScope: String

  """The oauth response type"""
  responseType: String

  """The actions allowed for this data subject"""
  actions: [Action!]!
}

"""The internal configuration for a data subject"""
type DataSubjectInternal implements DataSubjectInterface {
  """The UUID for the data subject configuration"""
  id: ID!

  """
  The unique name of the data subject classification within the organization
  """
  type: String!

  """The icon to display with the data subject"""
  icon: String!

  """The classification of data subject"""
  subjectClass: DataSubjectClass!

  """The display title for the data subject class"""
  title: DefinedMessage!

  """
  The instructions that should be shown in the modal as the data subject attempts to login
  """
  loginInstructions: DefinedMessage

  """
  The instructions that should be shown in the modal to instruct the data subject to make the request another way
  """
  disabledInstructions: DefinedMessage

  """The URL where the data subject can login"""
  redirectUrl: DefinedMessage

  """The organization's oauthClientId associated with subjects of this type"""
  oauthClientId: String

  """The oauthScope used to get context for data subjects of this type."""
  oauthScope: String

  """The oauth response type"""
  responseType: String

  """The actions allowed for this data subject"""
  actions: [Action!]!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!

  """
  The list of users that are assigned access to view requests for this data subject
  """
  owners: [UserPreview!]!

  """
  The list of teams that are assigned access to view requests for this data subject
  """
  teams: [TeamPreview!]!

  """Whether the data subject is currently turned on"""
  active: Boolean!

  """
  The admin dashboard form for this data subject should result all requests in silent mode when true. This is useful for admin-only workflows.
  """
  adminDashboardDefaultSilentMode: Boolean!

  """The number of open requests for this data subject type"""
  openRequestCount: Int!

  """The number of requests that were fulfilled of this data subject type"""
  fulFilledRequestCount: Int!
}

type DataSubjectUpdateConsentPreferencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentRecord"""
  data: [ConsentRecord!]!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""The query to pass to a database integration to resolve a specific DSR"""
type DbIntegrationQuery {
  """The database query to execute"""
  query: String

  """The suggested database query if different than the original"""
  suggestedQuery: String

  """The request type"""
  requestType: RequestActionObjectResolver!

  """Id of the query"""
  id: ID!
}

"""Suggestion for a new SQL query to run against DSRs"""
input DbIntegrationQuerySuggestionInput {
  """The suggested database query if different than the original"""
  suggestedQuery: String!

  """The request type"""
  requestType: RequestActionObjectResolver!
}

"""Input to decrypt a list of emails"""
input DecryptCommunicationInput {
  """List of communication Ids to decrypt"""
  communicationIds: [ID!]!

  """Whether or not to unwrap attachments"""
  unwrapAttachments: Boolean
}

"""
The contents of an email that are only revealed to the browser or sombra.
"""
type DecryptedEmailAttachment {
  """The filename of the attachment"""
  filename: String!

  """The decryption context for the email attachment contents"""
  content: DecryptionContext!

  """The MIME content type"""
  contentType: String!

  """The size in bytes of the attachment"""
  size: Int!
}

"""
The contents of an email that are only revealed to the browser or sombra.
"""
type DecryptedEmailContents {
  """ID of the email communication"""
  id: ID!

  """The decryption email subject"""
  subject: DecryptionContext

  """The decryption email body"""
  template: DecryptionContext!

  """The decryption contents for all email attachments"""
  attachments: [DecryptedEmailAttachment!]!
}

"""The items needed to decrypt data on the privacy center"""
type DecryptionContext {
  """The wrapped decryption key"""
  wrappedKey: String!

  """The auth tag from oauth"""
  authTag: String!

  """The iv seeded randomness"""
  iv: String!
}

"""
Metadata about a datapoint that can be viewed before connecting the datapoint
"""
type DefaultDataPoint implements DataPointMetadataInterface {
  """URL references to documentation about the datapoint"""
  references: [String!]

  """
        When provided, the datapoint is known to be a subjective lookup and will
      require a person to manually verify the results.
  This is expected to be a list of JSON paths, encoding which fields in the request file should be previewed for redaction.
  """
  subjectivePaths: [String!]

  """
    When provided, there is some sort of limitation to the datapoint that employees
  should be aware of.
  """
  employeeDescription: String

  """Default title for the datapoint"""
  title: String!

  """Default description for the datapoint"""
  description: String!

  """The unique name of the datapoint"""
  name: String!

  """The actions that are allowed on the datapoint"""
  allowedActions: [RequestActionObjectResolver!]!
}

"""Special email templates used in specific parts of the DSR lifecycle"""
type DefaultTemplates {
  """The message to send the data subject when they submit a request"""
  receiptTemplate: Template!

  """The response to use when a request finds no data or performs no action"""
  notFoundTemplate: Template!

  """
    The default template to use when the data subject needs to be notified
  that more time is needed to fulfill their request
  """
  additionalTimeTemplate: Template!

  """
  The template to send to the data subject when they cancel their request
  """
  revokedTemplate: Template!

  """The template to use when canceling a request"""
  cancelationTemplate: Template!

  """The email to send to login"""
  emailLoginTemplate: Template!

  """The template to use when prompting vendors for DSR actions"""
  externalBulkRequestVendorCoordination: Template!

  """The email to send for government ID verification"""
  governmentIdMessageTemplate: Template!
}

"""The message definition"""
type DefinedMessage {
  """A unique identifier for the message"""
  id: String!

  """The default message when no translation exists"""
  defaultMessage: String!

  """A description for the message"""
  description: String
}

type DeleteActionItemCollectionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for bulk deleting one or more action item collections"""
input DeleteActionItemCollectionsInput {
  """The ids of the action item collections"""
  ids: [ID!]!
}

type DeleteActionItemsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for bulk deleting one or more action items"""
input DeleteActionItemsInput {
  """The ids of the action items"""
  ids: [ID!]!
}

type DeleteActionItemSubscriptionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting an actionItemSubscription"""
input DeleteActionItemSubscriptionInput {
  """Whether the subscriptions in this input are org level or user level"""
  orgLevelSubscriptions: Boolean

  """The id of the action item subscription, pass no id to delete all"""
  ids: [ID!]
}

type DeleteAgentFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of agent files"""
input DeleteAgentFilesInput {
  """The id of the agent files to delete"""
  ids: [ID!]

  """The id of the files in the remote system, e.g. the OpenAI file ID"""
  fileIds: [String!]

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String
}

type DeleteAgentFunctionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of agent functions"""
input DeleteAgentFunctionsInput {
  """The id of the agent functions to delete"""
  ids: [ID!]!
}

type DeleteAgentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting agents"""
input DeleteAgentsInput {
  """The id of the agents to delete"""
  ids: [ID!]

  """
  The id of the agents in the remote system, e.g. the OpenAI assistant ID
  """
  agentIds: [String!]

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String
}

type DeleteApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of applications"""
input DeleteApplicationsInput {
  """The id of the applications to delete"""
  ids: [ID!]!
}

type DeleteApplicationUsersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of application users"""
input DeleteApplicationUsersInput {
  """The id of the application users to delete"""
  ids: [ID!]!
}

type DeleteAssessmentAnswerFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment answer files"""
input DeleteAssessmentAnswerFilesInput {
  """The ids of the assessment answers to delete"""
  ids: [ID!]!
}

type DeleteAssessmentAnswerFilesTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""
Input for external users to delete multiple assessment answer files via an auth token
"""
input DeleteAssessmentAnswerFilesTokenInput {
  """The ids of the assessment answers to delete"""
  ids: [ID!]!

  """The token to validate"""
  token: String!
}

type DeleteAssessmentEmailSetsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting assessment email sets"""
input DeleteAssessmentEmailSetsInput {
  """The ids of the assessment email sets to delete"""
  ids: [ID!]!
}

type DeleteAssessmentFormCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment form comments"""
input DeleteAssessmentFormCommentsInput {
  """The ids of the assessment form comments to delete"""
  ids: [ID!]!
}

type DeleteAssessmentFormsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment forms"""
input DeleteAssessmentFormsInput {
  """The id of the assessment forms to delete"""
  ids: [ID!]!
}

type DeleteAssessmentFormTemplatesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment form templates"""
input DeleteAssessmentFormTemplatesInput {
  """The ids of the assessment form templates to delete"""
  ids: [ID!]!
}

type DeleteAssessmentGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment groups"""
input DeleteAssessmentGroupsInput {
  """The id of the assessment groups to delete"""
  ids: [ID!]!
}

type DeleteAssessmentQuestionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment question comments"""
input DeleteAssessmentQuestionCommentsInput {
  """The ids of the assessment question comments to delete"""
  ids: [ID!]!
}

type DeleteAssessmentQuestionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment questions"""
input DeleteAssessmentQuestionsInput {
  """The ids of the assessment questions to delete"""
  ids: [ID!]!
}

type DeleteAssessmentSectionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment section comments"""
input DeleteAssessmentSectionCommentsInput {
  """The ids of the assessment section comments to delete"""
  ids: [ID!]!
}

type DeleteAssessmentSectionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting multiple assessment sections"""
input DeleteAssessmentSectionsInput {
  """The ids of the assessment sections to delete"""
  ids: [ID!]!
}

type DeleteAttributeKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting an AttributeKey"""
input DeleteAttributeKeyInput {
  """The id of the attribute key to delete"""
  id: ID!
}

type DeleteAttributeValuePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteAuditorSchedulesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of Web Auditor schedules"""
input DeleteAuditorSchedulesInput {
  """The id of the assessments to delete"""
  ids: [ID!]!
}

type DeleteBusinessEntitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting business entities"""
input DeleteBusinessEntitiesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteCodePackagesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a set of code packages"""
input DeleteCodePackagesInput {
  """The id of the code packages to delete"""
  ids: [ID!]!
}

"""Input for deleting consent applications by ID"""
input DeleteConsentApplicationInput {
  """ID of the consent application to delete"""
  ids: [ID!]!
}

type DeleteConsentApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteConsentPartitionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting consent sdks by ID"""
input DeleteConsentSdkInput {
  """ID of the airgap bundle this SDK belongs to"""
  airgapBundleId: ID!

  """ID of the consent sdks to delete"""
  ids: [ID!]!
}

type DeleteConsentSdksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteConsentServicesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting consent services by ID"""
input DeleteConsentServicesInput {
  """ID of the airgap bundle that this consent service belongs to"""
  airgapBundleId: ID!

  """IDs of the consent services to delete"""
  ids: [ID!]!
}

type DeleteConsentSitePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting consent sites by ID"""
input DeleteConsentSiteInput {
  """ID of the consent site record to delete"""
  id: ID!
}

type DeleteConsentWorkflowTriggersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting Consent Workflow Triggers"""
input DeleteConsentWorkflowTriggersInput {
  """ID of the consent workflow trigger to delete"""
  ids: [ID!]!
}

type DeleteContractsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteContractScansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of contract scans"""
input DeleteContractScansInput {
  """The id of the contract scans to delete"""
  ids: [ID!]!
}

"""Input for deleting a group of contracts"""
input DeleteContractsInput {
  """The id of the contracts to delete"""
  ids: [ID!]!
}

type DeleteCookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input to delete cookies"""
input DeleteCookiesInput {
  """The airgap bundle to delete the cookies for"""
  airgapBundleId: ID!

  """Delete cookies with ID in this list"""
  ids: [ID!]

  """The status of this cookie"""
  status: ConsentTrackerStatus
}

type DeleteDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input to delete data flows"""
input DeleteDataFlowsInput {
  """The airgap bundle to delete the data flows for"""
  airgapBundleId: ID!

  """Delete data flows with ID in this list"""
  ids: [ID!]

  """Delete data flows with this status"""
  status: ConsentTrackerStatus
}

type DeleteDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of datapoints"""
input DeleteDataPointsInput {
  """The id of the datapoint to update"""
  ids: [ID!]!
}

type DeleteDataReportsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting data reports for an organization"""
input DeleteDataReportsInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteDataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting data silos for an organization"""
input DeleteDataSilosInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteDataSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""
Input for deleting Data Subcategories from an organization's Data Inventory
"""
input DeleteDataSubCategoriesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteEmailDomainPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteEmailSenderAddressPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input to update email sender addresses"""
input DeleteEmailSenderAddressInput {
  """The address id"""
  id: ID!
}

type DeleteEnricherPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteExperiencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to delete a list of experiences via experience id"""
input DeleteExperiencesInput {
  """The IDs of the Experiences to delete."""
  ids: [ID!]!
}

type DeleteIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Delete a set of identifiers"""
input DeleteIdentifiersInput {
  """The identifier text filter"""
  ids: [ID!]!

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type DeleteLegalHoldsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting legal holds"""
input DeleteLegalHoldsInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteLegalMattersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting legal matters"""
input DeleteLegalMattersInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeletePathfinderPoliciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of pathfinder policies"""
input DeletePathfinderPoliciesInput {
  """The id of the pathfinder policies to delete"""
  ids: [ID!]!
}

type DeletePathfindersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a set of pathfinders"""
input DeletePathfindersInput {
  """The id of the pathfinders to delete"""
  ids: [ID!]!
}

type DeletePoliciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Make changes to the global Privacy Center configuration"""
input DeletePoliciesInput {
  """The ID of the Privacy Center to update"""
  privacyCenterId: ID!

  """The IDs of the policies to delete"""
  ids: [ID!]!

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type DeletePreferenceOptionValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting multiple preference option values"""
input DeletePreferenceOptionValuesInput {
  """IDs of the preference option values to delete"""
  ids: [ID!]!
}

type DeletePreferenceTopicsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting a preference"""
input DeletePreferenceTopicsInput {
  """ID of the preference topic to delete"""
  ids: [ID!]!
}

type DeleteProcessingActivitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting processing activities"""
input DeleteProcessingActivitiesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteProcessingPurposeSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeletePromptGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of group prompts"""
input DeletePromptGroupsInput {
  """The id of the group prompts to delete"""
  ids: [ID!]!
}

type DeletePromptPartialsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of partial prompts"""
input DeletePromptPartialsInput {
  """The id of the partial prompts to delete"""
  ids: [ID!]!
}

type DeletePromptsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of prompts"""
input DeletePromptsInput {
  """The id of the prompts to delete"""
  ids: [ID!]!
}

type DeletePromptThreadsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of prompt threads"""
input DeletePromptThreadsInput {
  """The id of the prompt threads to delete"""
  ids: [ID!]!
}

type DeletePullRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a set of pull requests"""
input DeletePullRequestsInput {
  """The id of the pull requests to delete"""
  ids: [ID!]!
}

type DeletePurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to delete existing consent purposes for an organization"""
input DeletePurposesInput {
  """The ids of the purposes"""
  ids: [ID!]!
}

"""
Input for deleting Processing Purpose Subcategories from an organization's Data Inventory
"""
input DeletePurposeSubCategoriesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteRepositoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a set of repositories"""
input DeleteRepositoriesInput {
  """The id of the repositories to delete"""
  ids: [ID!]!
}

type DeleteRequestFilePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteRequestFileTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting requests from an org"""
input DeleteRequestsInput {
  """ID of the organization to delete from"""
  organizationId: ID!

  """IDs of requests to delete"""
  requestIds: [ID!]!
}

type DeleteRiskCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting risk categories"""
input DeleteRiskCategoriesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteRiskFrameworksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting risk frameworks"""
input DeleteRiskFrameworksInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteSensitiveCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting sensitive categories"""
input DeleteSensitiveCategoriesInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteSoftwareDevelopmentKitsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a set of software development kits"""
input DeleteSoftwareDevelopmentKitsInput {
  """The id of the software development kits to delete"""
  ids: [ID!]!
}

type DeleteSubDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a group of subdatapoints"""
input DeleteSubDataPointsInput {
  """The id of the subdatapoint to update"""
  ids: [ID!]!
}

type DeleteSubjectPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteTeamPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteTemplatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeleteVendorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for deleting vendors"""
input DeleteVendorsInput {
  """The list of IDs to delete"""
  ids: [ID!]!
}

type DeleteWorkflowPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for deleting a workflow"""
input DeleteWorkflowInput {
  """The ID of the workflow config to delete"""
  workflowConfigId: ID!
}

"""
Submit a demo request. This is not our real demo form and is used for testing.
"""
type Demo {
  """The unique id of the demo request"""
  id: ID!

  """The email of the person requesting the demo"""
  email: String!

  """The name of the person requesting the demo"""
  name: String

  """
  The page they were on when requesting a demo (this indicates which banner they saw)
  """
  pathname: String
}

"""
Submit a demo request. This is not our real demo form and is used for testing.
"""
input DemoInput {
  """The email of the person requesting the demo"""
  email: String!

  """The name of the company"""
  companyName: String!

  """
  The page they were on when requesting a demo (this indicates which banner they saw)
  """
  pathname: String

  """The number of european data subjects"""
  dataSubjects: Int

  """The name of the person requesting the demo"""
  name: String
}

type DeployCloudfrontPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type DeployConsentManagerBundlePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""
[DEPRECATED] The options for deploying/publishing changes to the consent manager
"""
input DeployConsentManagerInput {
  """
  Whether to update the "test" consent manager bundle hosted at /cm-test. Or to update the "production" consent manager bundle hosted at /cm.  Defaults to updating the production bundle.
  """
  bundleType: ConsentBundleType
}

type DeployPrivacyCenterVersionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for querying a privacy center version from the admin dashboard"""
input DeployPrivacyCenterVersionInput {
  """ID of the privacy center version"""
  privacyCenterVersionId: ID!
}

"""Input for creating a new request identifier"""
input DeprecatedRequestIdentifierInput {
  """The name of the custom identifier"""
  name: String

  """The value of the identifier"""
  value: String!
}

"""
Deprecated: The identifiers associated with the request (list version of `RequestIdentifierValue`)
"""
input DeprecatedRequestIdentifiersInput {
  """
  The email identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  email: [DeprecatedRequestIdentifierInput!]

  """
  The phone identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  phone: [DeprecatedRequestIdentifierInput!]

  """The core identifier (list but always 0 or 1)"""
  coreIdentifier: [DeprecatedRequestIdentifierInput!]

  """Custom defined identifiers for the data subject"""
  custom: [DeprecatedRequestIdentifierInput!]

  """
  The gaid identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  gaid: [DeprecatedRequestIdentifierInput!]

  """
  The idfa identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  idfa: [DeprecatedRequestIdentifierInput!]

  """
  The idfv identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  idfv: [DeprecatedRequestIdentifierInput!]

  """
  The browserId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  browserId: [DeprecatedRequestIdentifierInput!]

  """
  The microsoftAdvertisingId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  microsoftAdvertisingId: [DeprecatedRequestIdentifierInput!]

  """
  The amazonFireAdvertisingId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  amazonFireAdvertisingId: [DeprecatedRequestIdentifierInput!]

  """
  The rida identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  rida: [DeprecatedRequestIdentifierInput!]

  """
  The filestackHandle identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  filestackHandle: [DeprecatedRequestIdentifierInput!]

  """
  The stripeId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  stripeId: [DeprecatedRequestIdentifierInput!]

  """
  The braintreeCustomerId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  braintreeCustomerId: [DeprecatedRequestIdentifierInput!]

  """
  The chargebeeId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  chargebeeId: [DeprecatedRequestIdentifierInput!]

  """
  The thriveTrmContactId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  thriveTrmContactId: [DeprecatedRequestIdentifierInput!]

  """
  The talkableUUID identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  talkableUUID: [DeprecatedRequestIdentifierInput!]

  """
  The recurlyId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  recurlyId: [DeprecatedRequestIdentifierInput!]

  """
  The customerIoId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  customerIoId: [DeprecatedRequestIdentifierInput!]

  """
  The sprigVisitorId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  sprigVisitorId: [DeprecatedRequestIdentifierInput!]

  """
  The linkedInURL identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  linkedInURL: [DeprecatedRequestIdentifierInput!]

  """
  The advertisingId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  advertisingId: [DeprecatedRequestIdentifierInput!]

  """
  The personaReferenceId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  personaReferenceId: [DeprecatedRequestIdentifierInput!]

  """
  The streamUserId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  streamUserId: [DeprecatedRequestIdentifierInput!]

  """
  The plaidProcessorToken identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  plaidProcessorToken: [DeprecatedRequestIdentifierInput!]

  """
  The onfidoApplicantId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  onfidoApplicantId: [DeprecatedRequestIdentifierInput!]

  """
  The veroUserId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  veroUserId: [DeprecatedRequestIdentifierInput!]

  """
  The adobeAdvertisingCloudId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  adobeAdvertisingCloudId: [DeprecatedRequestIdentifierInput!]

  """
  The adobeAudienceManagerId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  adobeAudienceManagerId: [DeprecatedRequestIdentifierInput!]

  """
  The adobeExperienceCloudId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  adobeExperienceCloudId: [DeprecatedRequestIdentifierInput!]

  """
  The adobeTargetId identifiers for the data subject. This identifier type is natively supported by Transcend.
  """
  adobeTargetId: [DeprecatedRequestIdentifierInput!]
}

type DestroyAccountPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for destroying a user"""
input DestroyUserInput {
  """The password of the user"""
  password: String!
}

type DetermineLoginMethodPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Information about how that email can login"""
  loginMethod: LoginMethod!
}

type DisableExperiencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to enable/disable a list of experiences via experience id"""
input DisableExperiencesInput {
  """The IDs of the Experiences to disable."""
  ids: [ID!]!

  """Whether the regional experience is active for an organization"""
  isActive: Boolean
}

type DisableUserAccountPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""A discovery and classification scan"""
type DiscoClassScan {
  """The ID of the disco class scan"""
  id: ID!

  """The configuration for the scan"""
  discoClassScanConfig: DiscoClassScanConfig!

  """The scan type"""
  type: DiscoClassScanType!

  """The status of the scan"""
  status: DiscoClassScanStatus!

  """When the scan started"""
  startedAt: Date!

  """When the scan completed"""
  completedAt: Date
}

"""A configuration for a disco class scan"""
type DiscoClassScanConfig {
  """The ID of the disco class scan config"""
  id: ID!

  """The ID of the data silo this scan belongs to"""
  dataSiloId: ID!

  """The scan type"""
  type: DiscoClassScanType!

  """If the scan is enabled"""
  enabled: Boolean!

  """How frequently the scan should be run in milliseconds"""
  scheduleFrequency: Int!

  """The ID of the last disco class scan"""
  lastDiscoClassScanId: ID

  """When the next scan should start (null if disabled)"""
  scheduleStartAt: Date

  """The last disco class scan"""
  lastDiscoClassScan: DiscoClassScanPreview
}

"""Input for a disco class scan config query"""
input DiscoClassScanConfigQueryInput {
  """The ID of the data silo to query"""
  dataSiloId: ID!
}

"""Filters for a disco class scan config query"""
input DiscoClassScanFiltersInput {
  """The ID of the data silo to query"""
  dataSiloId: ID

  """The scan type"""
  type: DiscoClassScanType

  """The status of the scan"""
  status: DiscoClassScanStatus
}

"""The latest disco class scan info"""
type DiscoClassScanPreview {
  """The scan type"""
  type: DiscoClassScanType!

  """The status of the scan"""
  status: DiscoClassScanStatus!

  """When the scan started"""
  startedAt: Date!

  """When the scan completed"""
  completedAt: Date
}

type DiscoClassScansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DiscoClassScan"""
  nodes: [DiscoClassScan!]!

  """int"""
  totalCount: Int!
}

"""A preview of the plugin that found the data silo"""
type DiscoveredByDataSiloPreview {
  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """A preview of the attached catalog"""
  catalog: CatalogPreview!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID
}

"""Input for the display logic of an assessment question"""
input DisplayLogicInput {
  """The action to take"""
  action: AssessmentsDisplayLogicAction!

  """The rule to evaluate"""
  rule: RuleInput

  """The nested rule to evaluate"""
  nestedRule: NestedRuleInput
}

"""A downloadable encrypted file associated with a request"""
type DownloadFile implements RequestFileInterface {
  """
  The file size in bytes as a string because graphql does not play well with larger numbers
  """
  size: String!

  """The mimetype of the file"""
  mimetype: String!

  """The unique id of the request file"""
  id: ID!

  """The URL to download the file"""
  downloadUrl: String!

  """The name of the file once downloaded"""
  fileName: String!

  """The authTag of the encrypted file"""
  authTag: String!

  """The iv randomness of the encrypted file"""
  iv: String!

  """Stringified redaction indices"""
  redactIndices: String!

  """The title of the file"""
  title: DefinedMessage

  """The description of the file"""
  description: DefinedMessage
}

"""A file count associated with a request"""
type DownloadFileCounts {
  """The id of the dataPoint"""
  dataPointId: String!

  """The name of the datapoint"""
  name: String!

  """The title of the file"""
  title: DefinedMessage

  """The number of files associated with the datapoint"""
  fileCount: Int!
}

"""The input for filtering downloadFiles"""
input DownloadFileFiltersInput {
  """The id of the request to get files for."""
  requestId: ID!

  """The id of the data collection to get files for"""
  dataCollectionId: ID
}

"""The order for a DownloadFile query"""
input DownloadFileOrder {
  """The field that the DownloadFile nodes should be ordered by"""
  field: DownloadFileOrderField!

  """
  The direction in which to order the DownloadFile nodes by the specified field
  """
  direction: OrderDirection!
}

type DownloadFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DownloadFile"""
  nodes: [DownloadFile!]!

  """int"""
  totalCount: Int!

  """string"""
  totalSize: String!
}

type DownloadFilesCountsOnlyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DownloadFileCounts"""
  nodes: [DownloadFileCounts!]!
}

"""
Represents a change in a consent or communication purpose for a request
"""
type DsrPurposeChange {
  """The boolean value of the consent that was changed for this purpose"""
  consent: Boolean!

  """The display title of the purpose change"""
  title: String!

  """The unique name of the purpose ame"""
  name: String!

  """
  The set of preferences tied to the purpose change event - this is a JSON object stringified
  """
  preferences: String!

  """The set of preference options enriched with metadata"""
  enrichedPreferences: [EnrichedPreference!]!
}

type DuplicateApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A newly created api key that exposes the key for one time only"""
  apiKey: CreatedApiKey!
}

"""Domains from which Transcend can send emails"""
type EmailDomain {
  """The domain id"""
  id: ID!

  """The customer domain name"""
  domain: String!

  """The current status of the domain verification process"""
  domainVerificationStatus: EmailDomainVerificationStatus!

  """The current status of the DKIM settings verification process"""
  dkimVerificationStatus: EmailDomainVerificationStatus!

  """The current status of the receive MX settings verification process"""
  receiveVerificationStatus: EmailDomainVerificationStatus!

  """The verification token for the domain"""
  domainToken: String

  """The verification tokens for dkim validation"""
  dkimTokens: [String!]

  """The MX record value to set in order to receive email"""
  receiveMx: String!
}

"""Input for adding an email domain"""
input CreateEmailDomainInput {
  """the customer domain name"""
  domain: String!
}

"""Input to make a login attempt into a privacy center"""
input EmailLoginInput {
  """The email of the person requesting the login"""
  email: String!

  """The action the user clicked into prior to email login flow"""
  action: RequestAction

  """The data subject ID that is being logged in as"""
  dataSubjectId: ID!

  """The path the user was on when they clicked the login button"""
  path: String

  """The region that the request was submitted in"""
  region: RegionInput

  """The login state to return after successful email verification"""
  loginState: PrivacyCenterEmailLoginState
}

"""Email addresses from which Transcend can send emails"""
type EmailSenderAddress {
  """The address id"""
  id: ID!

  """The internal name of this email address"""
  name: String!

  """The priority of this email address"""
  priority: Int!

  """The email prefix"""
  fromPrefix: String

  """The reply-to email"""
  replyTo: String

  """The pretty email alias"""
  alias: String

  """The pretty display name for inside the email body"""
  displayName: String

  """The request attribute values corresponding to this email address"""
  attributeValues: [ID!]!
}

type EmployeeDownloadCekPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type EmployeeMakeDataSubjectRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

type EmployeeMakeDataSubjectRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Request"""
  requests: [Request!]!
}

"""
Input for an employee to submit a data subject request on behalf of the data subject
"""
input EmployeeRequestInput {
  """The unique name of the organization's data subject class"""
  subjectType: String!

  """The type of data subject request"""
  type: RequestAction!

  """The identifiers to key the data subject by that need to be verified"""
  requestIdentifiers: DeprecatedRequestIdentifiersInput

  """The locale to translate the request it"""
  locale: String

  """Misc details from the data subject about their request"""
  details: String

  """The region that the request was submitted in"""
  region: RegionInput

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """When true, no emails should be sent to the data subject"""
  isSilent: Boolean

  """The ID of the request to re-submit."""
  requestId: ID

  """When true, request is a test request"""
  isTest: Boolean

  """When true, do not send a receipt email"""
  skipSendingReceipt: Boolean

  """The ID of the email template to send"""
  emailReceiptTemplateId: ID

  """When true, skip any waiting period associated with the workflow."""
  skipWaitingPeriod: Boolean

  """
  The IDs of the enrichment checks that should be skipped on this workflow
  """
  skipEnrichmentChecks: [ID!]

  """
  When uploading a backlog of old privacy requests for the purposes of audit history, set this status to create a request that is in a completed state.
  """
  completedRequestStatus: CompletedRequestStatus

  """
  Specify a time when the request was made, else assumes time of submission.
  """
  createdAt: String

  """
  A set of email addresses that should be CC'd on any communications send for that request.
  """
  replyToEmailAddresses: [String!]

  """The data silos to process for this request"""
  dataSiloIds: [ID!]

  """
  The set of data silo IDs that should NOT be processed. When specified, the default set of data silos will be calculated and then these IDs will be subtracted from that list.
  """
  ignoreDataSiloIds: [ID!]

  """The id of the parent request"""
  parentId: ID

  """Attribute Values to label requests"""
  attributes: [AttributeInput!]

  """
  The partition key that this DSR is kicked off for (often the data controller in context)
  """
  partitionKey: String

  """The workflow config to use for this request"""
  workflowConfigId: ID
}

type EmployeeReSignEncryptedCekContextsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  done: Boolean!
}

type EmployeeUpdateConsentPreferencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of EnrichedConsentRecordSchema"""
  data: [EnrichedConsentRecordSchema!]!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type EmployeeUpdateRequestIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A request enrichment that needs to be responded to"""
  requestEnricher: RequestEnricher!
}

"""Input for an employee to update the identifiers on a request"""
input EmployeeUpdateRequestIdentifiersInput {
  """The id of the request enricher to update"""
  requestEnricherId: ID

  """The id of the request to update"""
  requestId: ID
}

type EnableUserAccountPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Enriched record of consent preferences"""
type EnrichedConsentRecordSchema {
  """Primary key of the consent preference record"""
  encryptedIdentifier: String!

  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """purposes"""
  purposes: [EnrichedPurposeSchema!]!

  """Most recent consent event timestamp (ISO 8601)"""
  timestamp: String!

  """US IAB Privacy String"""
  usp: String

  """IAB GPP String, encoding both USP and USNAT"""
  gpp: String

  """IAB TCF String"""
  tcf: String

  """Airgap Version"""
  airgapVersion: String

  """Metadata"""
  metadata: String

  """Last-modified for metadata timestamp (ISO 8601)"""
  metadataTimestamp: String

  """Last record modification timestamp (ISO 8601)"""
  updatedAt: String

  """The identifiers of the user"""
  identifiers: [PreferenceStoreIdentifierSchema!]!
}

"""Represents a preference with all metadata enriched"""
type EnrichedPreference {
  """A unique ID for the preference change"""
  id: String!

  """The unique name of the preference option slug"""
  name: String!

  """The single select value of the preference"""
  selectValue: EnrichedPreferenceOption

  """The boolean value of the preference"""
  booleanValue: Boolean

  """The multi select values of the preference"""
  selectValues: [EnrichedPreferenceOption!]

  """
  The preference topic metadata for this. If not provided, this may have been deleted
  """
  preferenceTopic: PreferenceTopicPreview
}

"""Represents a preference option with all metadata enriched"""
type EnrichedPreferenceOption {
  """A unique ID for the preference option change"""
  id: String!

  """The unique name of the preference option slug"""
  name: String!

  """The preference option metadata. If not provided, this is deleted"""
  preferenceOption: PrivacyCenterPreferenceOptionValue
}

"""purpose"""
type EnrichedPurposeSchema {
  """Tracking purpose"""
  purpose: String!

  """Whether the user has given consent for this purpose"""
  consent: Boolean!

  """User preferences for this purpose"""
  preferences: [EnrichedPreference!]
}

"""
An enricher is takes in an identifier, and resolves additional identifiers keyed to the input identifier.
"""
type Enricher {
  """The unique id of the enricher"""
  id: ID!

  """The identifying title of the enricher"""
  title: String!

  """The description of the enricher"""
  description: String!

  """The logo icon display"""
  logo: String!

  """The user that is responsible for resolving the enricher"""
  user: UserPreview

  """The identifier that can be output from the enricher"""
  identifiers: [WiredIdentifier!]!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The mapping of identifier name to identifier JSON path"""
  signedIdentifierPaths: [SignedIdentifierPath!]!

  """The type of enricher"""
  type: EnricherType!

  """The url of the enricher (when an api request)"""
  url: String

  """The identifier that is the input to the enricher, null if initializer"""
  inputIdentifier: WiredIdentifier

  """The twilio phone number to send from"""
  phoneNumbers: [String!]!

  """
  Slug of the database name to run for this enricher. This is only needed for certain database enrichers, such as googleCloudSpanner, that require SQL statements to be scoped to a specific database.
  """
  databaseName: String

  """Title of the looker query to run for this enricher"""
  lookerQueryTitle: String

  """Slug of the looker query to run for this enricher"""
  lookerQuerySlug: String

  """The related data silo"""
  dataSilo: DataSiloPreview

  """A regular expression that can be used to match on for cancelation"""
  testRegex: String

  """The list of regions that should trigger the enrichment condition"""
  regionList: [String!]!

  """The duration (in ms) that the enricher should take to execute."""
  expirationDuration: String!

  """
  The duration (in ms) to wait between sending verification and first reminder.
  """
  reminderTemplate1Duration: String!

  """
  The duration (in ms) to wait between sending first reminder and second reminder.
  """
  reminderTemplate2Duration: String!

  """
  The duration (in ms) to wait between sending second reminder and third reminder. As well as any other reminder until the expiration occurs.
  """
  reminderTemplate3Duration: String!

  """The status that the enricher should transfer to when condition is met."""
  transitionRequestStatus: PreflightRequestStatus

  """
  The communication template that is used to verify the identifier, or run cancelation/on hold
  """
  template: Template

  """
  The communication template that is used when continuing the request after failure to verify
  """
  continuationTemplate: Template

  """
  The communication template that is used when canceling the request after failure to verify
  """
  requestVerificationFailedTemplate: Template

  """The data subjects explicitly configured for this enricher"""
  dataSubjects: [DataSubject!]!

  """The actions that this enricher runs for"""
  actions: [RequestAction!]!

  """The number of open errors with the enricher"""
  errorCount: Int!

  """The enricher dependencies for the enricher"""
  enricherDependencies: [EnricherPreview!]

  """SQL query to run for this enricher"""
  sqlQuery: String

  """Test the enricher"""
  EnricherCrossReferenceIdentifiers: [EnricherCrossReferenceIdentifier!]

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""The identifier/cross reference details for an enricher"""
type EnricherCrossReferenceIdentifier {
  """The unique id of the enricher"""
  id: ID!

  """The key to cross reference the identifier against"""
  crossReferenceKey: String!

  """The identifier to cross reference"""
  identifier: WiredIdentifier!
}

"""Filters for the paginated enrichers list"""
input EnricherFiltersInput {
  """Search text"""
  text: String

  """The type of enrichers"""
  type: [EnricherType!]

  """The actions that this enricher runs for"""
  actionTypes: [RequestAction!]

  """The IDs of the explicit data subjects that the enricher should run for"""
  dataSubjectIds: [ID!]
}

"""Input for creating a new enricher"""
input EnricherInput {
  """The type of enricher"""
  type: EnricherType!

  """The title of the enricher for reference"""
  title: String!

  """The description of the enricher"""
  description: String!

  """The ID of the related data silo (i.e. looker or twilio integration"""
  dataSiloId: ID

  """The url that the enricher should post to when a server"""
  url: String

  """The IDs of the explicit data subjects that the enricher should run for"""
  dataSubjectIds: [ID!]

  """The mapping between identifier name and JSON path for identifier"""
  signedIdentifierInputs: [SignedIdentifierPathInput!]

  """A regular expression that can be used to match on for cancelation"""
  testRegex: String

  """The list of regions that should trigger the enrichment condition"""
  regionList: [String!]

  """The duration (in ms) that the enricher should take to execute."""
  expirationDuration: String

  """
  The duration (in ms) to wait between sending verification and first reminder.
  """
  reminderTemplate1Duration: String

  """
  The duration (in ms) to wait between sending first reminder and second reminder.
  """
  reminderTemplate2Duration: String

  """
  The duration (in ms) to wait between sending second reminder and third reminder.
  """
  reminderTemplate3Duration: String

  """The status that the enricher should transfer to when condition is met."""
  transitionRequestStatus: PreflightRequestStatus

  """The ID of template to use for that identifier verification"""
  templateId: ID

  """
  The ID of template to use for notifying data subject about continuing request without an identifier
  """
  continuationTemplateId: ID

  """
  The ID of template to use for notifying data subject about their request being canceled
  """
  requestVerificationFailedTemplateId: ID

  """
  Slug of the database name to run for this enricher. This is only needed for certain database enrichers, such as googleCloudSpanner, that require SQL statements to be scoped to a specific database.
  """
  databaseName: String

  """
  The id of the user that is responsible for the enricher when a person enricher
  """
  userId: ID

  """The ID of the identifier that will be the input to the enricher"""
  inputIdentifier: ID!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeaderInput!]

  """
  The IDs of the identifiers that can possibly be output from the enricher
  """
  identifiers: [ID!]!

  """The action types that the enricher should run for"""
  actions: [RequestAction!]!

  """Phone numbers from twilio"""
  phoneNumbers: [String!]

  """Title of the looker query to run for this enricher"""
  lookerQueryTitle: String

  """Slug of the looker query to run for this enricher"""
  lookerQuerySlug: String

  """IDs of the enricher dependency"""
  enricherDependencyIds: [ID!]

  """Map of verification output keys to identifier ids"""
  verificationMap: [EnricherVerificationMapInput!]
}

"""The interface for identifying data silo details"""
interface EnricherInterface {
  """The id of the enricher configuration"""
  id: ID!

  """The enricher's title"""
  title: String!

  """The enricher's description"""
  description: String

  """The logo icon display"""
  logo: String!

  """The type of enricher"""
  type: EnricherType!
}

"""The order for a Enricher query"""
input EnricherOrder {
  """The field that the Enricher nodes should be ordered by"""
  field: EnricherOrderField!

  """
  The direction in which to order the Enricher nodes by the specified field
  """
  direction: OrderDirection!
}

"""Preview of an enricher"""
type EnricherPreview implements EnricherInterface {
  """The id of the enricher configuration"""
  id: ID!

  """The enricher's title"""
  title: String!

  """The enricher's description"""
  description: String

  """The logo icon display"""
  logo: String!

  """The type of enricher"""
  type: EnricherType!
}

type EnrichersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Enricher"""
  nodes: [Enricher!]!

  """int"""
  totalCount: Int!
}

"""Map of Stripe verification output keys to identifier ids"""
input EnricherVerificationMapInput {
  """The key of the verification output"""
  crossReferenceKey: String!

  """The identifier id that the verification output should be mapped to"""
  identifierId: ID!
}

"""Metadata used for configuring an enricher"""
type EnrichmentMetadata {
  """The JSON paths that can be configured for that enricher"""
  identifierJsonPaths: [IdentifierJsonPath!]!
}

"""Compare environment variables between sombra and backend"""
type EnvComparison {
  """The value on sombra"""
  sombra: String!

  """The value on the backend"""
  transcend: String!

  """The name of the env var"""
  name: String!
}

type ExecutePromptRunPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An instance of running a prompt"""
  promptRun: PromptRun!
}

"""Input for executing a prompt"""
input ExecutePromptRunInput {
  """
  The name of the prompt run (specified in API or derived from the file input)
  """
  name: String!

  """The content to scan"""
  content: String!

  """The product area that the prompt run is a part of"""
  productArea: PromptRunProductArea!

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """The id of the prompt being executed"""
  promptId: ID!

  """The id of the prompt group being executed"""
  promptGroupId: ID

  """
  The additional variables to template into the prompt. JSON data is stringified.
  """
  variables: [PromptRunVariableInput!]

  """The id of the large language model being executed"""
  largeLanguageModelId: ID
}

"""
A set of transcend configurations for an organization defined set of regions
"""
type Experience {
  """The unique UUID of the experience"""
  id: ID!

  """The name of the experience"""
  name: String!

  """The name of the experience"""
  displayName: String!

  """A list of regions to be included/not included in this experience"""
  regions: [Region!]!

  """
  Whether the listed regions are included or excluded from the experience
  """
  operator: RegionsOperator!

  """
  If data subject linked to multiple experiences, display priority for experiences. Lower number, higher priority.
  """
  displayPriority: Int!

  """The view state to display on transcend.showConsentManager()"""
  viewState: InitialViewState!

  """The UI module to use"""
  ui: ConsentManagerUI

  """A list of tracking purposes associated with this experience"""
  purposes: [TrackingPurpose!]!

  """
  A list of tracking purposes associated with this experience that will be opted out by default
  """
  optedOutPurposes: [TrackingPurpose!]!

  """A list of browser languages that this experience applies to"""
  browserLanguages: [String!]!

  """A list of browser time zones that this experience applies to"""
  browserTimeZones: [String!]!

  """Set of iab signals to communicate"""
  iabSignals: [IABSignal!]!

  """Time in months after which a user's opt-in consent should expire"""
  consentExpiry: Int!

  """Action taken when the user's consent has expired"""
  onConsentExpiry: OnConsentExpiry!

  """Whether the regional experience is active for an organization"""
  isActive: Boolean!
}

"""Filter experiences"""
input ExperienceFiltersInput {
  """Filter by text"""
  text: String

  """Filter by regions"""
  regions: [RegionInput!]

  """Whether listed regions are excluded or included in experience"""
  operator: RegionsOperator

  """Filter by language"""
  browserLanguages: [String!]

  """Filter by time zones"""
  browserTimeZones: [String!]

  """Filter by whether the experience is active"""
  isActive: Boolean
}

"""The order for a Experience query"""
input ExperienceOrder {
  """The field that the Experience nodes should be ordered by"""
  field: ExperienceOrderField!

  """
  The direction in which to order the Experience nodes by the specified field
  """
  direction: OrderDirection!
}

type ExperiencesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Experience"""
  nodes: [Experience!]!

  """int"""
  totalCount: Int!
}

type ExpireSombraApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""A pair of access and refresh tokens"""
type ExternalAccessTokenPair {
  """encrypted access token string"""
  token: String!

  """encrypted refresh token string"""
  refreshToken: String

  """expiry for refresh"""
  expiresIn: String
}

"""A feature that can be enabled/disabled/configured for an organization"""
type Feature {
  """The id of feature."""
  id: ID!

  """The user who last opted in or out of the beta feature."""
  lastEditor: UserPreview

  """The definition of the feature"""
  definition: FeatureDefinition!

  """Whether the organization opted into the beta feature."""
  isBetaEnabled: Boolean

  """The date the organization opted into the beta feature."""
  betaUpdatedAt: Date

  """The CX-chosen value for a boolean feature"""
  valueBoolean: Boolean

  """The CX-chosen value for a string list feature"""
  valueStringList: [String!]

  """The CX-chosen value for a number feature"""
  valueNumber: Int

  """The CX-chosen value for a support feature gate feature"""
  valueFeatureGate: FeatureGate

  """The CX-chosen value for a support tier feature"""
  valueSupportTier: SupportTier
}

"""A definition of a feature that can be enabled/disabled/configured"""
type FeatureDefinition {
  """The id of the feature definition."""
  id: ID!

  """The name of the feature."""
  featureName: FeatureDefinitionName!

  """The maturity status of the feature."""
  status: FeatureStatus!
}

"""Features allowed for an organization"""
type FeatureSet {
  """
  If true, an organization can pull from our private docker registry. This is useful for companies not on AWS
  """
  allowPrivateDockerRegistryAccess: Boolean!

  """
  If true, an organization can white label the emails that are sent to the data subject during a privacy request
  """
  whiteLabelPrivacyRequestEmails: Boolean!

  """
  If true, an organization can white label the emails that are sent to the data subject during a privacy request
  """
  whiteLabelPrivacyCenter: Boolean!

  """
  If true, the "about transcend" page will be disabled on the Privacy Center. The "show me" side menu item will also be disabled
  """
  disabledPrivacyCenterAboutTranscend: Boolean!

  """Whether or not the organization is a sandbox-only account"""
  isSandbox: Boolean!

  """The assessments feature"""
  assessments: FeatureGate!

  """The prompts feature"""
  prompts: FeatureGate!

  """The privacy center feature"""
  privacyCenter: FeatureGate!

  """Access to the selfHostedSombra feature"""
  selfHostedSombra: FeatureGate!

  """The level of support that the customer has purchased"""
  supportTier: SupportTier!

  """The monthly usage limit for auditor runs"""
  auditorMonthlyUsageLimit: Int!

  """The monthly usage limit for Transcend hosted prompt manager runs"""
  transcendHostedPromptManagerMonthlyUsageLimit: Int!

  """Access to the dataLineage feature"""
  dataLineage: FeatureGate!

  """Access to the siloDiscovery feature"""
  siloDiscovery: FeatureGate!

  """Access to the structuredDataDiscovery feature"""
  structuredDataDiscovery: FeatureGate!

  """Access to the unstructuredDataDiscovery feature"""
  unstructuredDataDiscovery: FeatureGate!

  """Access to the discoClassScan feature"""
  discoClassScan: FeatureGate!

  """Access to the dsrAutomation feature"""
  dsrAutomation: FeatureGate!

  """Access to the preferenceStore feature"""
  preferenceStore: FeatureGate!

  """Access to the webConsent feature"""
  webConsent: FeatureGate!

  """The number of mobile consent apps allowed"""
  mobileConsentApps: Int!

  """Access to the contractScanning feature"""
  contractScanning: FeatureGate!

  """Access to the pathfinder feature"""
  pathfinder: FeatureGate!

  """
  Access to large language model (LLM) for content classification feature
  """
  llmClassifier: FeatureGate!

  """
  Access to large language model (LLM) for unstructured classification feature
  """
  llmUnstructured: FeatureGate!

  """Whether to show action item onboarding checklists in the account"""
  actionItemChecklists: FeatureGate!

  """
  The version tags that are allowed for the org (e.g. 'beta', 'verizon-test')
  """
  airgapAllowedVersionTags: [String!]!

  """The maximum number of sync domains allowed for the org"""
  maxSyncDomainCount: Int!

  """Access to the customDomain feature"""
  customDomainUI: FeatureGate!

  """Access to the consent workflows feature"""
  consentWorkflows: FeatureGate!

  """Access to Workflows V2"""
  workflowsv2: Boolean!
}

type FetchEnrichmentMetadataForDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Metadata used for configuring an enricher"""
  metadata: EnrichmentMetadata!
}

"""Input for fetching metadata for an enricher"""
input FetchEnrichmentMetadataInput {
  """Name of input identifier to fetch metadata for"""
  inputIdentifierName: String!

  """Slug of the looker query"""
  lookerQuerySlug: String!
}

"""Response after unwrapping a set of file snippets"""
type FileSnippetDecryptionContext {
  """The recommendation ID"""
  id: ID!

  """The context needed to decrypt the sample in the browser"""
  decryptionContext: DecryptionContext
}

"""Input for filtering consent services"""
input FilterConsentServicesInput {
  """Filter by exact match on ID"""
  ids: [ID!]

  """Filter by a fuzzy match on the slug or service name"""
  text: String

  """Filter by the status of this consent service"""
  status: ConsentTrackerStatus

  """
  Filter by whether or not this consent service is considered "junk"
  """
  isJunk: Boolean

  """Filter for services that are shown in the TCF UI modal"""
  showInTcfModal: Boolean

  """Filter for services that are IAB registered vendors"""
  isIab: Boolean
}

"""Input for filtering consent sites"""
input FilterConsentSiteInput {
  """Filter for earliest date telemetry data was encountered"""
  lastDiscoveredAtBefore: Date

  """Filter for most recent date telemetry data was encountered"""
  lastDiscoveredAtAfter: Date

  """Filters based on either the host or site string"""
  host: String

  """
  Indicates how the row was added to the table; user ID or if by Telemetry data, show "Transcend Consent"
  """
  userId: [String!]

  """Optional free text notes field"""
  description: String

  """Fields to filter on null values"""
  includeNulls: [String!]
}

"""
The input to fire an integration for a single request or for all requests associated with a data silo,
at least one of these must be provided
"""
input FireIntegrationsInput {
  """The request id to re-trigger for"""
  requestId: ID

  """The data silo id to re-trigger for"""
  dataSiloId: ID
}

type FireSecondaryActionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

"""Input for manually firing a request's secondary action"""
input FireSecondaryActionInput {
  """The unique ID of the data subject request"""
  id: ID!
}

"""Input for font styles"""
input FontBasicInput {
  """Name of font face"""
  name: String!

  """URL of font face"""
  url: String!
}

"""Input for font metadata"""
input FontInput {
  """Name of font face"""
  name: String!

  """URL of font face"""
  url: String!

  """Additional font assets to load"""
  assets: [FontBasicInput!]
}

"""Specifies a form required to connect a data silo"""
type FormConfig {
  """The type of silo form"""
  type: SiloFormType!

  """The items associated with this form"""
  formItems: [FormItem!]!

  """The passport name aka the name of the callback"""
  passportName: String
}

"""A form item for the data subject to submit a DSR on the privacy center"""
type FormItem {
  """The unique ID of the form item"""
  id: ID

  """The name of the form item value"""
  name: String!

  """The form label message"""
  label: DefinedMessage!

  """The HTML form type"""
  type: FormType

  """The placeholder value for the form item"""
  placeholder: DefinedMessage

  """Additional info regarding the form item"""
  info: DefinedMessage

  """True if the form item is required input"""
  isRequired: Boolean!

  """True if the form item is disabled"""
  disabled: Boolean

  """The validator configuration for the form item input"""
  validator: FormRule

  """The code snippet configuration for displayed code"""
  snippet: SnippetConfig

  """The format type of the form item i.e. email"""
  format: FormFormat

  """The minimum length required of the input when a number"""
  minLength: Int

  """When an input, make it a text area with this many lines"""
  multiline: Int

  """The browser autocomplete parameter for the form item"""
  autoComplete: FormAutoComplete

  """The value for the form item"""
  value: String

  """The initial value for the form item"""
  initialValue: String

  """The initial boolean value for the form boolean item"""
  initialBooleanValue: Boolean

  """The set of data subject IDs that this form item should show for"""
  dataSubjectIds: [ID!]

  """Whether the form item value should be sent unencrypted to the backend"""
  sendUnencrypted: Boolean

  """Whether the form item value is plaintext"""
  isPlaintext: Boolean

  """The options for a select form"""
  options: [SelectOption!]

  """The mode of the select"""
  mode: ModeOption

  """Parse newline characters to actual newlines"""
  parseNewlines: Boolean

  """Whether the select is a multi select"""
  isMulti: Boolean
}

"""A form item rule"""
type FormRule {
  """The message to display when the rule is triggered"""
  message: String!

  """
  The match pattern RegExp as a string.  Will be converted to RegExp on frontend
  """
  pattern: String
}

type GenerateConsentIdentifierEncryptionKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type GenerateDataSiloSqlStatementsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A place in the organization where data sits. This could be a database, SaaS tool, filing cabinet, etc.
  """
  dataSilo: DataSilo!

  """int"""
  count: Int!
}

"""Input for generating an airgap bundle used for debugging"""
input GenerateDebugBundleInput {
  """
  The ID of the bundle to generate a debug bundle for (we will use the configuration from this bundle)
  """
  id: ID!

  """The version of airgap.js to use"""
  version: String!
}

type GenerateParentPrivacyCenterLoginTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  token: String!
}

"""Input for creating a new signup code"""
input GenerateSignupCodeInput {
  """The signup code"""
  code: String

  """
  The number of signup codes to generate (cannot be used in tandem with code)
  """
  count: Int

  """The link to the custom terms and conditions"""
  terms: String

  """The tier to generate the tokens for"""
  tier: OrganizationTier

  """
  The list of integrations that the token is being created in partnership with
  """
  integrationNames: [String!]
}

"""Input for generating SQL statements"""
input GenerateSqlInput {
  """ID of data silo to generate SQL statements for"""
  id: ID!

  """The actions to generate SQL statements for"""
  actions: [RequestActionObjectResolver!]!
}

"""Input for creating temporary api tokens"""
input GenerateTemporaryApiTokenInput {
  """The ID of the Organization to create an API key in"""
  organizationId: ID!

  """The names of the scopes to add"""
  scopes: [ScopeName!]

  """The number of milliseconds the token will live for before it expires"""
  msBeforeExpire: Int
}

type GetTokenSecretsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Secrets for signing JWTs"""
  tokenSecrets: TokenSecrets!
}

"""A new (global) action item"""
type GlobalActionItem implements GlobalActionItemInterface {
  """A unique identifier for the actionItem/s"""
  ids: [ID!]!

  """The number of action items of this type. Will be 1 for non-rollup"""
  count: Int!

  """The team/s that the actionItem item is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the actionItem item is assigned to"""
  users: [UserPreview!]!

  """
  The id of the customer experience action item, used for syncing of onboarding checklists
  """
  customerExperienceActionItemIds: [String!]!

  """The due date of the action item"""
  dueDate: Date

  """The priority of the action item"""
  priority: ActionItemPriorityOverride

  """
  The title/s for the action item. Includes things like the Data Silo name
  """
  titles: [String!]

  """List of extra contexts needed to render the actionItems"""
  additionalContexts: [GlobalActionItemContext!]

  """Is the action item resolved?"""
  resolved: Boolean!

  """The base model ids"""
  sourceIds: [String!]!

  """The user specified notes about the action item"""
  notes: [String!]!

  """The user specified link for the action item"""
  links: [String!]!

  """The attribute values used to label this action item"""
  attributeValues: [[AttributeValue!]!]!

  """The action item type"""
  type: ActionItemCode!

  """
  The collections that the action item belongs to - these are the onboarding checklist sections
  """
  collections: [GlobalActionItemCollection!]!
}

"""A collection of action items"""
type GlobalActionItemCollection {
  """A unique identifier for the actionItem/s"""
  id: ID!

  """A unique identifier for the actionItem/s"""
  title: String!

  """A unique identifier for the actionItem/s"""
  description: String!

  """A unique identifier for the actionItem/s"""
  hidden: Boolean!

  """The product line that the collection relates to"""
  productLine: TranscendProduct!
}

"""Filter action item collections"""
input GlobalActionItemCollectionFiltersInput {
  """The current location of the action item collection"""
  productLine: TranscendProduct
}

type GlobalActionItemCollectionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of GlobalActionItemCollection"""
  nodes: [GlobalActionItemCollection!]!
}

"""Additional context needed to render a global action item"""
type GlobalActionItemContext {
  """The icon to use instead of the default icon for this action item code"""
  iconOverride: String

  """The associated request id"""
  requestId: ID

  """The associated data silo id"""
  dataSiloId: ID

  """The type of an associated request"""
  requestType: String

  """The latest available airgap version"""
  latestAirgapVersion: String

  """The title of the logical parent of this object"""
  parentTitle: String
}

"""Filter action items"""
input GlobalActionItemFiltersInput {
  """The priority of the action item"""
  priority: [ActionItemPriorityOverride!]

  """The type of action item"""
  type: [ActionItemCode!]

  """The ids of assigned users"""
  assigneeUserIds: [String!]

  """The ids of assigned teams"""
  assigneeTeamIds: [String!]

  """Show only action items due after this date."""
  startDueDate: Date

  """Show only action items due before this date."""
  endDueDate: Date

  """Is the action item marked as resolved"""
  resolved: Boolean

  """Filter to only items in a specific collection"""
  collectionId: ID

  """Filter by the attribute values used to label the action item"""
  attributeValueIds: [ID!]

  """Show only action items for a specific data silo"""
  dataSiloId: ID

  """Show only action items for a specific request"""
  requestId: ID
}

"""Interface for the new (global) action item"""
interface GlobalActionItemInterface {
  """A unique identifier for the actionItem/s"""
  ids: [ID!]!

  """The number of action items of this type. Will be 1 for non-rollup"""
  count: Int!

  """The team/s that the actionItem item is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the actionItem item is assigned to"""
  users: [UserPreview!]!

  """
  The id of the customer experience action item, used for syncing of onboarding checklists
  """
  customerExperienceActionItemIds: [String!]!

  """The due date of the action item"""
  dueDate: Date

  """The priority of the action item"""
  priority: ActionItemPriorityOverride

  """
  The title/s for the action item. Includes things like the Data Silo name
  """
  titles: [String!]

  """List of extra contexts needed to render the actionItems"""
  additionalContexts: [GlobalActionItemContext!]

  """Is the action item resolved?"""
  resolved: Boolean!

  """The base model ids"""
  sourceIds: [String!]!

  """The user specified notes about the action item"""
  notes: [String!]!

  """The user specified link for the action item"""
  links: [String!]!

  """The attribute values used to label this action item"""
  attributeValues: [[AttributeValue!]!]!
}

type GlobalActionItemsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of GlobalActionItem"""
  nodes: [GlobalActionItem!]!

  """int"""
  totalCount: Int!

  """int"""
  unrolledCount: Int!
}

type GoogleSiteKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  key: String!
}

"""
The number of guessed personal data subDataPoints beneath a DataPointHierarchyItem
"""
type GuessedPersonalDataCount {
  """The number of top guesses with high confidence"""
  highConfidence: Int!

  """The number of top guesses with medium confidence"""
  mediumConfidence: Int!

  """The number of top guesses with low confidence"""
  lowConfidence: Int!
}

"""
The internal configuration of the identifier, view from the identifier's perspective on the /settings page.
"""
type Identifier implements IdentifierInterface {
  """The unique id of the identifier"""
  id: String!

  """The name of the identifier"""
  name: String!

  """The regex string for testing if a value matches the identifier"""
  regex: String!

  """
  Whether the identifier should be required in the Privacy Center/Admin Dashboard DSR form.
  """
  isRequiredInForm: Boolean!

  """The privacy center display title"""
  displayTitle: DefinedMessage

  """The privacy center display description"""
  displayDescription: DefinedMessage

  """The privacy center placeholder text"""
  placeholder: String!

  """
  Indicates if the model can be used to communicate with the data subject
  """
  isCommunicationModel: Boolean!

  """The type of identifier"""
  type: IdentifierType!

  """The logo icon to display with the identifier"""
  logo: String!

  """
  For multi select components, the set of options that should be exposed to the user
  """
  selectOptions: [String!]!

  """
  The set of actions where this identifier should be shown for on the privacy center
  """
  privacyCenterVisibility: [RequestAction!]!

  """Indicates if there is a way for the identifier to be resolved"""
  canResolve: Boolean!

  """The data subjects explicitly configured for this enricher"""
  dataSubjects: [DataSubject!]!

  """The data silos that can be keyed by the identifier"""
  dependentDataSilos: [Resource!]!

  """
  The order index for this identifier when displaying in the Privacy Center
  """
  displayOrder: Int

  """
  The SQL priority to use when generating SQL statements. If two identifiers are found for a table/datapoint, the lookup key for the table's SQL statement will be the identifier with highest priority. If no priorities are found, then all identifiers are queried. 
  """
  sqlPriority: Int

  """
  The SQL variable to use for this identifier in SQL statements. This defaults to just the identity function, but can be overridden to provide more complex SQL transformations. For example email does a LOWER({{ column }}) transformation. 
  """
  sqlVariable: String!

  """
  The SQL variable to use for this identifier in SQL statements as a lookup key. This defaults to just the identity function @<identifierName>, but can be overridden to provide more complex SQL transformations. For example email UNHEX(@<identifierName>) transformation. 
  """
  sqlLookupVariable: String!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!

  """
  Indicates that the value of the identifier is going to be unique when used in Preference store. 
  """
  isUniqueOnPreferenceStore: Boolean!
}

"""Basic Data Silo Info"""
type IdentifierDestinationDataSilo {
  """DataSilo id"""
  id: ID!

  """DataSilo title"""
  title: String!

  """Logo for corresponding integration catalog entry"""
  logo: String!
}

"""The filters when querying for identifiers"""
input IdentifierFiltersInput {
  """The identifier text filter"""
  text: String

  """The identifier type filter"""
  type: [IdentifierType!]
}

"""The input for creating an identifier"""
input IdentifierInput {
  """The unique name of the identifier"""
  name: String!

  """The static type of identifier"""
  type: IdentifierType!

  """The privacy center display title"""
  displayTitle: String

  """The privacy center display description"""
  displayDescription: String

  """The privacy center placeholder text"""
  placeholder: String

  """
  The IDs of the explicit data subjects that the identifier should display for
  """
  dataSubjectIds: [ID!]

  """A regex string for testing if a value matches the identifier"""
  regex: String

  """
  Whether the identifier should be required in the Privacy Center/Admin Dashboard DSR form.
  """
  isRequiredInForm: Boolean

  """
  The set of options to show in the privacy center when shown as a select component.
  """
  selectOptions: [String!]

  """
  The set of actions where this identifier should be shown for on the privacy center
  """
  privacyCenterVisibility: [RequestAction!]

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean

  """
  The order index for this identifier when displaying in the Privacy Center
  """
  displayOrder: Int

  """
  The SQL priority to use when generating SQL statements. If two identifiers are found for a table/datapoint, the lookup key for the table's SQL statement will be the identifier with highest priority. If no priorities are found, then all identifiers are queried. 
  """
  sqlPriority: Int

  """
  The SQL variable to use for this identifier in SQL statements. This defaults to just the identity function, but can be overridden to provide more complex SQL transformations. For example email does a LOWER({{ column }}) transformation. 
  """
  sqlVariable: String

  """
  The SQL variable to use for this identifier in SQL statements as a lookup key. This defaults to just the identity function @<identifierName>, but can be overridden to provide more complex SQL transformations. For example email UNHEX(@<identifierName>) transformation. 
  """
  sqlLookupVariable: String

  """
  Indicates that the value of the identifier is going to be unique when used in Preference store. 
  """
  isUniqueOnPreferenceStore: Boolean
}

"""
    The interface for an identifier.
An identifier is a piece of personal data, verified by the organization, that can be used to lookup data for some person.
"""
interface IdentifierInterface {
  """The unique id of the identifier"""
  id: String!

  """The name of the identifier"""
  name: String!

  """The regex string for testing if a value matches the identifier"""
  regex: String!

  """
  Whether the identifier should be required in the Privacy Center/Admin Dashboard DSR form.
  """
  isRequiredInForm: Boolean!

  """The privacy center display title"""
  displayTitle: DefinedMessage

  """The privacy center display description"""
  displayDescription: DefinedMessage

  """The privacy center placeholder text"""
  placeholder: String!

  """
  Indicates if the model can be used to communicate with the data subject
  """
  isCommunicationModel: Boolean!

  """The type of identifier"""
  type: IdentifierType!

  """The logo icon to display with the identifier"""
  logo: String!

  """
  For multi select components, the set of options that should be exposed to the user
  """
  selectOptions: [String!]!
}

"""JSON path metadata for enrichment redaction"""
type IdentifierJsonPath {
  """Unique identifier for resource with JSON path"""
  id: String!

  """JSON paths that are needed to fetch that resource"""
  jsonPaths: [String!]!
}

"""The order for a Identifier query"""
input IdentifierOrder {
  """The field that the Identifier nodes should be ordered by"""
  field: IdentifierOrderField!

  """
  The direction in which to order the Identifier nodes by the specified field
  """
  direction: OrderDirection!
}

type IdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Identifier"""
  nodes: [Identifier!]!

  """int"""
  totalCount: Int!
}

"""Enricher from which an identifier is sourced"""
type IdentifierSourceEnricher {
  """Enricher id"""
  id: ID!

  """Enricher title"""
  title: String!

  """Enricher icon name (called logo in enricher resolver)"""
  logo: String!
}

type ImportOneTrustAssessmentFormsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormRaw"""
  assessmentForms: [AssessmentFormRaw!]!
}

"""Input for importing multiple Onetrust assessment forms"""
input ImportOnetrustAssessmentsInput {
  """The rows of the CSV file."""
  rows: [OneTrustAssessmentRowInput!]

  """A stringified list of OneTrustEnrichedAssessment assessment objects."""
  json: String
}

type InitiateSitescanPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type InspectLookupProcessesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LookupProcessResultCount"""
  nodes: [LookupProcessResultCount!]!

  """int"""
  totalIndexedCount: Int!

  """int"""
  totalCount: Int!
}

"""Inspect a lookup process for information about a given identifier"""
input InspectLookupProcessesInput {
  """Data Silo ID"""
  dataSiloId: ID!

  """The identifier to inspect"""
  identifier: String!
}

"""The JSON representing the integration config for newest version only"""
type IntegrationConfig {
  """The base hosts per env"""
  configuredBaseHosts: BaseHosts!
}

"""Input for filtering the internal subjects"""
input InternalSubjectsFiltersInput {
  """Filter by text"""
  text: String

  """Filter by active"""
  active: [Boolean!]

  """Filter by subject class"""
  subjectClass: [DataSubjectClass!]
}

type InvalidateUserEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  invalidated: Boolean!
}

type IssueSombraApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An API key to be used with a Sombra instance"""
  sombraApiKey: SombraApiKey!
}

type IsUserAuthenticatedPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext

  """boolean"""
  success: Boolean!
}

"""A large language model registered by the business"""
type LargeLanguageModel implements LargeLanguageModelInterface {
  """The id of the large language model"""
  id: ID!

  """The identifying name of the large language model"""
  name: String!

  """A description of the large language model"""
  description: String!

  """The large language model client being integrated into (e.g. openai)"""
  client: LargeLanguageModelClient!

  """
  The review status of the large language model - is this model approved for usage within the business
  """
  status: PromptStatus!

  """
  Whether or not the model is hosted by Transcend or hosted by the customer
  """
  isTranscendHosted: Boolean!

  """
  The allowed context length for the model (e.g. how many tokens can go into a single call to the model)
  """
  contextLength: Int

  """
  The price per token paid for input tokens that are passed into the model
  """
  inputTokenPrice: Float

  """The price per token that comes out of the model"""
  outputTokenPrice: Float

  """The date the prompt was created"""
  createdAt: Date!

  """The date the prompt was last updated"""
  updatedAt: Date!

  """The number of prompt runs that have been executed for this model"""
  promptRunCount: Int!

  """
  The number of prompts that are configured that have been executed for this model
  """
  promptCount: Int!
}

"""Inputs for filtering large language models"""
input LargeLanguageModelFiltersInput {
  """The ids of the large language models"""
  ids: [ID!]

  """The types of LLM clients to filter for"""
  clients: [LargeLanguageModelClient!]

  """Filter by text (title of the model)"""
  text: String
}

"""Model inputs for upserting new models"""
input LargeLanguageModelInput {
  """The types of LLM client"""
  client: LargeLanguageModelClient!

  """The name of the LLM client"""
  name: String!
}

"""An interface for a large language model"""
interface LargeLanguageModelInterface {
  """The id of the large language model"""
  id: ID!

  """The identifying name of the large language model"""
  name: String!

  """A description of the large language model"""
  description: String!

  """The large language model client being integrated into (e.g. openai)"""
  client: LargeLanguageModelClient!

  """
  The review status of the large language model - is this model approved for usage within the business
  """
  status: PromptStatus!

  """
  Whether or not the model is hosted by Transcend or hosted by the customer
  """
  isTranscendHosted: Boolean!

  """
  The allowed context length for the model (e.g. how many tokens can go into a single call to the model)
  """
  contextLength: Int

  """
  The price per token paid for input tokens that are passed into the model
  """
  inputTokenPrice: Float

  """The price per token that comes out of the model"""
  outputTokenPrice: Float
}

"""The order for a LargeLanguageModel query"""
input LargeLanguageModelOrder {
  """The field that the LargeLanguageModel nodes should be ordered by"""
  field: LargeLanguageModelOrderField!

  """
  The direction in which to order the LargeLanguageModel nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a large language model"""
type LargeLanguageModelPreview implements LargeLanguageModelInterface {
  """The id of the large language model"""
  id: ID!

  """The identifying name of the large language model"""
  name: String!

  """A description of the large language model"""
  description: String!

  """The large language model client being integrated into (e.g. openai)"""
  client: LargeLanguageModelClient!

  """
  The review status of the large language model - is this model approved for usage within the business
  """
  status: PromptStatus!

  """
  Whether or not the model is hosted by Transcend or hosted by the customer
  """
  isTranscendHosted: Boolean!

  """
  The allowed context length for the model (e.g. how many tokens can go into a single call to the model)
  """
  contextLength: Int

  """
  The price per token paid for input tokens that are passed into the model
  """
  inputTokenPrice: Float

  """The price per token that comes out of the model"""
  outputTokenPrice: Float
}

type LargeLanguageModelsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LargeLanguageModel"""
  nodes: [LargeLanguageModel!]!

  """int"""
  totalCount: Int!
}

type LatestScanPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Scan metadata"""
  scan: Scan
}

type LatestSchemaDiscoveryScanProgressPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A schema discovery plugin's scan result"""
  scanProgress: SchemaDiscoveryScanResult
}

type LaunchPrivacyCenterPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""An individual on a legal hold"""
type LegalHold {
  """The unique ID of the legal hold"""
  id: ID!

  """The time the legal hold was created"""
  createdAt: Date!

  """The value of the legal hold identifier"""
  value: String!

  """The number of requests made by the individual"""
  requestCount: Int!

  """The identifier that the legal hold relates to"""
  identifier: WiredIdentifier!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""Filters for legal holds"""
input LegalHoldInput {
  """The identifier to place the legal hold on"""
  value: String!

  """The name of the identifier to create the hold for"""
  identifierName: String!
}

"""The order for a LegalHold query"""
input LegalHoldOrder {
  """The field that the LegalHold nodes should be ordered by"""
  field: LegalHoldOrderField!

  """
  The direction in which to order the LegalHold nodes by the specified field
  """
  direction: OrderDirection!
}

type LegalHoldsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LegalHold"""
  nodes: [LegalHold!]!

  """int"""
  totalCount: Int!
}

"""Filters for legal holds"""
input LegalHoldsFiltersInput {
  """Find any legal holds that are iLike a text string"""
  text: String

  """Filter by identifier types"""
  identifierIds: [ID!]
}

"""An individual on a legal matter"""
type LegalMatter {
  """The unique ID of the legal matter"""
  id: ID!

  """The time the legal matter was created"""
  createdAt: Date!

  """The title of the legal matter"""
  title: String!

  """The description of the legal matter"""
  description: String!

  """The number of individuals on the legal matter"""
  legalHoldCount: Int!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""Filters for legal matters"""
input LegalMatterInput {
  """The name of the identifier to search for matters matching"""
  identifierName: String!
}

"""The order for a LegalMatter query"""
input LegalMatterOrder {
  """The field that the LegalMatter nodes should be ordered by"""
  field: LegalMatterOrderField!

  """
  The direction in which to order the LegalMatter nodes by the specified field
  """
  direction: OrderDirection!
}

type LegalMattersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LegalMatter"""
  nodes: [LegalMatter!]!

  """int"""
  totalCount: Int!
}

"""Filters for legal matters"""
input LegalMattersFiltersInput {
  """Find any legal matters are iLike a text string"""
  text: String
}

type ListReducedRequestsForDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BulkCompletionReducedRequest"""
  nodes: [BulkCompletionReducedRequest!]!

  """int"""
  totalCount: Int!
}

type ListReducedRequestsForDataSiloAuthenticatedPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BulkCompletionReducedRequest"""
  nodes: [BulkCompletionReducedRequest!]!

  """int"""
  totalCount: Int!
}

"""LLM features for classification"""
input LLMFeaturesInput {
  """Wether to use description of the data sub category"""
  dataSubCategoryDescription: Boolean

  """Whether to use description of the subDataPoint"""
  subDataPointDescription: Boolean

  """Whether to use samples"""
  subDataPointSamples: Boolean

  """Whether to block any data sub categories"""
  dataSubCategoryBlockList: [String!]

  """Whether to use the fully qualified ID of the subDataPoint"""
  useFullyQualifiedId: Boolean
}

type LoadPrivacyPolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  content: String!
}

"""Input for loading a privacy policy from an HTML page"""
input LoadPrivacyPolicyInput {
  """The url to load the privacy policy from"""
  url: String!
}

"""An localized international message"""
type LocalizedMessage {
  """The unique id of the message"""
  id: String!

  """The default message when no translation exists"""
  defaultMessage: String!

  """
  The message localized to the current locale of the person making the request
  """
  localizedMessage: String
}

"""An email template localized"""
type LocalizedTemplate {
  """The unique id of the template"""
  id: ID!

  """The title of the template for lookup purposes"""
  title: String!

  """The actual template contents."""
  template: String!

  """The subject message for the email communication"""
  subject: String!
}

type LogEmailReplyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  done: Boolean!
}

"""The input for logging the reply to a request email"""
input LogEmailReplyInput {
  """a JWT encoding the encrypted email contents from sombra"""
  sombraContextJwt: String!

  """a JWT encoding the parsed email contents from the email-receiver"""
  emailReceiverContextJwt: String!
}

type LoginPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The currently logged in user"""
  user: CurrentUser!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext
}

"""Input for determining the login method for a particular email."""
input LoginDetailsInput {
  """The email to login with"""
  email: String!

  """The id of the user to login as"""
  userId: ID
}

"""Input for logging in via username/password"""
input LoginInput {
  """The email of the user to login as"""
  email: String!

  """The password of the user"""
  password: String!
}

"""Information about how that email can login"""
type LoginMethod {
  """The email to login with"""
  email: String!

  """
  When true, a user account & resulting organization was found matching the email.
  """
  userCanLogin: Boolean!

  """The SSO url to redirect to in order to perform login"""
  ssoUrl: String

  """The public key of the sombra gateway to communicate with"""
  sombraPublicKey: String!

  """The terms of service to be accepted"""
  terms: String!

  """
  The name of the organization logging into. Only returned when ssoUrl is returned.
  """
  organizationName: String
}

type LoginToSombraWithTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type LogoutPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type LogSentRequestEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """ID for model communication"""
  communicationId: ID!
}

"""Input to log metadata surrounding a request email"""
input LogSentRequestEmailInput {
  """The JWT containing email contents that are encrypted by sombra"""
  sombraContextJwt: String!

  """a JWT encoding the email context that initiated the email to send"""
  emailSenderContextJwt: String!

  """a JWT encoding the response from the email-sender"""
  emailSenderResponseJwt: String!
}

"""A long-running process, that is used to index an API"""
type LookupProcess {
  """Unique ID of the lookup process"""
  id: ID!

  """Lookup process's name canonical name"""
  name: String!

  """
  Lookup process's name in the config file, i.e. the configuration object it uses to index
  """
  processConfigName: String!

  """Indexing algorithm"""
  algorithm: String!

  """Indexing start date"""
  startDate: Date

  """Last indexed run until?"""
  indexedThrough: Date

  """Number of indexing runs in one invocation"""
  tolerance: Int!

  """Current status"""
  status: LookupProcessStatus!

  """Number of errors encountered"""
  errorCount: Int!

  """Error description, if in an erroneous state"""
  error: String

  """Keys for the context object"""
  contextKeys: [String!]

  """Values for the context object"""
  contextValues: [String!]

  """Keys for the currentPage object"""
  currentPageKeys: [String!]

  """Values for the currentPage object"""
  currentPageValues: [String!]
}

type LookupProcessesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of LookupProcess"""
  nodes: [LookupProcess!]!

  """int"""
  totalCount: Int!
}

"""Inputs for determining what lookup processes to filter"""
input LookupProcessFiltersInput {
  """Filter by name, process config name, or status of the lookup process"""
  text: String
}

"""Inputs for determining which silo's lookup processes to query"""
input LookupProcessInput {
  """Data Silo ID"""
  dataSiloId: ID!

  """
  Show all lookup processes that have not yet indexed until the latest request
  """
  showUnindexedUntilLatestRequest: Boolean
}

"""The order for a LookupProcess query"""
input LookupProcessOrder {
  """The field that the LookupProcess nodes should be ordered by"""
  field: LookupProcessOrderField!

  """
  The direction in which to order the LookupProcess nodes by the specified field
  """
  direction: OrderDirection!
}

"""The number of 'hits' for the given identifier"""
type LookupProcessResultCount {
  """The lookup process id"""
  id: ID!

  """The number of results for an identifier"""
  count: Int!

  """The name of the Lookup Process"""
  name: String!

  """The time of the last successfull run for the LP"""
  lastSuccessfulRun: Date!
}

type MakeDataSubjectRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A preview of a data subject request"""
  request: RequestHistory!
}

type MakeDataSubjectRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestHistory"""
  requests: [RequestHistory!]!
}

type MakeDefaultSyncEndpointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SyncEndpointCustomDomain"""
  syncEndpoints: [SyncEndpointCustomDomain!]!
}

"""Sync endpoint to make default"""
input MakeDefaultSyncEndpointInput {
  """Sync endpoint to make default"""
  domain: String!
}

type ManuallyTestAndRefreshDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A place in the organization where data sits. This could be a database, SaaS tool, filing cabinet, etc.
  """
  dataSilo: DataSilo!
}

"""Input for marking a data silo as completed"""
input MarkBulkRequestsAsCompletedInput {
  """The token to validate"""
  token: String

  """
  The request data silos to mark as complete instead of the ones directly attached to the token
  """
  RequestDataSiloIds: [String!]!

  """Mark the requests with the following statuses"""
  status: ProfileDataPointStatusSuccess
}

"""
Input to mark all link-only Request Files as Ready, associated with a given Request Data Silo
"""
input MarkLinkOnlyRequestFileAsReadyInput {
  """Request Data Silo Id"""
  id: ID!

  """Request File status"""
  status: RequestFileStatus!
}

type MarkLinkOnlyRequestFilesAsReadyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestFile"""
  requestFiles: [RequestFile!]!
}

type MarkSiloRecommendationsDuplicatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for marking data silo recommendations as duplicate"""
input MarkSiloRecommendationsDuplicateInput {
  """The ID of the plugin that found this recommendation"""
  pluginId: ID!

  """The unique identifier for the resource"""
  resourceId: String!

  """ID of an existing data silo"""
  dataSiloId: ID!
}

type MarkSiloRecommendationsJunkPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for marking data silo recommendations as junk"""
input MarkSiloRecommendationsJunkInput {
  """The ID of the plugin that found this recommendation"""
  pluginId: ID!

  """The unique identifier for the resource"""
  resourceId: String!
}

"""Lookup consent preferences"""
input MCDConsentLookupInput {
  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """Specific encrypted identifiers to lookup"""
  encryptedIdentifiers: [String!]

  """Limit the number of users' preferences to return"""
  limit: Int

  """The last record returned from previous requests; Used for pagination"""
  lastKey: ConsentLastKeyInput

  """
  Only return records with consent events before this timestamp; default is now
  """
  timestampBefore: String

  """Only return records with consent events after this timestamp"""
  timestampAfter: String

  """Only return records updated after this timestamp"""
  updatedAfter: String

  """Only return records updated before this timestamp"""
  updatedBefore: String

  """identifiers to lookup"""
  identifiers: [PreferenceStoreIdentifierInput!]
}

"""A menu item on the side menu of the privacy center"""
interface MenuTabInterface {
  """The unique tab identifier"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String
}

"""An international message"""
type Message {
  """The unique id of the message"""
  id: ID!

  """
  When true, the message is used as a title and thus should not contain rich text
  """
  isTitle: Boolean!

  """
  The default value of the message when associated with some value on the Privacy Center
  """
  defaultValue: String

  """A description for the message"""
  description: String!

  """The default message when no translation exists"""
  defaultMessage: String!

  """The ID of the react-intl message that the message relates to"""
  targetReactIntlId: String

  """The translations for this message"""
  translations: [MessageTranslation!]!

  """The type of this message"""
  type: IntlMessageType
}

"""Define an international message"""
input MessageInput {
  """
  The ID of the existing message being updated. This is normally required unless a valid "targetReactIntlId" is passed instead
  """
  id: ID

  """The default message when no translation exists"""
  defaultMessage: String!

  """The translations for this message"""
  translations: [MessageTranslationInput!]!

  """The ID of the react-intl message that the message relates to"""
  targetReactIntlId: String
}

"""A translation of an international message"""
type MessageTranslation {
  """The locale for this translation"""
  locale: String!

  """The translated message"""
  value: String!
}

"""Define a translation of an international message"""
input MessageTranslationInput {
  """The locale for this translation"""
  locale: String!

  """The translated message"""
  value: String!
}

"""An international message that is also localized"""
type MessageWithLocalized {
  """The unique id of the message"""
  id: String!

  """The default message when no translation exists"""
  defaultMessage: String!

  """
  The message localized to the current locale of the person making the request
  """
  localizedMessage: String

  """The translations for this message"""
  translations: [MessageTranslation!]!
}

"""
Input for migrating SSO configuration from a child organization to its parent
"""
input MigrateSSOInput {
  """The ID of the child organization to migrate SSO from"""
  organizationId: ID!
}

"""Input for a nested rule in the display logic of an assessment question"""
input NestedRuleInput {
  """The operator to use when comparing the nested rules"""
  logicOperator: LogicOperator!

  """
  The rules to evaluate and be compared with to other using the LogicOperator
  """
  rules: [RuleInput!]

  """
  The nested rules to add one more level of nesting to the rules. They are also compared to each other.
  """
  nestedRules: [NestedRuleInput!]
}

"""Input for creating a data collection"""
input NewDataCollectionInput {
  """The title of the data collection"""
  title: String!
}

"""A select option for an identifier type"""
type NewIdentifierType {
  """The logo icon"""
  logo: String!

  """The name of the option (its value)"""
  name: IdentifierType!
}

type NotifyAdditionalTimePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type OauthConnectionStatusPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  connected: Boolean!
}

"""Input for oauthConnectionStatus"""
input OAuthConnectionStatusInput {
  """The entity ID to check"""
  entityId: String!

  """The type of the entity to check"""
  entityType: OAuthEntityType!

  """The external auth service to check"""
  externalServiceCode: ExternalOauthServiceCode!
}

"""An access token for an external OAuth service"""
type OAuthExternalAccessEntryIds {
  """The entity ID to check"""
  entityId: String!

  """The type of the entity to check"""
  entityType: OAuthEntityType!

  """The external auth service to check"""
  externalServiceCode: ExternalOauthServiceCode!
}

"""Input used for identifying an oauth session"""
input OAuthIDInput {
  """The entity ID to check"""
  entityId: String!

  """The type of the entity to check"""
  entityType: OAuthEntityType!

  """The external auth service to check"""
  externalServiceCode: ExternalOauthServiceCode!
}

type OauthLinkPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  oauthLink: String!
}

"""Input for OAuthLink"""
input OAuthLinkInput {
  """The entity ID to check"""
  entityId: String!

  """The type of the entity to check"""
  entityType: OAuthEntityType!

  """The external auth service to check"""
  externalServiceCode: ExternalOauthServiceCode!
}

"""Configuration related to fetching the core ID for the data subject"""
type OAuthParametersGetCoreIdSchema {
  """
  The API endpoint where we can find a user ID or other similar core identifier
  """
  URL: String!

  """The path to extract the coreIdentifier from the JSON response body"""
  PATH: [String!]!

  """The type of Data Subject that the oauth login maps to"""
  DATA_SUBJECT_TYPE: String
}

"""
Input for configuration related to fetching the core ID for the data subject
"""
input OAuthParametersGetCoreIdSchemaInput {
  """
  The API endpoint where we can find a user ID or other similar core identifier
  """
  URL: String

  """The path to extract the coreIdentifier from the JSON response body"""
  PATH: [String!]
}

"""Configuration related to fetching the email for the data subject"""
type OAuthParametersGetEmailSchema {
  """The API endpoint where we can find a user email"""
  URL: String

  """The path to extract the email from the JSON response body"""
  PATH: [String!]!

  """
  Whether all OAuth emails are already verified by default, attested by the organization
  """
  IS_VERIFIED: Boolean

  """JSON path to the is_verified field on the Oauth profile"""
  IS_VERIFIED_PATH: [String!]
}

"""Input configuration related to fetching the email for the data subject"""
input OAuthParametersGetEmailSchemaInput {
  """The path to extract the email from the JSON response body"""
  PATH: [String!]

  """
  Whether all OAuth emails are already verified by default, attested by the organization
  """
  IS_VERIFIED: Boolean

  """JSON path to the is_verified field on the Oauth profile"""
  IS_VERIFIED_PATH: [String!]
}

"""Configuration related to fetching the data subject profile picture"""
type OAuthParametersGetProfilePictureSchema {
  """
  Configuration to retrieve additional profile data for the data subject (e.g. nickname, picture)
  """
  URL: String!

  """A path to the additional profile data (can be to a full JSON object)."""
  PATH: [String!]!
}

"""
Input configuration related to fetching the profile picture for the data subject
"""
input OAuthParametersGetProfilePictureSchemaInput {
  """A path to the additional profile data (can be to a full JSON object)."""
  PATH: [String!]!

  """
  Configuration to retrieve additional profile data for the data subject (e.g. nickname, picture)
  """
  URL: String!
}

"""Configuration for the body of the request that fetches the OAuth token"""
type OAuthParametersGetTokenBodySchema {
  """The redirect URI"""
  REDIRECT_URI: String!

  """The OAuth token grant type"""
  GRANT_TYPE: String
}

"""Configuration related to retrieving the Oauth Token"""
type OAuthParametersGetTokenSchema {
  """The token URL for your OAuth API (authorization_code => access_token)"""
  URL: String!

  """Configuration for the body of the request that fetches the OAuth token"""
  BODY: OAuthParametersGetTokenBodySchema!

  """The HTTP method for fetching the OAuth token from the OAuth API"""
  METHOD: HttpMethod

  """
  The headers to include when fetching the OAuth token as a stringified JSON object
  """
  HEADERS: String
}

"""Schema for an object of type `OAuthParametersInput`"""
type OAuthParametersInputSchema {
  """The Client ID of your privacy center's OAuth 2 application"""
  CLIENT_ID: [String!]!

  """Configuration related to retrieving the Oauth Token"""
  GET_TOKEN: OAuthParametersGetTokenSchema!

  """Configuration related to fetching the core ID for the data subject"""
  GET_CORE_ID: OAuthParametersGetCoreIdSchema!

  """Configuration related to fetching the email for the data subject"""
  GET_EMAIL: OAuthParametersGetEmailSchema!

  """Configuration related to fetching the data subject profile picture"""
  GET_PROFILE_PICTURE: OAuthParametersGetProfilePictureSchema
}

type OauthRevokePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  revoked: Boolean!
}

"""Input for oauthRevoke"""
input OAuthRevokeInput {
  """The entity ID to check"""
  entityId: String!

  """The type of the entity to check"""
  entityType: OAuthEntityType!

  """The external auth service to check"""
  externalServiceCode: ExternalOauthServiceCode!
}

type OauthTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An access token for an external OAuth service"""
  token: OAuthExternalAccessEntryIds!

  """string"""
  redirectPath: String!
}

"""Input for OAuthToken"""
input OAuthTokenInput {
  """
  Authorization code returned from auth server in redirect_uri query params
  """
  authCode: String!

  """State generated for auth link"""
  state: String!
}

"""The columns of a row of a OneTrust csv assessment file."""
input OneTrustAssessmentColumnInput {
  """The title of the column"""
  title: String!

  """The value of the column."""
  value: String
}

"""Input for importing an assessment form from Onetrust"""
input OneTrustAssessmentRowInput {
  """A list of columns within this row."""
  columns: [OneTrustAssessmentColumnInput!]!
}

"""
Input for creating a new on premise sombra gateway, using the legacy method
"""
input OnPremiseSombraDirectConnectionInput {
  """The customer ingress domain"""
  customerIngress: String!

  """The transcend ingress domain"""
  transcendIngress: String!
}

"""Input for creating a new on premise sombra gateway"""
input OnPremiseSombraInput {
  """Creation method"""
  method: OnPremiseSombraCreationMethod!

  """Reverse tunnel input"""
  reverseTunnel: OnPremiseSombraReverseTunnelInput

  """Direct connection input"""
  directConnection: OnPremiseSombraDirectConnectionInput
}

"""
Input for creating a new on premise sombra gateway, using the Piko cluster
"""
input OnPremiseSombraReverseTunnelInput {
  """Sombra ID to use"""
  sombraId: String
}

"""Airgap Bundle ID"""
input OptionalAirgapBundleInput {
  """The id of the airgap bundle"""
  airgapBundleId: ID
}

"""An organization on transcend"""
type Organization {
  """The unique UUID of the organization"""
  id: ID!

  """The unique UUID of the parent organization"""
  parentOrganizationId: ID

  """The display name of the organization"""
  name: String!

  """The description of the organization"""
  description: String!

  """The time when the organization was created"""
  createdAt: Date!

  """
  The unique uri slug to identify the organization in a human-readable way
  """
  uri: String!

  """The domain the organization's main website resides on"""
  domain: String!

  """The domain the organization's privacy center resides on"""
  transcendHostedDomain: String!

  """Logo taken from privacy center"""
  logo: AssetFile

  """Logo taken from privacy center"""
  favicon: AssetFile

  """The organization's tier"""
  tier: OrganizationTier!

  """The deployed privacy center configuration."""
  deployedPrivacyCenterUrl: String!

  """The associated Sombra gateway configuration"""
  sombra: Sombra!

  """The associated Sombra gateway configuration"""
  sombras: [Sombra!]!

  """Set of features that an organization has access to"""
  featureSet: FeatureSet!

  """The features that an organization has access to"""
  features: [Feature!]!

  """The default pretty alias used for emails"""
  defaultEmailAlias: String

  """The whitelist of allowed org-level notification channels"""
  notificationsWhitelist: [OrganizationNotificationWhitelistItem!]

  """The external id used for AWS cross-account access"""
  awsExternalId: String

  """The child organizations of this organization"""
  childOrganizations: [PrivacyCenterChildOrganizationPreview!]!
}

"""A whitelisted org-level notification channel"""
type OrganizationNotificationWhitelistItem {
  """The name of an org-level notification channel"""
  name: String!

  """
  The destination identifier of an org-level notification channel. E.g. slack channel ID or email address
  """
  identifier: String!

  """Method of notification for this channel"""
  notificationMethod: ActionItemSubscriptionNotificationMethod!
}

"""
  The preview of an organization when connected to some other context
that does not have access to the full organization model
"""
type OrganizationPreview {
  """The unique UUID of the organization"""
  id: ID!

  """The display name of the organization"""
  name: String!

  """
  The unique uri slug to identify the organization in a human-readable way
  """
  uri: String!

  """The unique UUID of the parent organization"""
  parentOrganizationId: ID

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  sombraPublicKeyECDH: String

  """Logo taken from privacy center"""
  favicon: AssetFile

  """Set of features that an organization has access to"""
  featureSet: FeatureSet!

  """The features that an organization has access to"""
  features: [Feature!]!

  """
  If the company has SSO login, the domains of emails that can authenticate with SSO.
  """
  ssoDomains: [String!]
}

"""TCF Special Purposes applicable for an organization"""
type OrganizationTCFSpecialPurposes {
  """The ID of the purpose as used by TCF"""
  id: Int

  """
  The name of the purpose, e.g. "Select basic ads"
  """
  name: String

  """The description of the purpose"""
  description: String

  """The duration for which data is stored (days)"""
  dataRetentionPeriod: Int

  """Real-world examples of the purpose"""
  illustrations: [String!]

  """Whether or not this TCF purpose is applicable for the organization"""
  isApplicable: Boolean!

  """Number of vendors that have declared this special purpose"""
  vendorsDeclaring: Int!
}

"""An AllowList of notification destinations"""
type OrgNotificationDestinationAllowList {
  """allow list entries"""
  entries: [OrgNotificationDestinationAllowListEntry!]!
}

"""An AllowListed notification destination"""
type OrgNotificationDestinationAllowListEntry {
  """How this identifier will be displayed"""
  name: String!

  """
  Raw identifier that will be user when sending notifications e.g. email address
  """
  identifier: String!

  """
  Raw identifier that will be user when sending notifications e.g. email address
  """
  notificationMethod: ActionItemSubscriptionNotificationMethod!
}

"""An AllowListed notification destination"""
input OrgNotificationDestinationAllowListEntryInput {
  """How this identifier will be displayed"""
  name: String!

  """
  Raw identifier that will be user when sending notifications e.g. email address
  """
  identifier: String!

  """
  Raw identifier that will be user when sending notifications e.g. email address
  """
  notificationMethod: ActionItemSubscriptionNotificationMethod!
}

"""Inputs to filter the Org TCF Purposes endpoint by"""
input OrgTcfPurposeFilterInput {
  """Filters the purpose by whether the substring is present in the name"""
  text: String

  """Filters the purposes by the TCF Purpose IDs"""
  tcfPurposeIds: [ID!]
}

type OrgTcfPurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFPurposeTrackingPurposes"""
  nodes: [TCFPurposeTrackingPurposes!]!
}

"""Inputs to filter the Org TCF Special Features endpoint by"""
input OrgTcfSpecialFeatureFilterInput {
  """
  Filters the special features by whether the substring is present in the name
  """
  text: String

  """Filters the special features by the TCF Special Feature IDs"""
  tcfSpecialFeatureIds: [ID!]
}

type OrgTcfSpecialFeaturesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFSpecialFeatureTrackingPurpose"""
  nodes: [TCFSpecialFeatureTrackingPurpose!]!

  """int"""
  totalCount: Int!
}

type OrgTcfSpecialPurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of OrganizationTCFSpecialPurposes"""
  nodes: [OrganizationTCFSpecialPurposes!]!
}

"""A page on the privacy center"""
type Page {
  """The type of page (dictates what component to use)"""
  type: PageType!
}

"""Information to aid in pagination"""
type PageInfo {
  """When paginating forwards, the cursor to continue"""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue"""
  startCursor: String
}

type ParentOrganizationTeamsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TeamPreview"""
  nodes: [TeamPreview!]!

  """int"""
  totalCount: Int!
}

"""The parent privacy center"""
type ParentPrivacyCenter {
  """The ID of the parent privacy center"""
  id: ID!

  """The URL of the privacy center"""
  url: String!
}

"""Input for determining what teams to filter"""
input ParentTeamFiltersInput {
  """Filter by team ids"""
  ids: [ID!]

  """Filter by text (name of team)"""
  text: String
}

"""
A pathfinder service that has access to particular large language models
"""
type Pathfinder {
  """The id of the pathfinder"""
  id: ID!

  """The name of the pathfinder instance"""
  name: String!

  """The URL of the pathfinder service"""
  url: String

  """The date the pathfinder was created"""
  createdAt: Date!

  """The date the pathfinder was last updated"""
  updatedAt: Date!

  """The date the pathfinder was last seen reporting a prompt run"""
  lastSeenAt: Date

  """The number of prompt runs that this pathfinder has reported"""
  promptRunCount: Int!

  """The applications that have access to this pathfinder instance"""
  applications: [ApplicationPreview!]!

  """The agents that have access to this pathfinder instance"""
  agents: [AgentPreview!]!

  """The policies that are applied to this this pathfinder instance"""
  pathfinderPolicies: [PathfinderPolicyPreview!]!

  """The large language models that this pathfinder instance has access to"""
  largeLanguageModels: [LargeLanguageModelPreview!]!
}

"""Inputs for filtering a list of pathfinders"""
input PathfinderFiltersInput {
  """The ids of the pathfinders"""
  ids: [ID!]

  """
  The ids of the applications that have access to this pathfinder application
  """
  applicationIds: [ID!]

  """
  The ids of the pathfinder policies used within this pathfinder application
  """
  pathfinderPolicyIds: [ID!]

  """
  The ids of the large language models that this pathfinder application has access to
  """
  largeLanguageModelIds: [ID!]

  """Filter by text (name, url)"""
  text: String

  """Filter by name"""
  names: [String!]
}

"""The order for a Pathfinder query"""
input PathfinderOrder {
  """The field that the Pathfinder nodes should be ordered by"""
  field: PathfinderOrderField!

  """
  The direction in which to order the Pathfinder nodes by the specified field
  """
  direction: OrderDirection!
}

type PathfinderPoliciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PathfinderPolicy"""
  nodes: [PathfinderPolicy!]!

  """int"""
  totalCount: Int!
}

"""A policy that is applied to a pathfinder service"""
type PathfinderPolicy {
  """The id of the pathfinder policy"""
  id: ID!

  """The name of the pathfinder policy"""
  name: String!

  """The description of the pathfinder policy"""
  description: String!

  """The date the pathfinder policy was created"""
  createdAt: Date!

  """The date the pathfinder policy was last updated"""
  updatedAt: Date!

  """The type of pathfinder policy"""
  type: PathfinderPolicyType!

  """
  When the policy is meant to reject input, this is the default response message
  """
  response: String

  """The data sub  categories that this policy applies to"""
  dataSubCategories: [DataSubCategoryPreview!]!

  """The list of pathfinder instances that this policy applies to"""
  pathfinders: [PathfinderPreview!]!
}

"""Inputs for filtering a list of pathfinder policies"""
input PathfinderPolicyFiltersInput {
  """The ids of the pathfinder policies"""
  ids: [ID!]

  """The ids of the pathfinders that the policy applies to"""
  pathfinderIds: [ID!]

  """The ids of the data sub categories that the policy applies to"""
  dataSubCategoryIds: [ID!]

  """Filter by text (name, description, response of the pathfinder policy)"""
  text: String

  """Filter by fuzzy name"""
  name: String

  """Filter on exact names"""
  names: [String!]
}

"""The order for a PathfinderPolicy query"""
input PathfinderPolicyOrder {
  """The field that the PathfinderPolicy nodes should be ordered by"""
  field: PathfinderPolicyOrderField!

  """
  The direction in which to order the PathfinderPolicy nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of an pathfinder policy instance"""
type PathfinderPolicyPreview {
  """The id of the pathfinder policy"""
  id: ID!

  """The name of the pathfinder policy"""
  name: String!

  """The description of the pathfinder policy"""
  description: String!

  """The date the pathfinder policy was created"""
  createdAt: Date!

  """The date the pathfinder policy was last updated"""
  updatedAt: Date!

  """The type of pathfinder policy"""
  type: PathfinderPolicyType!

  """
  When the policy is meant to reject input, this is the default response message
  """
  response: String

  """The data sub  categories that this policy applies to"""
  dataSubCategories: [DataSubCategoryPreview!]!
}

"""A preview of a pathfinder instance"""
type PathfinderPreview {
  """The id of the pathfinder"""
  id: ID!

  """The name of the pathfinder instance"""
  name: String!

  """The URL of the pathfinder service"""
  url: String

  """The date the pathfinder was created"""
  createdAt: Date!

  """The date the pathfinder was last updated"""
  updatedAt: Date!

  """The date the pathfinder was last seen reporting a prompt run"""
  lastSeenAt: Date
}

type PathfindersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Pathfinder"""
  nodes: [Pathfinder!]!

  """int"""
  totalCount: Int!
}

type PlaceRequestOnHoldPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

"""Custom headers to include in outbound webhook"""
type PlaintextContext {
  """The name of the form input."""
  name: String!

  """The value of the form input"""
  value: String!
}

"""Form input plaintext"""
input PlaintextContextInput {
  """The name of the form input."""
  name: String!

  """The value of the form input"""
  value: String!
}

"""
The plaintext information that an integration will need to work, exposed to UI before connect
"""
type PlaintextRequirement {
  """The path, in jsonpath notation"""
  path: String!

  """The reason that transcend needs this information"""
  types: [PlaintextReasonStaticType!]!
}

"""A plugin belonging to a data silo"""
type Plugin {
  """The ID of the plugin that found this recommendation"""
  id: ID!

  """The data silo this plugin belongs to"""
  dataSilo: DataSiloPreview!

  """Whether the plugin is currently running"""
  isRunning: Boolean!

  """If the plugin is enabled."""
  enabled: Boolean!

  """Type of plugin to toggle"""
  type: PluginType!

  """When the next plugin run is scheduled"""
  scheduledAt: Date!

  """The date at which this data silo was last run"""
  lastRunAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """When to start scheduling the plugin"""
  scheduleStartAt: Date!

  """
  How frequently the plugin should be run. Needs to be a string because the number can be larger than the MAX_INT
  """
  scheduleFrequency: String!

  """The current error message for the most recent run of the plugin"""
  error: String

  """
  Timestamp for until when a source has been indexed through, if applicable.
  """
  indexedThrough: Date

  """
  Timestamp representing when we started picking results that are valid for the plugins' current configuration
  """
  ignoreResultsBeforeAt: Date

  """The current status of the plugin run"""
  status: PluginQueueStatus!

  """The configuration for the plugin in stringified JSON"""
  configuration: String!

  """The context for the plugin in stringified JSON"""
  context: String!
}

"""The configuration for plugin forms."""
type PluginFormConfiguration {
  """The content classification form"""
  CONTENT_CLASSIFICATION: [FormItem!]

  """The content classification form"""
  SCHEMA_DISCOVERY: [FormItem!]

  """The content classification form"""
  DATA_SILO_DISCOVERY: [FormItem!]

  """The content classification form"""
  UNSTRUCTURED_DATA_DISCOVERY: [FormItem!]

  """The content classification form"""
  UNSTRUCTURED_DATA_SAMPLING: [FormItem!]
}

type PluginsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Plugin"""
  plugins: [Plugin!]!

  """int"""
  totalCount: Int!
}

type PluginScansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Scan"""
  nodes: [Scan!]!

  """Key used for paginating scans"""
  lastKey: ScanKey
}

"""Input for listing past scan runs"""
input PluginScansInput {
  """The plugin ID"""
  pluginId: ID!

  """The `LastEvaluatedKey` received from DynamoDB for the previous page"""
  lastKey: ScanKeyInput
}

"""Inputs for determining what plugins to filter"""
input PluginsFiltersInput {
  """The data silo this plugin belongs to"""
  dataSiloId: String

  """If the plugin is enabled."""
  enabled: Boolean

  """Type of plugin to toggle"""
  type: PluginType

  """The ID of the plugin that found this recommendation"""
  ids: [ID!]

  """Search plugins by name"""
  text: String
}

"""A policy on the privacy center"""
type Policy implements MenuTabInterface {
  """The unique tab identifier"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String

  """The time the Policy was created"""
  createdAt: Date!

  """The time the Policy was updated"""
  updatedAt: Date!

  """
  The unique slug of the policy, used as the query parameter to identify the policy
  """
  slug: String!

  """The versions of the policy"""
  versions: [PolicyVersion!]!

  """The type of the policy"""
  type: PolicyType!

  """
  The locales that are enabled for this policy. When empty list, all locales are enabled.
  """
  disabledLocales: [String!]!

  """When true, do not show the effectiveOn date in the policy."""
  disableEffectiveOn: Boolean!

  """
  When rendering on the side menu, these are the headers of each HTML section
  """
  children: [PolicyMenuTab!]!
}

"""Input for policy content for multiple locales"""
input PolicyContentInput {
  """The default content"""
  defaultMessage: String!

  """Translations of the content"""
  translations: [MessageTranslationInput!]
}

"""Make changes to a policy"""
input PolicyInput {
  """
  The unique ID of the policy to update, or left blank to create a new policy
  """
  id: ID

  """The updated title of the policy"""
  title: String

  """The static type of policy"""
  type: PolicyType

  """The policy version being updated"""
  version: PolicyVersionInput

  """When true, do not show the effectiveOn date in the policy."""
  disableEffectiveOn: Boolean

  """
  The locales that are enabled for this policy. When empty list, all locales are enabled.
  """
  disabledLocales: [String!]
}

"""A side menu for a policy on the privacy center"""
type PolicyMenuTab implements MenuTabInterface {
  """The unique tab identifier"""
  id: ID!

  """The display title of the menu tab"""
  title: LocalizedMessage!

  """The visual id of the tab, used as the hashbang"""
  visualId: String!

  """The tab logo or icon"""
  logo: String
}

"""A version of a policy on the privacy center"""
type PolicyVersion {
  """The unique ID of the policy version"""
  id: ID!

  """The date the policy version was effective"""
  effectiveOn: Date!

  """The time this policy version was created"""
  createdAt: Date!

  """The HTML content of the policy version"""
  content: Message
}

"""Make changes to a policy version"""
input PolicyVersionInput {
  """The date the policy version was effective"""
  effectiveOn: String

  """The HTML content of the policy version"""
  content: PolicyContentInput
}

type PossibleDataSiloDependenciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSilo"""
  nodes: [DataSilo!]!

  """int"""
  totalCount: Int!
}

"""Input for filtering possible dependencies of a data silo"""
input PossibleDataSiloDependencyFilterInput {
  """The id of the data silo to search for dependencies of"""
  dataSiloId: ID!

  """Filter by text (title of data silo)"""
  text: String
}

type PredictPrivacyPolicyUrlPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """string"""
  url: String!
}

type PreferencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A preference for a user or organization"""
  preference: PreferenceRaw
}

"""Input for preference choice"""
input PreferenceChoiceInput {
  """The boolean value of the preference"""
  booleanValue: Boolean

  """The select value(string) of the preference"""
  selectValue: String

  """The select values(string[]) of the preference"""
  selectValues: [String!]
}

"""preference choice made by the user"""
type PreferenceChoiceSchema {
  """The boolean value of the preference"""
  booleanValue: Boolean

  """The select value(string) of the preference"""
  selectValue: String

  """The select values(string[]) of the preference"""
  selectValues: [String!]
}

"""Inputs to get preferences for a user or organization"""
input PreferenceFiltersInput {
  """The id of the preference"""
  id: ID

  """The id of the user for whom get preferences"""
  userId: ID

  """The id of the organization for which get preferences"""
  organizationId: ID
}

"""Input for preference"""
input PreferenceInput {
  """The topic of the preference"""
  topic: String!

  """The choice made by the user for this preference topic"""
  choice: PreferenceChoiceInput!
}

"""The option value for a preference"""
type PreferenceOptionValue {
  """The id of the preference option"""
  id: ID!

  """The title of the preference option"""
  title: DefinedMessage!

  """The slug of the preference option"""
  slug: String!

  """The date the preference option was last updated"""
  updatedAt: Date

  """The user that created the preference option"""
  user: UserPreview
}

"""Filter input for preference option values"""
input PreferenceOptionValueFilterInput {
  """Filter by name"""
  text: String

  """Filter by preference topic id"""
  preferenceTopicIds: [ID!]
}

type PreferenceOptionValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PreferenceOptionValue"""
  nodes: [PreferenceOptionValue!]!

  """int"""
  totalCount: Int!
}

"""A preference for a user or organization"""
type PreferenceRaw {
  """A unique identifier for the preference"""
  id: ID!

  """The ID of the organization this preference belongs to"""
  organizationId: ID!

  """The ID of the user this preference belongs to"""
  userId: ID

  """A JSON blob of the preferences for tables"""
  tables: String!
}

"""User preference"""
type PreferenceSchema {
  """The topic of the preference"""
  topic: String!

  """The choice made by the user for this preference topic"""
  choice: PreferenceChoiceSchema!
}

"""Identifier for consent preferences"""
input PreferenceStoreIdentifierInput {
  """encrypted identifier value"""
  value: String!

  """The name of the identifier (e.g. email, phone number, etc.)"""
  name: String!
}

"""Identifier for consent preferences"""
type PreferenceStoreIdentifierSchema {
  """encrypted identifier value"""
  value: String!

  """The name of the identifier (e.g. email, phone number, etc.)"""
  name: String!
}

"""Preference topic configuration on the Admin Dashboard."""
type PreferenceTopic {
  """The id of the preference topic"""
  id: ID!

  """The slug of the preference topic"""
  slug: String!

  """The display title of the preference topic"""
  title: DefinedMessage!

  """The color of the preference topic"""
  color: String!

  """The type of preference topic"""
  type: PreferenceTopicType!

  """The display description of the preference topic"""
  displayDescription: DefinedMessage!

  """Whether the preference topic should be shown in the privacy center"""
  showInPrivacyCenter: Boolean!

  """
  The default configuration for this preference topic when the purpose is opted in or out
  """
  defaultConfiguration: String!

  """The option values for this preference topic"""
  preferenceOptionValues: [PreferenceOptionValue!]!

  """The purpose this preference topic is associated with"""
  purpose: TrackingPurposePreview!

  """The date the preference topic was last updated"""
  updatedAt: Date

  """The user that created the preference topic"""
  user: UserPreview
}

"""Filter input for preferences"""
input PreferenceTopicFilterInput {
  """Filter by name"""
  text: String

  """Filter the preference topics by purpose IDs"""
  purposeIds: [ID!]

  """Filter the preference topics by showInPrivacyCenter"""
  showInPrivacyCenter: Boolean

  """Filter the preference topics by tracking types"""
  trackingTypes: [String!]

  """Whether to paginate by purpose"""
  paginateByPurpose: Boolean
}

"""Preference topic preview configuration on the Admin Dashboard."""
type PreferenceTopicPreview {
  """The id of the preference topic"""
  id: ID!

  """The slug of the preference topic"""
  slug: String!

  """The display title of the preference topic"""
  title: DefinedMessage!

  """The color of the preference topic"""
  color: String!
}

type PreferenceTopicsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PreferenceTopic"""
  nodes: [PreferenceTopic!]!

  """int"""
  totalCount: Int!

  """int"""
  groupCount: Int!
}

"""Privacy Center Access Token"""
type PrivacyCenterAccessToken {
  """The token to be used to access the privacy center"""
  token: String!
}

"""The asset files to render on the Privacy Center"""
type PrivacyCenterAssets {
  """The asset file logo"""
  logo: AssetFile

  """The asset file favicon"""
  favicon: AssetFile

  """The asset file logoOnSolid"""
  logoOnSolid: AssetFile

  """The asset file hero"""
  hero: AssetFile

  """The asset file widgetBg"""
  widgetBg: AssetFile
}

"""
  The preview of an organization when connected to some other context
that does not have access to the full organization model
"""
type PrivacyCenterChildOrganizationPreview {
  """The unique UUID of the organization"""
  id: ID!

  """The display name of the organization"""
  name: String!

  """
  The unique uri slug to identify the organization in a human-readable way
  """
  uri: String!

  """The unique UUID of the parent organization"""
  parentOrganizationId: ID

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  sombraPublicKeyECDH: String

  """Logo taken from privacy center"""
  logo: AssetFile

  """The deployed privacy center configuration."""
  deployedPrivacyCenterUrl: String!

  """
  The unique UUID of the airgap bundle--used as the default partition for the organization
  """
  airgapBundleId: ID
}

"""The deployment information for a Privacy Center"""
type PrivacyCenterDeployment {
  """The id of the Privacy Center"""
  id: ID!

  """The cloudfront instance deployed for the Privacy Center"""
  cloudfront: CloudFront

  """The SSL certificate used to host the cloudfront"""
  certificate: Certificate

  """The current step in the deployment process for this Privacy Center"""
  step: PrivacyCenterDeploymentStep!
}

"""A step in the privacy deployment process"""
type PrivacyCenterDeploymentStep {
  """The index of the step currently being run"""
  current: Int!

  """A description of what is happening at this step"""
  description: String!

  """The status of the step as it relates to the ant.design component"""
  status: StepStatus!
}

type PrivacyCenterEmailLoginPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for querying a privacy center from the admin dashboard"""
input PrivacyCenterIdInput {
  """ID of the privacy center"""
  privacyCenterId: ID!
}

"""Input for querying a privacy center"""
input PrivacyCenterLookupInput {
  """Lookup privacy center by URL"""
  url: String

  """Get by type (if an organization is in context, i.e. admin dashboard)"""
  type: PrivacyCenterType
}

"""The option value for a preference option on the privacy center"""
type PrivacyCenterPreferenceOptionValue {
  """The id of the preference option"""
  id: ID!

  """The title of the preference option"""
  title: DefinedMessage!

  """The slug of the preference option"""
  slug: String!
}

"""Privacy Center Preference topic configuration on the Privacy Center."""
type PrivacyCenterPreferenceTopic {
  """The display title of the preference topic"""
  title: DefinedMessage!

  """The display description of the preference topic"""
  displayDescription: DefinedMessage!

  """The slug of the preference topic"""
  slug: String!

  """The type of preference topic"""
  type: PreferenceTopicType!

  """
  The default configuration for this preference topic when the purpose is opted in or out
  """
  defaultConfiguration: String!

  """The option values for this preference topic"""
  preferenceOptionValues: [PrivacyCenterPreferenceOptionValue!]!
}

"""The Privacy Center configuration"""
type PrivacyCenterStringified {
  """The id of the Privacy Center"""
  id: ID!

  """The type of Privacy Center"""
  type: PrivacyCenterType!

  """Show the Make a Privacy Request button"""
  showPrivacyRequestButton: Boolean!

  """
  When true, do not show data practices and instead redirect to privacy policy
  """
  hideDataPractices: Boolean @deprecated(reason: "This feature is being removed")

  """
  When true, do not show the Privacy Center, instead show a disabled message
  """
  isDisabled: Boolean!

  """When true, show the policies tab"""
  showPolicies: Boolean!

  """When true, show the tracking technologies tab"""
  showTrackingTechnologies: Boolean!

  """When true, show the "Privacy Settings" tab"""
  showManageYourPrivacy: Boolean!

  """When true, show the sale of info tab"""
  showSaleOfInfo: Boolean!

  """The regions that support unauthenticated Do Not Sell requests"""
  unauthenticatedDoNotSellRegions: [Region!]!

  """When true, show the marketing preferences tab"""
  showMarketingPreferences: Boolean!

  """Show cookies in tracking technologies table"""
  showCookies: Boolean!

  """Show cookie expiration duration in tracking technologies table"""
  showCookieMaxAge: Boolean!

  """
  Enable the ability to set/change consent preferences via the consent manager
  """
  showConsentManager: Boolean!

  """Show data flows in tracking technologies table"""
  showDataFlows: Boolean!

  """When true, show the Requests Processed tab"""
  showRequestsProcessedStats: Boolean!

  """The url that the Privacy Center is hosted on"""
  url: String!

  """
  When the logo is clicked, this is the URL it should redirect to.
  The default is to the home page of the Privacy Center (data practices), but this could also be the full privacy policy
  if hosted individually from the Privacy Center.
  """
  home: DefinedMessage!

  """The languages that the Privacy Center supports"""
  locales: [String!]!

  """The default locale to use for this Privacy Center"""
  defaultLocale: String!

  """When true, use the browser default locale if available"""
  preferBrowserDefaultLocale: Boolean!

  """The support email that should be linked to in the footer"""
  supportEmail: String

  """
  The support email that should be used when the user hits reply-to on an email
  """
  replyToEmail: String

  """
  The email prefix that should be used when sending emails to the data subject
  """
  emailPrefix: String

  """The preview of the organization"""
  organization: OrganizationPreview!

  """The child organizations to render preference information on behalf of"""
  childOrganizations: [PrivacyCenterChildOrganizationPreview!]!

  """The globally defined asset files"""
  assets: PrivacyCenterAssets!

  """The consent manager bundles associated with this Privacy Center"""
  consentManagers: [SyncedConsentManager!]!

  """The pages associated with the Privacy Center"""
  pages: [Page!]!

  """The theme to style the Privacy Center with"""
  themeStr: String!

  """The list of all data applications"""
  dataApplications: [DataApplication!] @deprecated(reason: "This feature is being removed")

  """The data practices, in nested format"""
  dataPractices: [DataCategoryMethodMenu!] @deprecated(reason: "This feature is being removed")

  """
  The parent privacy center where users can be redirected to in order to manage additional preferences
  """
  parentPrivacyCenter: ParentPrivacyCenter

  """
  Whether to use a no-reply email address for data subject communications
  """
  useNoReplyEmailAddress: Boolean!

  """
  Whether to use the configured email domain for data subject communications
  """
  useCustomEmailDomain: Boolean!

  """
  Should we attempt to transform any JSON objects as part of the ACCESS report download into CSV?
  """
  transformAccessReportJsonToCsv: Boolean!

  """When true, show the partition select component in the privacy center"""
  allowPartitionChange: Boolean!

  """When true, show the partition information on the privacy center"""
  showPartition: Boolean!

  """
  Custom subdomain for the Transcend-hosted privacy center (when fully launched)
  """
  customSubdomain: String!

  """Domain for the Transcend-hosted privacy center (when fully launched)."""
  transcendHostedDomain: String!

  """The consent partitions available for display on the Privacy Center"""
  consentPartitions: [ConsentPartition!]!
}

"""Preview of purpose with subset of fields"""
type PrivacyCenterTrackingPurposePreview {
  """The display title of the purpose"""
  title: DefinedMessage!

  """The display description of the purpose"""
  displayDescription: DefinedMessage!

  """The tracking purpose type associated with the site."""
  trackingType: String!

  """
  Whether this purpose should be shown in the Consent Management dashboard
  """
  isActive: Boolean!

  """
  The authentication level require by user to update the purpose in the preference store
  """
  authLevel: PreferenceStoreAuthLevel!

  """
  Whether this purpose should be shown in the communication preferences page of the privacy center
  """
  showInPrivacyCenter: Boolean!

  """Topics associated with this purpose"""
  preferenceTopics: [PrivacyCenterPreferenceTopic!]
}

"""An ID of a message and its associated translation"""
type PrivacyCenterTranslation {
  """The unique identifier for that message"""
  id: String!

  """The translation for that message"""
  value: String!
}

"""Items in current privacy center version"""
type PrivacyCenterVersionModules {
  """A unique identifier for the Privacy Center Version"""
  id: ID

  """The JSON containing the configurations of the privacy center module"""
  privacyCenterModule: String

  """The JSON containing the configurations of the policies module"""
  policiesModule: String

  """The JSON containing the configurations of the messages module"""
  messagesModule: String

  """The JSON containing the configurations of the subjects module"""
  subjectsModule: String

  """
  The JSON containing the configurations of the requests processed stats module
  """
  privacyCenterRequestsProcessedStatsModule: String

  """The JSON containing the configurations of the purposes module"""
  purposesModule: String

  """The JSON containing the configurations of the workflow configs module"""
  privacyCenterWorkflowConfigsModule: String
}

"""Input to get the latest saved or deployed privacy center version"""
input PrivacyCenterVersionModulesInput {
  """ID of the privacy center"""
  privacyCenterId: ID!

  """
  Indicates whether to get latest privacy center version modules in deployed or saved state
  """
  inDeployState: Boolean!
}

"""A subset of a workflow config, for the privacy center"""
type PrivacyCenterWorkflowConfig {
  """The unique ID of the workflow config"""
  id: ID!

  """The title of the workflow"""
  title: LocalizedMessage!

  """The subtitle of the workflow"""
  subtitle: LocalizedMessage

  """The description of the workflow"""
  description: LocalizedMessage

  """The action"""
  action: Action!

  """The data subject for this workflow"""
  subject: DataSubject

  """The list of regions"""
  regionList: [String!]

  """
  The form items that should be rendered when the data subject submits the request
  """
  formItems: [FormItem!]!
}

type PrivacyCenterWorkflowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PrivacyCenterWorkflowConfig"""
  nodes: [PrivacyCenterWorkflowConfig!]!
}

type ProcessingActivitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ProcessingActivity"""
  nodes: [ProcessingActivity!]!

  """int"""
  totalCount: Int!
}

"""Filters for processing activities"""
input ProcessingActivitiesFiltersInput {
  """The ids of the processing activities"""
  ids: [ID!]

  """Find any processing activities are iLike a text string"""
  text: String

  """The attribute values used to label the processing activities"""
  attributeValueIds: [ID!]

  """The ids of the business entities related to the processing activities"""
  businessEntityIds: [ID!]

  """The ids of the data silos related to the processing activities"""
  dataSiloIds: [ID!]

  """The ids of the subjects of the processing activities"""
  dataSubjectIds: [ID!]

  """The ids of the teams that own the processing activities"""
  teamIds: [ID!]

  """The ids of the users that own the processing activities"""
  ownerIds: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """
  The ids of the processing purpose sub categories related to the processing activities
  """
  processingPurposeSubCategoryIds: [ID!]

  """
  Filter by data categories of the processing activities, or to related subdatapoints and data silos
  """
  dataCategories: [DataCategoryType!]

  """
  The ids of the data subcategories related to the processing activities, or to related subdatapoints and data silos
  """
  dataSubCategoryIds: [ID!]

  """The ids of the saas categories of the processing activities"""
  saaSCategoryIds: [ID!]

  """The ids of the vendors of the processing activities"""
  vendorIds: [ID!]
}

"""A processing activity of the organization"""
type ProcessingActivity {
  """The unique ID of the processing activity"""
  id: ID!

  """The title of the processing activity"""
  title: String!

  """The description of the processing activity"""
  description: String!

  """Security measures related to this processing activity"""
  securityMeasureDetails: String

  """The controllership values assigned to this processingActivity"""
  controllerships: [Controllership!]!

  """The storage regions associated with this processing activity"""
  storageRegions: [Region!]!

  """The transfer regions associated with this processing activity"""
  transferRegions: [Region!]!

  """The type of retention schedule"""
  retentionType: RetentionType!

  """
  The number of days personal data is retained (for stated period retention types)
  """
  retentionPeriod: Int

  """A link to the DPIA for this processing activity"""
  dataProtectionImpactAssessmentLink: String

  """The status of the DPIA for this processing activity"""
  dataProtectionImpactAssessmentStatus: DataProtectionImpactAssessmentStatus!

  """The attribute values used to label this processing activity"""
  attributeValues: [AttributeValue!]!

  """The list of business entities related to this processing activity"""
  businessEntities: [BusinessEntityPreview!]!

  """The list of data silos related to this processing activity"""
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """
  The list of data silos related to this processing activity's subdatapoints
  """
  subDataPointDataSilos: [DiscoveredByDataSiloPreview!]!

  """The list of data subjects for this processing activity"""
  dataSubjects: [DataSubject!]!

  """
  The list of teams who are responsible for managing this processing activity
  """
  teams: [TeamPreview!]!

  """
  The list of users who are responsible for managing this processing activity
  """
  owners: [UserPreview!]!

  """
  The list of processing purpose sub categories related to this processing activity
  """
  processingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """The data subcategories for this processing activity"""
  dataSubCategories: [DataSubCategoryPreview!]!

  """
  The data subcategories for subdatapoints and data silos assigned to processing activity
  """
  relatedDataSubCategories: [DataSubCategoryPreview!]!

  """
  The SaaS categories (sometimes called recipient categories) for this processing activity
  """
  saaSCategories: [SaaSCategoryBase!]!

  """The vendors for this processing activity"""
  vendors: [VendorPreview!]!
}

"""The order for a ProcessingActivity query"""
input ProcessingActivityOrder {
  """The field that the ProcessingActivity nodes should be ordered by"""
  field: ProcessingActivityOrderField!

  """
  The direction in which to order the ProcessingActivity nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a processing activity"""
type ProcessingActivityPreview {
  """The unique ID of the processing activity"""
  id: ID!

  """The title of the processing activity"""
  title: String!
}

"""Input for filtering the list of purpose of processing sub categories"""
input ProcessingPurposeCategoryFiltersInput {
  """Filter by list of processingPurposeSubCategory ids"""
  ids: [ID!]

  """Filter by text"""
  text: String

  """Filter purposes by ids of the teams assigned as owners"""
  teamIds: [ID!]

  """Filter purposes by the ids of the users assigned as owners"""
  ownerIds: [ID!]

  """Filter by the attribute values used to label the purposes"""
  attributeValueIds: [ID!]

  """
  Filter by the ids of the owners of the vendors associated to this purpose
  """
  vendorOwnerIds: [ID!]

  """
  Filter by the ids of the owners of the silos associated to this purpose
  """
  dataSiloOwnerIds: [ID!]

  """
  Filter by the categories of personal data assigned to sub-datapoints with this processing purpose
  """
  dataCategories: [DataCategoryType!]

  """
  Filter by the ids of the subcategories assigned to subdatapoints with this processing purpose
  """
  dataSubCategoryIds: [ID!]

  """
  Filter by the ISO country assigned to vendors whose data silos have subdatapoints with this processing purpose subcategory
  """
  vendorHeadquarterCountry: [IsoCountryCode!]

  """
  Filter by the ISO country sub-division assigned to vendors whose data silos have subdatapoints with this processing purpose subcategory
  """
  vendorHeadquarterSubDivision: [String!]

  """
  Filter by the countries assigned to data silos that have subdatapoints with this processing purpose subcategory
  """
  dataSiloCountry: [IsoCountryCode!]

  """
  Filter by the country sub-divisions assigned to data silos that have subdatapoints with this processing purpose subcategory
  """
  dataSiloCountrySubDivision: [String!]

  """
  Filter by IDs of recipient categories associated with the catalogs of silos whose subdatapoints have this processing purpose subcategory
  """
  saaSCategoryIds: [ID!]

  """
  Filter by the type of retention schedule for subdatapoints with this processing purpose subcategory
  """
  retentionTypes: [RetentionType!]

  """
  Filter by data silos whose subdatapoints have this processing purpose subcategory
  """
  dataSiloIds: [ID!]

  """
  Filter by controllerships set on associated data silos or subdatapoints
  """
  controllerships: [Controllership!]

  """Filter by the associated sensitive categories"""
  sensitiveCategoryIds: [ID!]
}

"""Input for filtering the list of processing purposes"""
input ProcessingPurposeFiltersInput {
  """Filter processing purposes by text"""
  text: String

  """Filter purposes by ids of the teams assigned as owners"""
  teamIds: [ID!]

  """Filter purposes by the ids of the users assigned as owners"""
  ownerIds: [ID!]

  """Filter by the attribute values used to label the purposes"""
  attributeValueIds: [ID!]
}

"""Metadata about a purpose of processing"""
interface ProcessingPurposeInterface {
  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!
}

type ProcessingPurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  totalCount: Int!

  """A list of ProcessingPurposeInterface"""
  nodes: [ProcessingPurposeInterface!]!
}

type ProcessingPurposeSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PurposeSubCategory"""
  nodes: [PurposeSubCategory!]!

  """int"""
  totalCount: Int!
}

"""Metadata about a subcategory of a purpose of processing"""
interface ProcessingPurposeSubCategoryInterface {
  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!

  """The ID of the subpurpose"""
  id: ID!

  """The purpose of processing subcategory"""
  name: String!

  """Whether this is a default processing subcategory"""
  isDefault: Boolean!
}

"""
A unique identifier for a data subject in the context of a data silo. From this profile is where all data is attached.
"""
type Profile {
  """The unique database id of the profile, assigned by transcend"""
  id: ID!

  """The name of the identifier that the profile resolved from"""
  type: String

  """The request identifiers that mapped to this profile"""
  requestIdentifiers: [RequestIdentifier!]!

  """The statuses of the datapoints to fire in respect to this profile"""
  profileDataPoints: [ProfileDataPoint!]!
}

"""An edge between a datapoint and profile, indicating child profile"""
type ProfileDataPoint {
  """The unique database id of the ProfileDataPoint edge"""
  id: ID!

  """The id of the datapoint"""
  dataPointId: ID!

  """The id of the profile"""
  profileId: ID!

  """The datapoint that the edge refers to"""
  dataPoint: DataPointPreviewWithDataSilo!

  """The action being taken on the datapoint"""
  action: Action

  """The status of the profile firing the datapoint"""
  status: ProfileDataPointStatus!

  """The error message if an error ocurred"""
  error: String

  """The number of request files associated with the profile datapoint"""
  fileCount: Int!

  """When the next action is scheduled"""
  scheduledAt: Date!

  """The profile identifier being looked up"""
  profile: ProfilePreview!

  """
  The ID used as reference when implemented as notify -> save nonce -> poll nonce
  """
  pollId: String

  """A link to the profile datapoint in question"""
  link: String!
}

"""Input for filter ProfileDataPoints"""
input ProfileDataPointFiltersInput {
  """Search datapoints by name or data silos by title"""
  text: String

  """The ID of the data silo to filter for"""
  dataSiloId: ID

  """The ID of the profile to filter for"""
  profileId: ID

  """
  The ID of the datapoint to filter for. When provided, dataSiloId is redundant
  """
  dataPointId: ID

  """The status of the ProfileDataPoint to filter"""
  status: [ProfileDataPointStatus!]

  """The IDs of the requests to filter for"""
  requestIds: [ID!]

  """Show only active profile datapoint jobs"""
  showActiveJobs: Boolean

  """The type of data subject requests to filter for"""
  requestType: [RequestAction!]

  """Filter for requests that have been made before this date"""
  requestCreatedAt: Date

  """The status of data subject requests to filter for"""
  requestStatus: [RequestStatus!]
}

"""The order for a ProfileDataPoint query"""
input ProfileDataPointOrder {
  """The field that the ProfileDataPoint nodes should be ordered by"""
  field: ProfileDataPointOrderField!

  """
  The direction in which to order the ProfileDataPoint nodes by the specified field
  """
  direction: OrderDirection!
}

type ProfileDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ProfileDataPoint"""
  nodes: [ProfileDataPoint!]!

  """int"""
  totalCount: Int!
}

"""Preview of a profile"""
type ProfilePreview {
  """The unique database id of the profile, assigned by transcend"""
  id: ID!

  """The name of the identifier that the profile resolved from"""
  type: String
}

"""An HTML-based prompt for editable prompts with HTML content"""
type Prompt {
  """The id of the prompt"""
  id: ID!

  """The title of the prompt"""
  title: String!

  """The status of the prompt"""
  status: PromptStatus!

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """
  The expected mode in which response text is returned - commonly set to json_object to return JSON data
  """
  responseFormat: PromptResponseFormat!

  """The content of the prompt"""
  content: String!

  """The user who created this prompt someone"""
  creator: UserPreview

  """The user who last edited the prompt"""
  lastEditor: UserPreview

  """The user who is asked to review the prompt"""
  reviewer: UserPreview

  """The date the prompt was created"""
  createdAt: Date!

  """The date the prompt was last updated"""
  updatedAt: Date!

  """The number of recorded prompt runs"""
  promptRunCount: Int!

  """The team/s that the prompt is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the prompt is assigned to"""
  owners: [UserPreview!]!

  """The prompt groups that the prompt belongs to"""
  promptGroups: [PromptGroupPreview!]!

  """The agents that the prompt belongs to"""
  agents: [AgentPreview!]!

  """The large language models that this prompt is best used with"""
  largeLanguageModels: [LargeLanguageModelPreview!]!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""Inputs for filtering a list of prompts"""
input PromptFiltersInput {
  """The ids of the prompts"""
  ids: [ID!]

  """The response formats of the prompts"""
  responseFormats: [PromptResponseFormat!]

  """The titles of the prompts"""
  titles: [String!]

  """The ids of last editors"""
  lastEditorIds: [ID!]

  """The ids of the users who created a prompt"""
  creatorIds: [ID!]

  """The ids of the prompt groups for the prompt"""
  promptGroupIds: [ID!]

  """The ids of the large language models assigned to the prompts"""
  largeLanguageModelIds: [ID!]

  """The ids of the reviewers for the prompt"""
  reviewerIds: [ID!]

  """Filter by text (title of the prompt)"""
  text: String

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]
}

"""Group for a template that can be composed into a prompt"""
type PromptGroup {
  """The id of the prompt group"""
  id: ID!

  """The title of the prompt group"""
  title: String!

  """The description of the prompt group"""
  description: String!

  """The user who created this prompt someone"""
  creator: UserPreview

  """The user who last edited the prompt"""
  lastEditor: UserPreview

  """The date the prompt was created"""
  createdAt: Date!

  """The date the prompt was last updated"""
  updatedAt: Date!

  """The list of prompts in the group"""
  prompts: [PromptPreview!]!

  """The team/s that the prompt is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the prompt is assigned to"""
  owners: [UserPreview!]!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!
}

"""Inputs for filtering prompt groups"""
input PromptGroupFiltersInput {
  """The ids of the prompt groups"""
  ids: [ID!]

  """The ids of last editors"""
  lastEditorIds: [ID!]

  """The ids of the users who created a prompt"""
  creatorIds: [ID!]

  """The ids of the prompts that are in the group"""
  promptIds: [ID!]

  """Filter by text (title of the prompt)"""
  text: String

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]
}

"""The order for a PromptGroup query"""
input PromptGroupOrder {
  """The field that the PromptGroup nodes should be ordered by"""
  field: PromptGroupOrderField!

  """
  The direction in which to order the PromptGroup nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a prompt group"""
type PromptGroupPreview {
  """The id of the prompt"""
  id: ID!

  """The title of the prompt"""
  title: String!
}

type PromptGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptGroup"""
  nodes: [PromptGroup!]!

  """int"""
  totalCount: Int!
}

"""Information about a prompt partial necessary for templating a prompt"""
type PromptGroupTemplated {
  """The id of the prompt group"""
  id: ID!

  """The title of the prompt group"""
  title: String!

  """The description of the prompt group"""
  description: String!

  """The date the prompt was created"""
  createdAt: Date!

  """The date the prompt was last updated"""
  updatedAt: Date!

  """The list of prompts in the group"""
  prompts: [PromptPreview!]!
}

"""The order for a Prompt query"""
input PromptOrder {
  """The field that the Prompt nodes should be ordered by"""
  field: PromptOrderField!

  """
  The direction in which to order the Prompt nodes by the specified field
  """
  direction: OrderDirection!
}

"""Partial for a template that can be composed into a prompt"""
type PromptPartial {
  """The id of the prompt partial"""
  id: ID!

  """The title of the partial prompt"""
  title: String!

  """The slug of the partial prompt"""
  slug: String!

  """The content of the partial prompt"""
  content: String!

  """The user who created this partial prompt"""
  creator: UserPreview

  """The user who last edited the partial prompt"""
  lastEditor: UserPreview

  """The date the partial prompt was created"""
  createdAt: Date!

  """The date the partial prompt was last updated"""
  updatedAt: Date!

  """The team/s that the partial prompt is assigned to"""
  teams: [TeamPreview!]!

  """The user/s that the partial prompt is assigned to"""
  owners: [UserPreview!]!
}

"""Inputs for filtering prompt partials"""
input PromptPartialFiltersInput {
  """The ids of the prompt partials"""
  ids: [ID!]

  """The ids of last editors"""
  lastEditorIds: [ID!]

  """The ids of the users who created a prompt"""
  creatorIds: [ID!]

  """Filter by text (title of the prompt)"""
  text: String

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]
}

"""The order for a PromptPartial query"""
input PromptPartialOrder {
  """The field that the PromptPartial nodes should be ordered by"""
  field: PromptPartialOrderField!

  """
  The direction in which to order the PromptPartial nodes by the specified field
  """
  direction: OrderDirection!
}

type PromptPartialsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptPartial"""
  nodes: [PromptPartial!]!

  """int"""
  totalCount: Int!
}

"""Information about a prompt partial necessary for templating a prompt"""
type PromptPartialTemplated {
  """The id of the prompt partial"""
  id: ID!

  """The title of the prompt"""
  title: String!

  """The slug of the partial prompt"""
  slug: String!

  """The content of the partial prompt"""
  content: String!

  """The date the partial prompt was created"""
  createdAt: Date!

  """The date the partial prompt was last updated"""
  updatedAt: Date!
}

"""A preview of an AI prompt definition"""
type PromptPreview {
  """The id of the prompt"""
  id: ID!

  """The title of the prompt"""
  title: String!

  """The status of the prompt"""
  status: PromptStatus!

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int
}

"""An instance of running a prompt"""
type PromptRun {
  """The id of the prompt run"""
  id: ID!

  """
  The name of the prompt run (specified in API or derived from the file input)
  """
  name: String!

  """The link to view the prompt run in the admin dashboard"""
  link: String!

  """The status of the prompt run"""
  status: QueueStatus!

  """The product area that the prompt run is a part of"""
  productArea: PromptRunProductArea!

  """The date the prompt run was created"""
  createdAt: Date!

  """The date the prompt run was last updated"""
  updatedAt: Date!

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float!

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float!

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """The number of ms that the prompt run took to execute within the LLM"""
  duration: Int

  """The number of tokens used in the prompt input"""
  inputTokenCount: Int

  """The number of tokens used in the response"""
  responseTokenCount: Int

  """The cost of input tokens"""
  inputTokenCost: Float

  """The cost of response tokens"""
  responseTokenCost: Float

  """The total cost of the prompt run"""
  totalCost: Float

  """The error message if status is error"""
  error: String

  """The messages in the prompt run"""
  promptRunMessages: [PromptRunMessage!]!

  """The prompt that executed the prompt run"""
  prompt: PromptPreview

  """The prompt group that the prompt run was a being executed within"""
  promptGroup: PromptGroupPreview

  """The agent that the prompt run was associated to"""
  agent: AgentPreview

  """The application that the prompt run was executed within"""
  application: ApplicationPreview

  """The pathfinder that reported the prompt"""
  pathfinder: PathfinderPreview

  """The application user that reported the prompt"""
  applicationUser: ApplicationUserPreview

  """The code package that the prompt was reported for"""
  codePackage: CodePackagePreview

  """The repository that the prompt was reported for"""
  repository: RepositoryPreview

  """The thread that the prompt was found within"""
  promptThread: PromptThreadPreview

  """The user that the prompt run was executed by"""
  user: UserPreview

  """The API key that executed or reported the prompt run"""
  apiKey: ApiKeyPreview

  """The contract scan that the prompt run was related to"""
  contractScan: ContractScanPreview

  """The contract that the prompt run was run again"""
  contract: ContractPreview

  """The large language model that executed the prompt"""
  largeLanguageModel: LargeLanguageModelPreview!

  """The attribute values used to label this assessment"""
  attributeValues: [AttributeValue!]!

  """Data sub categories that were detected in the prompt runs"""
  dataSubCategories: [DataSubCategoryPreview!]!
}

"""
When a prompt run message returns JSON data, this is the parsed version of that JSON data
"""
type PromptRunField {
  """The name of the field"""
  name: String!

  """The JSON stringified value of that data"""
  value: String!
}

"""Inputs for filtering prompt runs"""
input PromptRunFiltersInput {
  """The ids of the prompt runs"""
  ids: [ID!]

  """The ids of the prompts"""
  promptIds: [ID!]

  """The ids of the prompt groups"""
  promptGroupIds: [ID!]

  """The ids of the large language models"""
  largeLanguageModelIds: [ID!]

  """The ids of the users who recorded the prompt run"""
  userIds: [ID!]

  """The ids of the contract scans that the prompt was run for"""
  contractScanIds: [ID!]

  """The ids of the pathfinders that reported the run"""
  pathfinderIds: [ID!]

  """The ids of the applications that reported the run"""
  applicationIds: [ID!]

  """The ids of the application users that reported the run"""
  appUserIds: [ID!]

  """Filter by specific subcategory of personal data"""
  dataSubCategoryIds: [ID!]

  """The ids of the api keys that recorded for the prompt run"""
  apiKeyIds: [ID!]

  """
  The ids of the teams that reported the prompt run (looked up by users on team)
  """
  teamIds: [ID!]

  """Filter by specific code packages"""
  codePackageIds: [ID!]

  """Filter by specific repositories"""
  repositoryIds: [ID!]

  """Filter by specific contracts"""
  contractIds: [ID!]

  """The statuses of the prompt runs"""
  statuses: [QueueStatus!]

  """The product areas of the prompt runs"""
  productAreas: [PromptRunProductArea!]

  """Filter by text (title of the prompt)"""
  text: String
}

"""A message in a chain of messages for a prompt run"""
type PromptRunMessage {
  """The id of the prompt run message"""
  id: ID!

  """The message that was sent to the LLM"""
  message: String!

  """The template the the message was generated from"""
  template: String

  """The role of the message (user input, ai assistant, etc)"""
  role: ChatCompletionRole!

  """The date the message was created"""
  createdAt: Date!

  """The parsed fields from the message when the response is JSON"""
  parsedFields: [PromptRunField!]!

  """The categories of data that were extracted from the message"""
  dataCategories: [DataSubCategoryTextMatch!]!
}

"""An input message when recording prompt runs"""
input PromptRunMessageInput {
  """The message that was sent to the LLM"""
  message: String!

  """The template the the message was generated from"""
  template: String

  """The role of the message (user input, ai assistant, etc)"""
  role: ChatCompletionRole!
}

"""The order for a PromptRun query"""
input PromptRunOrder {
  """The field that the PromptRun nodes should be ordered by"""
  field: PromptRunOrderField!

  """
  The direction in which to order the PromptRun nodes by the specified field
  """
  direction: OrderDirection!
}

type PromptRunsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptRun"""
  nodes: [PromptRun!]!

  """int"""
  totalCount: Int!
}

"""
When templating prompts, the set of data that is necessary to fill in said template
"""
input PromptRunVariableInput {
  """Name of the variable"""
  name: String!

  """JSON stringified data to be used for that variable"""
  data: String!
}

type PromptsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Prompt"""
  nodes: [Prompt!]!

  """int"""
  totalCount: Int!
}

type PromptsWithVariablesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptTemplated"""
  prompts: [PromptTemplated!]!

  """A list of PromptPartialTemplated"""
  promptPartials: [PromptPartialTemplated!]!

  """A list of PromptGroupTemplated"""
  promptGroups: [PromptGroupTemplated!]!

  """A list of PromptVariableData"""
  calculatedVariables: [PromptVariableData!]!

  """A list of PromptVariableFormItem"""
  runtimeVariables: [PromptVariableFormItem!]!
}

"""Input for fetching prompts and their associated variables"""
input PromptsWithVariablesInput {
  """The ids of the prompts to get variables for"""
  promptIds: [ID!]

  """The titles of the prompts to get variables for"""
  promptTitles: [String!]

  """The ids of the prompt groups to get variables for"""
  promptGroupIds: [ID!]

  """The titles of the prompt groups to get variables for"""
  promptGroupTitles: [String!]

  """The ids of the prompt partials to get variables for"""
  promptPartialIds: [ID!]

  """The titles of the prompt partials to get variables for"""
  promptPartialTitles: [String!]
}

"""Prompt with all information necessary to render it"""
type PromptTemplated {
  """The id of the prompt"""
  id: ID!

  """The title of the prompt"""
  title: String!

  """The status of the prompt"""
  status: PromptStatus!

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """
  The expected mode in which response text is returned - commonly set to json_object to return JSON data
  """
  responseFormat: PromptResponseFormat!

  """The content of the prompt"""
  content: String!

  """The date the prompt was created"""
  createdAt: Date!

  """The date the prompt was last updated"""
  updatedAt: Date!
}

"""
A thread that was contains context that a large language model will run against
"""
type PromptThread {
  """The id of the prompt thread"""
  id: ID!

  """The ID of the thread in the remote system"""
  threadId: String!

  """The ts of the slack message is the thread is a slack conversation"""
  slackMessageTs: String

  """The ID of the slack team if the thread is a slack conversation"""
  slackTeamId: String

  """The ID of the slack channel if the thread is a slack conversation"""
  slackChannelId: String

  """The name of the slack channel if the thread is a slack conversation"""
  slackChannelName: String

  """The number of runs against this thread"""
  promptRunCount: Int!

  """The number of messages in the thread"""
  messageCount: Int!

  """The employee user that started the thread."""
  user: UserPreview

  """The API key that reported the thread."""
  apiKey: ApiKeyPreview

  """The application that reported the thread."""
  application: ApplicationPreview

  """The pathfinder that reported the thread."""
  pathfinder: PathfinderPreview

  """The application user that started the thread."""
  applicationUser: ApplicationUserPreview
}

"""Inputs for filtering prompt threads"""
input PromptThreadFiltersInput {
  """The ids of the prompt threads"""
  ids: [ID!]

  """The ids of the users who created a prompt thread"""
  creatorIds: [ID!]

  """The ids of the API keys who created a prompt thread"""
  apiKeyIds: [ID!]

  """The ids of the application users who created a prompt thread"""
  applicationUsersIds: [ID!]

  """The ids of the pathfinders who created a prompt thread"""
  pathfinderIds: [ID!]

  """The ids of the applications that reported a prompt thread"""
  applicationIds: [ID!]

  """Filter by fuzzy text (threadId of the prompt thread)"""
  text: String

  """Filter by exact thread ids"""
  threadIds: [String!]

  """The list of slack message timestamps to filter by"""
  slackMessageTs: [String!]
}

"""The order for a PromptThread query"""
input PromptThreadOrder {
  """The field that the PromptThread nodes should be ordered by"""
  field: PromptThreadOrderField!

  """
  The direction in which to order the PromptThread nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a prompt thread"""
type PromptThreadPreview {
  """The id of the prompt thread"""
  id: ID!

  """The ID of the thread in the remote system"""
  threadId: String!

  """The ts of the slack message is the thread is a slack conversation"""
  slackMessageTs: String

  """The ID of the slack team if the thread is a slack conversation"""
  slackTeamId: String

  """The ID of the slack channel if the thread is a slack conversation"""
  slackChannelId: String

  """The name of the slack channel if the thread is a slack conversation"""
  slackChannelName: String
}

type PromptThreadsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptThread"""
  nodes: [PromptThread!]!

  """int"""
  totalCount: Int!
}

"""
When templating prompts, the set of data that is necessary to fill in said template
"""
type PromptVariableData {
  """Name of the variable"""
  name: String!

  """JSON stringified data to be used for that variable"""
  data: String!
}

"""A form item for a prompt"""
type PromptVariableFormItem {
  """The name of the form item value"""
  name: String!
}

"""A pull request that contains code submitted to a particular repository"""
type PullRequest {
  """The id of the pull request"""
  id: ID!

  """The title of the pull request"""
  title: String!

  """The description of the pull request"""
  description: String!

  """The URL of the pull request"""
  url: String!

  """The ID of the pull request in the remote tool"""
  remoteId: String!

  """The date the pull request was created"""
  createdAt: Date!

  """The date the pull request was last updated"""
  updatedAt: Date!

  """The repository that pull request is created for"""
  repository: RepositoryPreview!

  """The users that made the pull request"""
  users: [UserPreview!]!
}

"""Inputs for filtering a list of pull requests"""
input PullRequestFiltersInput {
  """The ids of the pull requests"""
  ids: [ID!]

  """The ids of the users that created the pull requests"""
  userIds: [ID!]

  """The ids of the repositories that the pull requests are made to"""
  repositoryIds: [ID!]

  """Filter by text (title, description, url)"""
  text: String

  """Filter by pull request title"""
  title: String

  """Filter on exact pull request titles"""
  titles: [String!]
}

"""The order for a PullRequest query"""
input PullRequestOrder {
  """The field that the PullRequest nodes should be ordered by"""
  field: PullRequestOrderField!

  """
  The direction in which to order the PullRequest nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a pull request instance"""
type PullRequestPreview {
  """The id of the pull request"""
  id: ID!

  """The title of the pull request"""
  title: String!

  """The description of the pull request"""
  description: String!

  """The URL of the pull request"""
  url: String!

  """The ID of the pull request in the remote tool"""
  remoteId: String!

  """The date the pull request was created"""
  createdAt: Date!

  """The date the pull request was last updated"""
  updatedAt: Date!
}

type PullRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PullRequest"""
  nodes: [PullRequest!]!

  """int"""
  totalCount: Int!
}

"""Request for upserting consent record from the Privacy Center"""
input PurposeInput {
  """Tracking purpose"""
  purpose: String!

  """Whether the user has given consent for this purpose"""
  consent: Boolean!

  """User preferences for this purpose"""
  preferences: [PreferenceInput!]
}

"""Metadata on a top-level data processing category"""
type PurposeOfProcessing implements ProcessingPurposeInterface {
  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!

  """The number of sub-datapoints related to the processing purpose"""
  subDataPointCount: Int!

  """The number of vendors related to the processing purpose"""
  vendors: [VendorPreview!]!

  """The business entities that the processing purpose belongs to"""
  businessEntities: [BusinessEntityPreview!]!
}

"""The order for a Purpose query"""
input PurposeOrder {
  """The field that the Purpose nodes should be ordered by"""
  field: PurposeOrderField!

  """
  The direction in which to order the Purpose nodes by the specified field
  """
  direction: OrderDirection!
}

type PurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TrackingPurpose"""
  nodes: [TrackingPurpose!]!

  """int"""
  totalCount: Int!
}

"""purpose"""
type PurposeSchema {
  """Tracking purpose"""
  purpose: String!

  """Whether the user has given consent for this purpose"""
  consent: Boolean!

  """User preferences for this purpose"""
  preferences: [PreferenceSchema!]
}

"""Details about a subcategory of a purpose of processing"""
type PurposeSubCategory implements ProcessingPurposeInterface & ProcessingPurposeSubCategoryInterface {
  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!

  """The ID of the subpurpose"""
  id: ID!

  """The purpose of processing subcategory"""
  name: String!

  """Whether this is a default processing subcategory"""
  isDefault: Boolean!

  """The number of sub-datapoints related to the processing purpose"""
  subDataPointCount: Int!

  """The number of vendors related to the processing purpose"""
  vendors: [VendorPreview!]!

  """The business entities that the processing purpose belongs to"""
  businessEntities: [BusinessEntityPreview!]!

  """The attribute values used to label this processing purpose"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this processing purpose subcategory
  """
  owners: [UserPreview!]!

  """
  The list of teams who are responsible for managing this processing purpose subcategory
  """
  teams: [TeamPreview!]!

  """
  The headquarter regions assigned to vendors whose data silos or their subdatapoints have this processing purpose subcategory
  """
  vendorHeadquarterLocations: [String!]!

  """
  The regions assigned to data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloRegions: [String!]!

  """
  The users assigned as owners to data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloOwners: [UserPreview!]!

  """
  The users assigned as owners to vendors whose data silos or their subdatapoints have this processing purpose subcategory
  """
  vendorOwners: [UserPreview!]!

  """
  The data subcategories assigned to data silos and subdatapoints with this processing purpose subcategory
  """
  dataSubCategories: [DataSubCategoryPreview!]!

  """
  The super categories associated data silos and subdatapoints that have this processing purpose subcategory
  """
  superCategories: [AttributeValue!]!

  """
  The type of retention schedule for subdatapoints with this processing purpose subcategory, or the number of days data is retained for, if type is stated period
  """
  subDataPointRetentionSchedules: [String!]!

  """
  The recipient categories for data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  catalogRecipients: [SaaSCategoryBase!]!

  """
  The data silos that have or whose subdatapoints have this processing purpose
  """
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """
  The data subjects for data silos that have or whose subdatapoints have this processing purpose subcategory
  """
  dataSiloDataSubjects: [DataSubject!]!

  """
  The controllerships assigned to data silos and subdatapoints with this processing purpose subcategory
  """
  controllerships: [Controllership!]!

  """The sensitive categories that are related to this processing purpose"""
  sensitiveCategories: [SensitiveCategory!]
}

"""Details about a subcategory of a purpose of processing"""
input PurposeSubCategoryInput {
  """The purpose of processing subcategory"""
  name: String!

  """The purpose of processing"""
  purpose: ProcessingPurpose!
}

"""Details about a subcategory of a purpose of processing"""
type PurposeSubCategoryPreview implements ProcessingPurposeSubCategoryInterface {
  """The purpose of processing"""
  purpose: ProcessingPurpose!

  """A description of this purpose of processing"""
  description: String!

  """The slug of the processing purpose for templating"""
  slug: String!

  """The ID of the subpurpose"""
  id: ID!

  """The purpose of processing subcategory"""
  name: String!

  """Whether this is a default processing subcategory"""
  isDefault: Boolean!
}

"""Input for fetching actionItemSubscriptions"""
input QueryActionItemSubscriptionInput {
  """Whether query is fetching org or user level subscriptions"""
  orgLevelSubscriptions: Boolean
}

"""Rate limit configuration"""
type RateLimitConfig {
  """Rate limit type"""
  rateLimitType: String!

  """Rate limit quantity"""
  rateLimitQuantity: Int!

  """Milliseconds to wait upon exhaustion of this rate limit"""
  rateLimitWaitTimeMs: Int!

  """Unix epoch in milliseconds to when the rate limit will reset"""
  rateLimitResetAt: Date!

  """Number of calls made against this rate limit"""
  counter: Int!

  """If this rate limit has been modified/added by a user"""
  isUserModified: Boolean!
}

"""Rate limit configuration for a data silo"""
input RateLimitConfigInput {
  """Rate limit type"""
  rateLimitType: String!

  """Rate limit quantity"""
  rateLimitQuantity: Int!

  """Milliseconds to wait upon exhaustion of this rate limit"""
  rateLimitWaitTimeMs: Int!
}

"""Information about a cookie that was reclassified"""
type ReclassifiedCookie {
  """The ID of the airgap bundle"""
  airgapBundleId: ID!

  """The name of the cookie"""
  cookieName: String!

  """Whether the reclassification was successful"""
  success: Boolean!

  """Error message if the reclassification failed"""
  error: String
}

"""Information about a data flow that was reclassified"""
type ReclassifiedDataFlow {
  """The ID of the airgap bundle"""
  airgapBundleId: ID!

  """The value of the data flow"""
  value: String!

  """Whether the reclassification was successful"""
  success: Boolean!

  """Error message if the reclassification failed"""
  error: String
}

"""Input for a single cookie to reclassify"""
input ReclassifyCookieInput {
  """The ID of the airgap bundle"""
  airgapBundleId: ID!

  """The name of the cookie to reclassify"""
  cookieName: String!
}

type ReClassifyCookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for reclassifying cookies"""
input ReclassifyCookiesInput {
  """The list of cookies to reclassify"""
  cookies: [ReclassifyCookieInput!]!
}

"""Input for a single data flow to reclassify"""
input ReclassifyDataFlowInput {
  """The ID of the airgap bundle"""
  airgapBundleId: ID!

  """The value of the data flow to reclassify"""
  value: String!

  """The type of data flow"""
  type: DataFlowScope!
}

type ReClassifyDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for reclassifying data flows"""
input ReclassifyDataFlowsInput {
  """The list of data flows to reclassify"""
  dataFlows: [ReclassifyDataFlowInput!]!
}

"""Recommendations of different categories discovered in a given file"""
type RecommendationPreview {
  """Recommendation id"""
  id: ID!

  """Name of the subdatapoint recommendations"""
  name: String!

  """Context Snippet"""
  contextSnippet: String

  """
  The set of data categories assigned to the sub-datapoints of this datapoint
  """
  dataSubCategory: DataSubCategoryPreview

  """The confidence score for this recommendation"""
  confidence: Float

  """The method that identified this unstructured subDataPoint entity"""
  classificationMethod: UnstructuredClassificationMethod

  """The status of this recommendation"""
  status: UnstructuredSubDataPointRecommendationStatus
}

type RecommendedCatalogsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Catalog"""
  catalogs: [Catalog!]!
}

"""Input for fetching recommendedCatalogs"""
input RecommendedCatalogsInput {
  """The maximum number of results to return"""
  limit: Int
}

type ReconnectDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A place in the organization where data sits. This could be a database, SaaS tool, filing cabinet, etc.
  """
  dataSilo: DataSilo!
}

"""Input to reconnect a SaaS integration"""
input ReconnectDataSiloInput {
  """The ids of the teams that should be responsible for this data silo"""
  teams: [ID!]

  """The unique ids of the users to assign as owners of this data silo"""
  ownerIds: [ID!]

  """The title of the data silo"""
  title: String

  """The id of template to use when prompting via email"""
  promptEmailTemplateId: ID

  """
  The email of the person that should be notified (an account will be created)
  """
  notifyEmailAddress: String

  """The description of the data silo"""
  description: String

  """The URL to send POST request notifications to"""
  url: String

  """The id of the associated data silo"""
  dataSiloId: ID!

  """A presigned JWT containing the SaaS Context for an integration."""
  presignedSaasContext: String

  """The form input plaintext"""
  plaintextContext: [PlaintextContextInput!]
}

"""Token to continue fetching consent records"""
type RecordOfConsentNextToken {
  """AWS statement ID"""
  statementId: String!

  """String token to continue fetching records"""
  nextToken: String!
}

"""Token to continue fetching consent records"""
input RecordOfConsentNextTokenInput {
  """AWS statement ID"""
  statementId: String!

  """String token to continue fetching records"""
  nextToken: String!
}

type RecordsOfConsentPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ConsentRecord"""
  nodes: [ConsentRecord!]!

  """Token to continue fetching consent records"""
  nextToken: RecordOfConsentNextToken

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""Input for querying records of consent"""
input RecordsOfConsentInput {
  """
  The partition to lookup consent for (by default, this is the consent manager or airgap bundle id
  """
  partition: String!

  """
  Only return records with consent events before this timestamp; default is now
  """
  timestampBefore: String

  """Only return records with consent events after this timestamp"""
  timestampAfter: String

  """Only return records updated before this timestamp"""
  updatedBefore: String

  """Only return records updated after this timestamp"""
  updatedAfter: String

  """Identifiers to query for, in plaintext"""
  identifiers: [String!]

  """Token to continue fetching records of consent"""
  nextToken: RecordOfConsentNextTokenInput
}

"""The JSON path to redact"""
input RedactPathInput {
  """The JSON path itself"""
  path: String!

  """The selections to redact"""
  selections: [SelectionInput!]!
}

"""Input to update the redact indices for a request file"""
input RedactRequestFileInput {
  """The id of the request file to redact"""
  requestFileId: ID!

  """The JSON paths and indices to redact"""
  redactionIndices: [RedactPathInput!]!
}

type RedactRequestFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestFile"""
  requestFiles: [RequestFile!]!
}

"""Input to update the redact indices for a set of request files"""
input RedactRequestFilesInput {
  """The set of redactions to make"""
  redactions: [RedactRequestFileInput!]!
}

"""
Represents a subset of the data subject request fields merged with fields to be consumed by the bulk request completion UI
"""
type ReducedRequestPreview {
  """The unique ID of the request"""
  id: ID!

  """The type of request being made"""
  type: RequestAction!

  """The status of request being made"""
  status: RequestStatus!

  """The email to communicate with"""
  email: String

  """The number of days remaining until overdue"""
  daysRemaining: Int

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The total number of days that the request is valid for"""
  overdueTime: Int!

  """The request identifiers to lookup the data subject by"""
  requestIdentifiers: [RequestIdentifier!]!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The attribute values used to label this request"""
  attributeValues: [AttributeValue!]!

  """The type of the data subject, unique to the organization"""
  subjectType: String!

  """Details submitted in the request form"""
  details: String

  """The title of the data subject"""
  subjectTitle: DefinedMessage!
}

type RefetchSubDataPointSamplePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SubDataPoint"""
  subDataPoints: [SubDataPoint!]!
}

"""Input for refetching sample for a group of subdatapoint"""
input RefetchSubDataPointSampleInput {
  """The id of the data silo"""
  dataSiloId: ID!

  """Metadata about how samples for each sub datapoint should be refetched"""
  subDataPoints: [SubDataPointRefetchSampleInfoInput!]!
}

"""ISO 3166 defined country and country subdivision"""
type Region {
  """A country's ISO code"""
  country: IsoCountryCode!

  """A country subdivision ISO code"""
  countrySubDivision: String
}

"""A country and country subdivision nested in that country"""
input RegionInput {
  """A country's ISO code"""
  country: IsoCountryCode

  """A country subdivision ISO code"""
  countrySubDivision: String
}

type RemoveDataSiloFromWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type RemoveEnrichersFromWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to remove enrichers from a given workflow"""
input RemoveEnrichersFromWorkflowConfigInput {
  """The workflow config ID"""
  workflowConfigId: ID!

  """list of enricher ids to remove"""
  enrichers: [ID!]!
}

type RemoveRequestIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  count: Int!
}

"""Input for removing RequestIdentifiers"""
input RemoveRequestIdentifiersInput {
  """The unique ID of the data subject request"""
  requestId: ID!

  """The RequestIdentifiers to delete"""
  requestIdentifierIds: [ID!]!
}

type RemoveSombraPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type RemoveTcfStacksFromBundlePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type RemoveUserPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for removing a user"""
input RemoveUserInput {
  """The email of the user to remove"""
  email: String
}

type ReportPromptRunPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An instance of running a prompt"""
  promptRun: PromptRun!
}

"""Input for recording the execution of a prompt that is run on premise"""
input ReportPromptRunInput {
  """
  The name of the prompt run (specified in API or derived from the file input)
  """
  name: String!

  """Error message to report when an error occurs"""
  error: String

  """The product area that the prompt run is a part of"""
  productArea: PromptRunProductArea!

  """The status of the prompt run"""
  status: QueueStatus

  """The email address of employee that ran the prompt"""
  runByEmployeeEmail: String

  """The number of milliseconds it took to run the message"""
  duration: Int

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """The id of the prompt being executed"""
  promptId: ID

  """The title of the prompt being executed"""
  promptTitle: String

  """The id of the prompt group being executed"""
  promptGroupId: ID

  """The title of the prompt group being executed"""
  promptGroupTitle: String

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """The Transcend UUID of the prompt thread that this run is a part of"""
  promptThreadId: ID

  """
  The promptThread.threadId ID that the prompt run is a part of. This may be the thread ID for the remote system such as OpenAI.
  """
  threadId: String

  """
  The ts of the slack message if this run is in response to a slack message
  """
  slackMessageTs: String

  """The ID of the slack team if the run is in response to a slack message"""
  slackTeamId: String

  """
  The ID of the slack channel if the run is in response to a slack message
  """
  slackChannelId: String

  """
  The name of the slack channel if the thread is in response to a slack message
  """
  slackChannelName: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The ID of the agent that reported the prompt run"""
  agentId: ID

  """The name of the agent that reported the prompt run"""
  agentName: String

  """The remote ID of the agent - agent.agentId"""
  agentRemoteId: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The id of the large language model being executed"""
  largeLanguageModelId: ID

  """The name of the large language model being executed"""
  largeLanguageModelName: String

  """The client of the large language model being executed"""
  largeLanguageModelClient: LargeLanguageModelClient

  """The messages in the prompt run"""
  promptRunMessages: [PromptRunMessageInput!]!
}

type RepositoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Repository"""
  nodes: [Repository!]!

  """int"""
  totalCount: Int!
}

"""A repository where code is stored"""
type Repository {
  """The id of the repository"""
  id: ID!

  """The name of the repository instance"""
  name: String!

  """The description of the repository instance"""
  description: String!

  """The URL of the repository service"""
  url: String!

  """The date the repository was created"""
  createdAt: Date!

  """The date the repository was last updated"""
  updatedAt: Date!

  """The number of code packages in this repository"""
  codePackageCount: Int!

  """The number of SDKs in this repository"""
  softwareDevelopmentKitCount: Int!

  """The number of pull requests that are made against this repository"""
  pullRequestCount: Int!

  """The number of prompt runs that this repository has ran"""
  promptRunCount: Int!

  """
  The list of individual users who are responsible for managing this repository
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this repository"""
  teams: [TeamPreview!]!
}

"""Inputs for filtering a list of repositories"""
input RepositoryFiltersInput {
  """The ids of the repositories"""
  ids: [ID!]

  """The ids of the owners that are mapped to this repository"""
  ownerIds: [ID!]

  """The ids of the teams that are mapped to this repository"""
  teamIds: [ID!]

  """The ids of the SDKs in this repository"""
  softwareDevelopmentKitIds: [ID!]

  """Filter by text (title, description, url)"""
  text: String

  """Fuzzy search by repository name"""
  name: String

  """Filter on exact repository names"""
  names: [String!]
}

"""The order for a Repository query"""
input RepositoryOrder {
  """The field that the Repository nodes should be ordered by"""
  field: RepositoryOrderField!

  """
  The direction in which to order the Repository nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a code repository"""
type RepositoryPreview {
  """The id of the repository"""
  id: ID!

  """The name of the repository instance"""
  name: String!

  """The description of the repository instance"""
  description: String!

  """The URL of the repository service"""
  url: String!

  """The date the repository was created"""
  createdAt: Date!

  """The date the repository was last updated"""
  updatedAt: Date!
}

"""Represents a data subject request"""
type Request implements RequestInterface {
  """The unique ID of the data subject request"""
  id: ID!

  """The time the request was made"""
  createdAt: Date!

  """The time the request was last updated"""
  updatedAt: Date!

  """The time the request was last transitioned"""
  lastTransitionTime: Date

  """The time at which the secondary action will begin"""
  secondaryStartTime: Date

  """The current status of the request"""
  status: RequestStatus!

  """The type of request being made"""
  type: RequestAction!

  """The active type of the request being made"""
  activeType: RequestAction!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The type of data subject, unique to the organization"""
  subjectType: String!

  """The locale the request should be translated to"""
  locale: String!

  """Additional details submit with the request"""
  details: String

  """The DSR report template to send"""
  report: LocalizedTemplate

  """The DSR secondary report template to send after deletion is completed"""
  secondaryReport: LocalizedTemplate

  """The time the compiling phase was completed"""
  reportSendTime: Date

  """The time the ERASURE report was sent"""
  secondaryReportSendTime: Date

  """The time the report was opened if a download link was included"""
  reportOpenedTime: Date

  """
  Indicates if report has been opened, else undefined if not relevant in the context
  """
  isOpened: Boolean

  """Indicator as to whether the request can be downloaded"""
  canDownload: Boolean!

  """
  Indicator as to whether the request can be viewable by data subject on Privacy Center
  """
  canViewByDataSubject: Boolean!

  """Indicator as to whether the request can be revoked"""
  canRevoke: Boolean!

  """
  Indicator as to whether the request is active from the employee's perspective
  """
  isActive: Boolean!

  """Indicator as to whether the request is completed"""
  isClosed: Boolean!

  """Indicator as to whether the request has been archived"""
  isArchived: Boolean!

  """
  Indicator as to whether the request is active from the data subjects perception
  """
  isActiveDataSubject: Boolean!

  """The email to communicate with"""
  email: String

  """
  The core identifier is the global user identifier specific to the organization
  """
  coreIdentifier: String!

  """Is the Encrypted CEK context for a request expired"""
  isContextExpired: Boolean!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The consent purpose that triggered this DSR and its boolean value"""
  purpose: DsrPurposeChange

  """
  The partition key that this DSR is kicked off for (often the data controller that the request is scoped to)
  """
  partition: ConsentPartition

  """The data subject class information"""
  subject: DataSubject!

  """The list of individual users who are assigned to this request"""
  owners: [UserPreview!]!

  """The list of teams who are assigned to this request"""
  teams: [TeamPreview!]!

  """The data subject action configuration"""
  action: ActionPreview!

  """The total number of days that the request is valid for"""
  overdueTime: Int!

  """
  If the request is completed, the total amount of time it took to complete the request, in minutes.
  """
  completionDuration: Float

  """
  If the request is completed, the time at which it was successfully completed. This is adjusted to handle the different completion statuses for erasure requests vs other request types. Only requests with a successfullyCompletedAt timestamp will have completionDuration calculated.
  """
  successfullyCompletedAt: Date

  """The percentage of time until the request is overdue"""
  overduePercentage: Float!

  """The number of days remaining until overdue"""
  daysRemaining: Int

  """The number of times that the emails in the request have bounced"""
  bounced: Int!

  """Indicates if the request is a test request"""
  isTest: Boolean!

  """Indicates if the request is silent and should not be sending messages"""
  isSilent: Boolean!

  """Indicates by what means the request was made"""
  origin: RequestOrigin!

  """The link the request lives at on the admin dashboard"""
  link: String!

  """The workflow for the request"""
  steps: RequestSteps!

  """ID of the parent request"""
  parentId: ID

  """ID of an open child request of the same type as this one"""
  openChildRequestId: ID

  """
  A set of email addresses that should be CC'd on any communications send for that request.
  """
  replyToEmailAddresses: [String!]!

  """
  The status of the connection between the request and the data silo in context
  """
  dataSiloConnectionStatus: RequestDataSiloConnectionStatus

  """The attribute values used to label this request"""
  attributeValues: [AttributeValue!]!

  """The workflow for the request if started from a workflow"""
  workflowConfig: WorkflowConfig
}

type RequestCertificatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An SSL certificate issued for the privacy center"""
  certificate: Certificate!
}

"""The status of looking up a DSR in a data silo"""
type RequestDataSilo {
  """The unique ID of the request data silo lookup"""
  id: ID!

  """The ID of the data silo in reference"""
  dataSiloId: ID!

  """The ID of the request in reference"""
  requestId: ID!

  """Link to the request data silo on the admin dashboard"""
  link: String!

  """Notes specific to this RequestDataSilo"""
  details: String!

  """The exposed details of the request"""
  request: RequestDetails!

  """The current status of the request/data silo combo"""
  status: VisualRequestDataSiloStatus!

  """Indicates if the request data silo is in an editable state"""
  canEdit: Boolean!

  """
  Whether or not the current user can change the status of the request data silo
  """
  canChangeStatus: Boolean!

  """The related data silo information"""
  dataSilo: DataSiloBulkPreview!

  """The profiles associated with a request data silo"""
  profiles: [Profile!]!

  """The number of profiles being processed"""
  profileCount: Int!

  """The number of request files that have been found"""
  requestFileCount: Int!

  """The error message if there is one"""
  error: String

  """When the next action is scheduled"""
  scheduledAt: Date!
}

"""Input for finding a request data silo's data points"""
input RequestDataSiloDataPointInput {
  """Filter by datapoint name"""
  text: String

  """The ID of the profile being viewed"""
  profileId: ID
}

type RequestDataSiloDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataPointSummary"""
  nodes: [DataPointSummary!]!

  """int"""
  totalCount: Int!
}

"""Input for finding a request data silo"""
input RequestDataSiloFiltersInput {
  """The ID of the data silo in reference"""
  dataSiloId: ID

  """The ID of the request in reference"""
  requestId: ID

  """The status of the request data silo"""
  status: [RequestDataSiloStatus!]

  """The status of the request to filter on"""
  requestStatus: [RequestStatus!]

  """The text to filter the data silos by"""
  text: String

  """Filter for data silos that are deleted"""
  isDeleted: Boolean

  """Filter by the connection state"""
  connectionState: [DataSiloConnectionState!]
}

"""Input for finding a request data silo"""
input RequestDataSiloInput {
  """The ID of the data silo in reference"""
  dataSiloId: ID!

  """The ID of the request in reference"""
  requestId: ID!
}

"""The order for a RequestDataSilo query"""
input RequestDataSiloOrder {
  """The field that the RequestDataSilo nodes should be ordered by"""
  field: RequestDataSiloOrderField!

  """
  The direction in which to order the RequestDataSilo nodes by the specified field
  """
  direction: OrderDirection!

  """The associated model whose field to order by"""
  model: RequestDataSiloSortAssociation
}

type RequestDataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestDataSilo"""
  nodes: [RequestDataSilo!]!

  """int"""
  totalCount: Int!
}

type RequestDemoPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  Submit a demo request. This is not our real demo form and is used for testing.
  """
  demo: Demo!
}

"""Request details exposed when accessing a request data silo"""
type RequestDetails {
  """The unique ID of the request"""
  id: ID!

  """The time the request was created"""
  createdAt: Date!

  """The type of the request"""
  type: RequestAction!

  """TThe active type of the request"""
  activeType: RequestAction!

  """The type of data subject"""
  subjectType: String!

  """The current status of the request"""
  status: RequestStatus!

  """Indicates if the request is a test request"""
  isTest: Boolean!

  """The main email address used for communication"""
  email: String

  """
  The core identifier is the global user identifier specific to the organization
  """
  coreIdentifier: String!
}

type RequestEmailBouncedPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  done: Boolean!
}

"""Input for logging that an email bounced"""
input RequestEmailBouncedInput {
  """A JWT containing the parameters to log a request email bouncing"""
  requestEmailBouncedJWT: String!
}

"""A request enrichment that needs to be responded to"""
type RequestEnricher {
  """The unique id of the RequestEnricher"""
  id: ID!

  """The id of the request in process"""
  requestId: ID!

  """The enricher configuration"""
  enricher: Enricher!

  """The error message if one exists"""
  error: String

  """The status of the request enricher"""
  status: RequestEnricherStatus!

  """The request identifier that is being responded to"""
  inputRequestIdentifier: RequestIdentifier

  """
  Indicator as to whether the request enricher verified the identifier or not. Only provided when input.requestIdentifierId provided.
  """
  isVerified: Boolean

  """The number of RequestIdentifiers found by this RequestEnrichers"""
  requestIdentifierCount: Int!

  """
    When sombra signs an identifier, there is an underlying authentication method that did the verification
  (Usually one of "SombraDataSubjectAuthMethod"). Only provided when input.requestIdentifierId provided.
  """
  initialAuthMethod: String

  """When the next action is scheduled"""
  scheduledAt: Date!

  """Poll ID for polling results"""
  pollId: String

  """URL used for verification"""
  verificationUrl: String
}

"""
The edge indicating that a request enricher is attesting to a request identifier
"""
type RequestEnricherRequestIdentifier {
  """The ID of the RequestEnricherRequestIdentifier"""
  id: ID!

  """The ID of the request enricher"""
  RequestEnricherId: ID!

  """The ID of the request identifier"""
  RequestIdentifierId: ID!

  """The JWT signing the identifier values"""
  jwt: String

  """
  Indicator that the request enricher is verifying the request identifier
  """
  isVerified: Boolean!
}

type RequestEnrichersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestEnricher"""
  nodes: [RequestEnricher!]!

  """int"""
  totalCount: Int!
}

"""Input for searching for Enrichers"""
input RequestEnrichersFiltersInput {
  """Filter by arbitrary text (search on: title)"""
  text: String

  """Filter by status"""
  statuses: [RequestEnricherStatus!]
}

"""Input for RequestEnrichers"""
input RequestEnrichersInput {
  """The unique ID of the data subject request"""
  requestId: ID!

  """The unique ID of the RequestIdentifier to filter RequestEnrichers for"""
  requestIdentifierId: ID
}

"""The order for a RequestEnricher query"""
input RequestEnricherOrder {
  """The field that the RequestEnricher nodes should be ordered by"""
  field: RequestEnricherOrderField!

  """
  The direction in which to order the RequestEnricher nodes by the specified field
  """
  direction: OrderDirection!

  """The associated model whose field to order by"""
  model: RequestEnricherSortAssociation
}

"""A download file viewed from the administrator perspective"""
type RequestFile implements RequestFileInterface {
  """
  The file size in bytes as a string because graphql does not play well with larger numbers
  """
  size: String!

  """The mimetype of the file"""
  mimetype: String!

  """The unique id of the request file"""
  id: ID!

  """The URL to download the file"""
  downloadUrl: String!

  """The name of the file once downloaded"""
  fileName: String!

  """The authTag of the encrypted file"""
  authTag: String!

  """The iv randomness of the encrypted file"""
  iv: String!

  """Stringified redaction indices"""
  redactIndices: String!

  """ID of the profile datapoint"""
  ProfileDataPointId: ID!

  """The error that occurred when processing the request file"""
  error: String

  """The time that the file was created"""
  createdAt: Date!

  """The id of the file in the remote system"""
  remoteId: String

  """A link to the file in the remote system"""
  link: String

  """
  The status of that request file in respect to being processed in the remote system
  """
  status: RequestFileStatus!

  """The type of action that will be taken when secondary action happens"""
  queueType: RequestFileQueueType!

  """The URL of the file to use if need to peek at the file contents."""
  peekUrl: String!

  """Stringified context"""
  context: String!

  """
  The base64 encoded key containing information needed to download the file
  """
  downloadKey: String

  """When the next action is scheduled"""
  scheduledAt: Date!

  """The data point that this file is associated with"""
  dataPoint: RequestFileDataPointPreview!
}

"""
Previews associated datapoint information. Used as download file metadata
"""
type RequestFileDataPointPreview implements DataPointInterface {
  """The unique ID of the datapoint"""
  id: ID!

  """The display title of the datapoint"""
  title: DefinedMessage

  """A brief overview of the datapoint"""
  description: DefinedMessage

  """The identifying name/key of the datapoint"""
  name: String!

  """Additional metadata about the datapoint"""
  metadata: DataPointMetadata!

  """The slug of the datapoint for templating"""
  slug: String!

  """The id of the data silo that contains the datapoint"""
  dataSiloId: ID!

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType

  """
  The allowed mime types for the datapoint. Empty list implies all mime types allowed
  """
  allowedMimeTypes: [String!]!

  """The data silo for this datapoint"""
  dataSilo: RequestFileDataSiloPreview!

  """The hierarchy of levels associated with this datapoint"""
  path: [String!]!
}

"""A preview of the data silo that the request file is associated with"""
type RequestFileDataSiloPreview {
  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String
}

"""The input for filtering requestFiles"""
input RequestFileFiltersInput {
  """
      Provide a list of ProfileDataPoints to filter by.
  Cannot be provided with "requestId", "profileId" or "dataSiloId"
  """
  profileDataPointIds: [ID!]

  """
      The id of the profile to get the files for.
  Cannot be provided with "requestId", "profileDataPointId" or "dataSiloId
  """
  profileId: ID

  """
  The id of the request to get files for. Cannot be provided with "profileDataPointId" or "profileId"
  """
  requestId: ID

  """
  The id of the data silo to get files for. Must be provided with "requestId"
  """
  dataSiloId: ID

  """The export mode on the dataPoint"""
  exportMode: [DataPointExportMode!]
}

"""A downloadable encrypted file associated with a request"""
interface RequestFileInterface {
  """
  The file size in bytes as a string because graphql does not play well with larger numbers
  """
  size: String!

  """The mimetype of the file"""
  mimetype: String!

  """The unique id of the request file"""
  id: ID!

  """The URL to download the file"""
  downloadUrl: String!

  """The name of the file once downloaded"""
  fileName: String!

  """The authTag of the encrypted file"""
  authTag: String!

  """The iv randomness of the encrypted file"""
  iv: String!

  """Stringified redaction indices"""
  redactIndices: String!
}

"""The order for a RequestFile query"""
input RequestFileOrder {
  """The field that the RequestFile nodes should be ordered by"""
  field: RequestFileOrderField!

  """
  The direction in which to order the RequestFile nodes by the specified field
  """
  direction: OrderDirection!
}

type RequestFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestFile"""
  nodes: [RequestFile!]!

  """int"""
  totalCount: Int!

  """float"""
  totalSize: Float!
}

type RequestFilesCountsOnlyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DownloadFileCounts"""
  nodes: [DownloadFileCounts!]!
}

type RequestFilesTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestFile"""
  nodes: [RequestFile!]!

  """int"""
  totalCount: Int!

  """string"""
  totalSize: String!
}

"""The input for filtering requestFiles using token based auth"""
input RequestFileTokenFiltersInput {
  """Provide a list of ProfileDataPoints to filter by."""
  profileDataPointIds: [ID!]!
}

"""Filters that can be applied when looking up requests"""
input RequestFiltersForDataSiloInput {
  """
  The id of the data silo to determine if each request has processed or not
  """
  dataSiloId: ID!

  """
  Find any request form inputs or request ids that are like a text string
  """
  text: String

  """Filter only certain request statuses"""
  status: [RequestStatus!]

  """Filter only certain request types"""
  type: [RequestAction!]

  """Filter for test or non test requests"""
  isTest: Boolean

  """Filter to requests for these subjects"""
  subjectIds: [ID!]

  """
  Filter for requests that were created as child requests or filter out child requests
  """
  isChild: Boolean

  """Filter to only requests that have or don't have the silo"""
  requestHasSilo: Boolean

  """Filter to only requests that have errors for the silo"""
  hasErrors: Boolean
}

"""Filters that can be applied when looking up requests"""
input RequestFiltersInput {
  """
  Find any request form inputs or request ids that are like a text string
  """
  text: String

  """Filter only certain request statuses"""
  status: [RequestStatus!]

  """Filter only certain request types"""
  type: [RequestAction!]

  """Filter for requests that are archived"""
  isArchived: Boolean

  """Filter for requests that are closed"""
  isClosed: Boolean

  """Filter for requests that are bounced"""
  isBounced: Boolean

  """Filter for requests that have reports that are opened or not"""
  isOpened: Boolean

  """Filter only certain request origin"""
  origin: [RequestOrigin!]

  """Filter for test or non test requests"""
  isTest: Boolean

  """Filter for silent or non silent requests"""
  isSilent: Boolean

  """Filter for requests with expired CEK contexts"""
  isContextExpired: Boolean

  """Filter for requests that have unread emails"""
  hasUnreadEmails: Boolean

  """Filter for requests that have children"""
  hasChildren: Boolean

  """
  Filter for requests that were created as child requests or filter out child requests
  """
  isChild: Boolean

  """Find requests that are not processing for these data silo IDs"""
  missingDataSiloIds: [ID!]

  """Filter to requests for these subjects"""
  subjectIds: [ID!]

  """Filter to requests after a create date"""
  createdAtAfter: String

  """Filter to requests before a create date"""
  createdAtBefore: String

  """Filter to requests of specific locales"""
  locales: [String!]

  """Filter to requests labeled with specific attribute values"""
  attributeValueIds: [ID!]

  """Filter to requests labeled with specific ISO countries"""
  countries: [IsoCountryCode!]

  """Filter to requests labeled with specific ISO country subdivisions"""
  countrySubDivisions: [String!]

  """Filter to requests by individuals who are assigned to the request"""
  ownerIds: [ID!]

  """Filter to requests by teams who are assigned to the request"""
  teamIds: [ID!]

  """Filter to requests that have enricher errors"""
  hasEnricherErrors: Boolean

  """Filter to requests with an exact identifier value"""
  identifierValue: String

  """
  The partition keys that this DSR is kicked off for (often the data controller in context)
  """
  partitionKeys: [String!]

  """
  The partition key UUIDs that this DSR is kicked off for (often the data controller in context)
  """
  partitionIds: [ID!]

  """Filter on requests triggered by a certain purpose change"""
  purposeNames: [String!]

  """Filter on requests triggered by a certain purpose change"""
  purposeIds: [ID!]
}

"""Represents a data subject request"""
type RequestForDataSilo {
  """The unique ID of the data subject request"""
  id: ID!

  """The time the request was made"""
  createdAt: Date!

  """The current status of the request"""
  status: RequestStatus!

  """The type of request being made"""
  type: RequestAction!

  """The email to communicate with"""
  email: String

  """
  The core identifier is the global user identifier specific to the organization
  """
  coreIdentifier: String!

  """The type of data subject, unique to the organization"""
  subjectType: String!

  """Indicates if the request is a test request"""
  isTest: Boolean!

  """ID of the parent request"""
  parentId: ID

  """ID of an open child request of the same type as this one"""
  openChildRequestId: ID

  """
  The status of the connection between the request and the data silo in context
  """
  dataSiloConnectionStatus: RequestDataSiloConnectionStatus

  """The current status of the request/data silo combo"""
  requestDataSiloStatus: VisualRequestDataSiloStatus

  """The number of request files that this request data silo has resolved"""
  requestFileCount: Int

  """The number of profiles that this request has resolved"""
  profileCount: Int

  """The number of request identifiers that this request has resolved"""
  requestIdentifierCount: Int

  """When the next action is scheduled"""
  scheduledAt: Date

  """The number of errors for the request"""
  errorCount: Int!
}

type RequestHistoryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestHistory"""
  nodes: [RequestHistory!]!

  """int"""
  totalCount: Int!
}

"""A preview of a data subject request"""
type RequestHistory implements RequestInterface {
  """The unique ID of the data subject request"""
  id: ID!

  """The time the request was made"""
  createdAt: Date!

  """The time the request was last updated"""
  updatedAt: Date!

  """The time the request was last transitioned"""
  lastTransitionTime: Date

  """The time at which the secondary action will begin"""
  secondaryStartTime: Date

  """The current status of the request"""
  status: RequestStatus!

  """The type of request being made"""
  type: RequestAction!

  """The active type of the request being made"""
  activeType: RequestAction!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The type of data subject, unique to the organization"""
  subjectType: String!

  """The locale the request should be translated to"""
  locale: String!

  """Additional details submit with the request"""
  details: String

  """The DSR report template to send"""
  report: LocalizedTemplate

  """The DSR secondary report template to send after deletion is completed"""
  secondaryReport: LocalizedTemplate

  """The time the compiling phase was completed"""
  reportSendTime: Date

  """The time the ERASURE report was sent"""
  secondaryReportSendTime: Date

  """The time the report was opened if a download link was included"""
  reportOpenedTime: Date

  """
  Indicates if report has been opened, else undefined if not relevant in the context
  """
  isOpened: Boolean

  """Indicator as to whether the request can be downloaded"""
  canDownload: Boolean!

  """
  Indicator as to whether the request can be viewable by data subject on Privacy Center
  """
  canViewByDataSubject: Boolean!

  """Indicator as to whether the request can be revoked"""
  canRevoke: Boolean!

  """
  Indicator as to whether the request is active from the employee's perspective
  """
  isActive: Boolean!

  """Indicator as to whether the request is completed"""
  isClosed: Boolean!

  """Indicator as to whether the request has been archived"""
  isArchived: Boolean!

  """
  Indicator as to whether the request is active from the data subjects perception
  """
  isActiveDataSubject: Boolean!

  """The email to communicate with"""
  email: String

  """
  The core identifier is the global user identifier specific to the organization
  """
  coreIdentifier: String!

  """Is the Encrypted CEK context for a request expired"""
  isContextExpired: Boolean!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The consent purpose that triggered this DSR and its boolean value"""
  purpose: DsrPurposeChange

  """
  The partition key that this DSR is kicked off for (often the data controller that the request is scoped to)
  """
  partition: ConsentPartition

  """The data subject class information"""
  subject: DataSubject!

  """The action config"""
  action: Action!

  """
  The name of the zip file to be downloaded to, this is constructed on the browser
  """
  zipFileName: String!
}

"""
Filters for the request history. These are requests viewed on the privacy center.
"""
input RequestHistoryFiltersInput {
  """Filter only certain request statuses"""
  status: [RequestStatus!]

  """Filter only certain request types"""
  type: [RequestAction!]

  """
  Filter to only show requests that are active from the perspective of the data subject
  """
  isActive: Boolean

  """
  The partition keys that this DSR is kicked off for (often the data controller in context)
  """
  partitionKeys: [String!]

  """
  The partition key UUIDs that this DSR is kicked off for (often the data controller in context)
  """
  partitionIds: [ID!]

  """Filter on requests triggered by a certain purpose change"""
  purposeNames: [String!]

  """Filter on requests triggered by a certain purpose change"""
  purposeIds: [ID!]
}

"""The order for a RequestHistory query"""
input RequestHistoryOrder {
  """The field that the RequestHistory nodes should be ordered by"""
  field: RequestHistoryOrderField!

  """
  The direction in which to order the RequestHistory nodes by the specified field
  """
  direction: OrderDirection!
}

"""The value of an identifier in the context of a request"""
type RequestIdentifier {
  """The unique ID of the RequestIdentifier"""
  id: ID!

  """The ID of the request"""
  requestId: ID!

  """The ID of the identifier"""
  identifierId: ID!

  """The error message if something went wrong"""
  error: String

  """The type of identifier"""
  identifier: WiredIdentifier!

  """The identifier converted to string"""
  value: String!

  """The name of the custom identifier"""
  name: String

  """
  Indicator as to whether the request identifier has been verified by at least one RequestEnricher.Only provided when input.requestEnricherId provided.
  """
  isVerifiedAtLeastOnce: Boolean!

  """
  Indicator as to whether the request identifier has been verified by a specific request enricher. Only provided when input.requestEnricherId provided.
  """
  isVerified: Boolean

  """
    When sombra signs an identifier, there is an underlying authentication method that did the verification
  (Usually one of "SombraDataSubjectAuthMethod"). Only provided when input.requestEnricherId provided.
  """
  initialAuthMethod: String

  """The source of the RequestIdentifier"""
  source: RequestIdentifierSource!

  """Whether or not this identifier is encrypted"""
  isEncrypted: Boolean!

  """
  The data silo that is the source of the RequestIdentifier if the request identifier source is from a data silo
  """
  sourceDataSilos: [DataSiloPreview!]

  """
  The enricher that is the source of the RequestIdentifier if the request identifier source is from an enricher
  """
  sourceEnrichers: [EnricherPreview!]
}

type RequestIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestIdentifier"""
  nodes: [RequestIdentifier!]!

  """int"""
  totalCount: Int!
}

"""Input for searching for RequestIdentifiers"""
input RequestIdentifiersFiltersInput {
  """Filter for a specific identifier"""
  identifierName: String

  """Filter by arbitrary text (search on: name, value, type)"""
  text: String

  """Filter by whether the identifier has been verified at least once"""
  isVerifiedAtLeastOnce: Boolean

  """Filter by source"""
  source: [RequestIdentifierSource!]
}

"""Input  for RequestIdentifiers"""
input RequestIdentifiersInput {
  """A list of unique IDs of data subject requests"""
  requestIds: [ID!]!

  """The unique ID of the RequestEnricher to filter RequestIdentifiers for"""
  requestEnricherId: ID
}

"""The order for a RequestIdentifier query"""
input RequestIdentifierOrder {
  """The field that the RequestIdentifier nodes should be ordered by"""
  field: RequestIdentifierOrderField!

  """
  The direction in which to order the RequestIdentifier nodes by the specified field
  """
  direction: OrderDirection!
}

"""Represents a request identity enrichment job"""
type RequestIdentityEnrichmentJob {
  """
  The unique ID of the request identity enrichment job (RequestEnricher.id or RequestDataSilo.id)
  """
  id: ID!

  """The status of the request identity enrichment job"""
  status: String!

  """The time the request identity enrichment job was scheduled"""
  scheduledAt: Date!

  """The error of the request identity enrichment job"""
  error: String

  """
  The ID of the underlying source model of the job (enricher.id or dataSilo.id)
  """
  sourceModelId: ID!

  """The type of the source model (enricher or dataSilo)"""
  sourceModelName: String!

  """The title of the source model"""
  sourceModelTitle: String!

  """The type of the source model (enricher.type or dataSilo.type)"""
  sourceModelType: String!

  """The identifiers for the source model"""
  sourceModelIdentifiers: [Identifier!]!

  """The logo for the source model"""
  sourceModelLogo: String

  """The input request identifier for the job"""
  inputRequestIdentifier: RequestIdentifier

  """The request identifiers that the job produced"""
  outputRequestIdentifiers: [RequestIdentifier!]!
}

"""Input for a request identity enrichment job"""
input RequestIdentityEnrichmentJobFiltersInput {
  """
  Find any request form inputs or request ids that are like a text string
  """
  text: String
}

"""Input for a request identity enrichment job"""
input RequestIdentityEnrichmentJobInput {
  """The unique ID of the data subject request"""
  requestId: ID!
}

type RequestIdentityEnrichmentJobsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestIdentityEnrichmentJob"""
  nodes: [RequestIdentityEnrichmentJob!]!

  """int"""
  totalCount: Int!
}

"""Input for creating a data subject request"""
input RequestInput {
  """The type of data subject request"""
  type: RequestAction!

  """The unique name of the organization's data subject class"""
  subjectType: String!

  """The identifiers to key the data subject by that need to be verified"""
  requestIdentifiers: DeprecatedRequestIdentifiersInput

  """The region that the request was submitted in"""
  region: RegionInput

  """The locale to translate the request it"""
  locale: String

  """Misc details from the data subject about their request"""
  details: String

  """The google recaptcha result"""
  captcha: String

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The data silos to process for this request"""
  dataSiloIds: [ID!]

  """
  The set of data silo IDs that should NOT be processed. When specified, the default set of data silos will be calculated and then these IDs will be subtracted from that list.
  """
  ignoreDataSiloIds: [ID!]

  """The id of the parent request"""
  parentId: ID

  """
  The partition key that this DSR is kicked off for (often the data controller in context)
  """
  partitionKey: String

  """The workflow config to use for this request"""
  workflowConfigId: ID
}

"""The interface for a data subject request"""
interface RequestInterface {
  """The unique ID of the data subject request"""
  id: ID!

  """The time the request was made"""
  createdAt: Date!

  """The time the request was last updated"""
  updatedAt: Date!

  """The time the request was last transitioned"""
  lastTransitionTime: Date

  """The time at which the secondary action will begin"""
  secondaryStartTime: Date

  """The current status of the request"""
  status: RequestStatus!

  """The type of request being made"""
  type: RequestAction!

  """The active type of the request being made"""
  activeType: RequestAction!

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The type of data subject, unique to the organization"""
  subjectType: String!

  """The locale the request should be translated to"""
  locale: String!

  """Additional details submit with the request"""
  details: String

  """The DSR report template to send"""
  report: LocalizedTemplate

  """The DSR secondary report template to send after deletion is completed"""
  secondaryReport: LocalizedTemplate

  """The time the compiling phase was completed"""
  reportSendTime: Date

  """The time the ERASURE report was sent"""
  secondaryReportSendTime: Date

  """The time the report was opened if a download link was included"""
  reportOpenedTime: Date

  """
  Indicates if report has been opened, else undefined if not relevant in the context
  """
  isOpened: Boolean

  """Indicator as to whether the request can be downloaded"""
  canDownload: Boolean!

  """
  Indicator as to whether the request can be viewable by data subject on Privacy Center
  """
  canViewByDataSubject: Boolean!

  """Indicator as to whether the request can be revoked"""
  canRevoke: Boolean!

  """
  Indicator as to whether the request is active from the employee's perspective
  """
  isActive: Boolean!

  """Indicator as to whether the request is completed"""
  isClosed: Boolean!

  """Indicator as to whether the request has been archived"""
  isArchived: Boolean!

  """
  Indicator as to whether the request is active from the data subjects perception
  """
  isActiveDataSubject: Boolean!

  """The email to communicate with"""
  email: String

  """
  The core identifier is the global user identifier specific to the organization
  """
  coreIdentifier: String!

  """Is the Encrypted CEK context for a request expired"""
  isContextExpired: Boolean!

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """The consent purpose that triggered this DSR and its boolean value"""
  purpose: DsrPurposeChange

  """
  The partition key that this DSR is kicked off for (often the data controller that the request is scoped to)
  """
  partition: ConsentPartition
}

type RequestNewDataSiloTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for requesting a new data silo token"""
input RequestNewDataSiloTokenInput {
  """the raw secret to use to find the token"""
  token: String!
}

"""The order for a Request query"""
input RequestOrder {
  """The field that the Request nodes should be ordered by"""
  field: RequestOrderField!

  """
  The direction in which to order the Request nodes by the specified field
  """
  direction: OrderDirection!
}

type RequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Request"""
  nodes: [Request!]!

  """int"""
  totalCount: Int!
}

"""The input for fetching additional context for each request"""
input RequestsContextInput {
  """
  The id of the data silo to determine if each request has processed or not
  """
  dataSiloId: ID
}

type RequestsForDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RequestForDataSilo"""
  nodes: [RequestForDataSilo!]!

  """int"""
  totalCount: Int!
}

"""A single row of requests processd stats"""
type RequestsProcessedDisclosureStat {
  """The type of the request"""
  type: RequestAction!

  """The total number of requests received"""
  received: Int!

  """The total number of requests processed"""
  processed: Int!

  """The total number of requests denied"""
  denied: Int!

  """The median number of days taken for request resolution"""
  medianNumberOfDays: Int!
}

"""An individual override for a requests processed stat value"""
type RequestsProcessedDisclosureStatOverride {
  """The calendar year this stat is for"""
  year: Int!

  """The action type of the request"""
  actionType: RequestAction!

  """The stat type to override"""
  statType: RequestsProcessedDisclosureStatsTableHeaders!

  """The value to override with"""
  statValue: Int!
}

"""An individual override for a requests processed stat value"""
input RequestsProcessedDisclosureStatOverrideInput {
  """The calendar year this stat is for"""
  year: Int!

  """The action type of the request"""
  actionType: RequestAction!

  """The stat type to override"""
  statType: RequestsProcessedDisclosureStatsTableHeaders!

  """The value to override with"""
  statValue: Int!
}

"""Stats on requests processed by year, for CCPA disclosure"""
type RequestsProcessedDisclosureStatsByYear {
  """The calendar year these stats are for"""
  year: Int!

  """Disclosure stats by request type"""
  stats: [RequestsProcessedDisclosureStat!]!
}

"""Input for getting stats for CCPA requests processed disclosure"""
input RequestsProcessedDisclosureStatsInput {
  """The calendar years to get metrics for"""
  years: [Int!]

  """
  Should the raw results be returned, without overrides or other settings applied
  """
  showRawValues: Boolean
}

"""Settings for Requests Processed Disclosure Stats"""
type RequestsProcessedDisclosureStatsSettings {
  """The ID of the privacy center"""
  privacyCenterId: ID!

  """A list of action types to hide from the result and table"""
  disabledActions: [RequestAction!]!

  """
  Is the table enabled at all? If disabled, results will not be calculated
  """
  tableEnabled: Boolean!

  """Individual overrides, by year"""
  valueOverrides: [RequestsProcessedDisclosureStatOverride!]!
}

"""Input to change settings for Requests Processed Disclosure Stats"""
input RequestsProcessedDisclosureStatsSettingsInput {
  """The ID of the Privacy Center to update"""
  privacyCenterId: ID!

  """A list of action types to hide from the result and table"""
  disabledActions: [RequestAction!]

  """
  Is the table enabled at all? If disabled, results will not be calculated
  """
  tableEnabled: Boolean

  """Individual overrides, by year"""
  valueOverrides: [RequestsProcessedDisclosureStatOverrideInput!]
}

"""
Configuration to display the steps/workflow of a request (https://ant.design/components/steps/)
"""
type RequestSteps {
  """The state of the current step"""
  status: StepStatus!

  """The index of the step currently being run"""
  current: Int!

  """The steps in the lifecycle of the DSR"""
  steps: [Step!]!
}

type ReScanPluginPermissionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A plugin belonging to a data silo"""
  plugin: Plugin!
}

type ResetDataSiloRateLimitsToDefaultPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for resetting a password"""
input ResetPasswordInput {
  """The email to reset"""
  email: String!

  """The captcha value to verify that a user is making the request"""
  captcha: String!
}

"""Input for resetting the SSO provider for an organization"""
input ResetSsoProviderInput {
  """The ID of the Organization to reset the SSO provider for"""
  organizationId: ID!
}

type ResetUserPasswordPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  sent: Boolean!
}

"""Input to re-sign multiple Encrypted CEK contexts"""
input ReSignEncryptedCEKContextsInput {
  """List of request Ids"""
  requestIds: [ID!]!
}

type ReSignSaaSContextsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  done: Boolean!
}

"""Input to re-sign multiple SaaS contexts"""
input ReSignSaaSContextsInput {
  """List of data silo Ids"""
  dataSiloIds: [ID!]!
}

"""Grant access to a particular resource, i.e. a data silo"""
type Resource {
  """The unique ID of the resource"""
  id: ID!

  """The type of resource"""
  type: ResourceType!

  """The display title of the resource"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """The avatar image URL"""
  logo: String!
}

type RestartSiloClassificationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A plugin belonging to a data silo"""
  plugin: Plugin!
}

"""Input for restarting the classification of the contents of a data silo"""
input RestartSiloClassificationInput {
  """The id of the data silo"""
  dataSiloId: ID!

  """
  Whether to remove unconfirmed guesses in addition to triggering a rescan. Defaults to true.
  """
  clearPendingGuesses: Boolean
}

type RestartSiloObjectClassificationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A plugin belonging to a data silo"""
  plugin: Plugin!
}

"""
Input for restarting the classification of the scanned objects of a data silo
"""
input RestartSiloObjectClassificationsInput {
  """The id of the data silo"""
  dataSiloId: ID!

  """Whether to remove all existing classifications for scanned objects."""
  clearExistingClassifications: Boolean
}

type ResumeRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

"""Configurable retention policy to manage an organizations data"""
type RetentionSchedule {
  """The unique ID of the RetentionSchedule"""
  id: ID!

  """The ID of the organization that the retention schedule belongs to"""
  organizationId: ID!

  """The type of the retention schedule"""
  type: RetentionScheduleType!

  """The duration of the retention schedule in days"""
  durationDays: Int!

  """The operation to perform on the retention schedule"""
  operation: RetentionScheduleOperation!

  """The time the retention schedule was created"""
  createdAt: Date!

  """The time the retention schedule was last updated"""
  updatedAt: Date!
}

"""Filters for querying retention schedules"""
input RetentionScheduleFiltersInput {
  """Filter by the ids of the retention schedules"""
  ids: [ID!]

  """Filter by the operation types of the retention schedule"""
  operations: [RetentionScheduleOperation!]

  """Filter by the types of the retention schedules"""
  types: [RetentionScheduleType!]
}

type RetentionSchedulesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RetentionSchedule"""
  nodes: [RetentionSchedule!]!

  """int"""
  totalCount: Int!
}

"""Input for updating an organization's feature sets"""
input RetryDaemonQueueErrorsInput {
  """The queue type to restart"""
  queueType: IntegrationQueueType!
}

type RetryDataSiloErrorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A place in the organization where data sits. This could be a database, SaaS tool, filing cabinet, etc.
  """
  dataSilo: DataSilo!
}

type RetryEnricherErrorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An enricher is takes in an identifier, and resolves additional identifiers keyed to the input identifier.
  """
  enricher: Enricher!
}

type RetryProfileDataPointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An edge between a datapoint and profile, indicating child profile"""
  profileDataPoint: ProfileDataPoint!
}

"""Input for retrying a profile datapoint"""
input RetryProfileDataPointInput {
  """When true, preserve the pollId instead of resetting it"""
  preservePollId: Boolean
}

type RetryProfileDataPointSecondaryPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An edge between a datapoint and profile, indicating child profile"""
  profileDataPoint: ProfileDataPoint!
}

type RetryRequestDataSiloPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The status of looking up a DSR in a data silo"""
  requestDataSilo: RequestDataSilo!
}

type RetryRequestEnricherPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A request enrichment that needs to be responded to"""
  requestEnricher: RequestEnricher!
}

type RevealConsentIdentifierEncryptionKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type RevealRootSombraSecretPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type RevokeRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A preview of a data subject request"""
  request: RequestHistory!
}

"""
Input for the risk to assign to an assessment question if it matches the risk logic rule
"""
input RiskAssignmentInput {
  """The ID risk level to assign to a question."""
  riskLevelId: ID

  """The ID risk matrix column to assign to a question."""
  riskMatrixColumnId: ID

  """The ID risk matrix row to assign to a question."""
  riskMatrixRowId: ID
}

type RiskCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskCategory"""
  nodes: [RiskCategory!]!

  """int"""
  totalCount: Int!
}

"""Inputs for filtering a list of risk categories"""
input RiskCategoriesFiltersInput {
  """The ids of risk categories"""
  ids: [ID!]

  """The titles or descriptions of risk categories"""
  text: String

  """The id of the risk framework this risk category belongs to"""
  riskFrameworkId: ID
}

"""A type of risk within a risk framework"""
type RiskCategory {
  """The id of the risk category"""
  id: ID!

  """The display name of the risk category"""
  title: String!

  """A description of what kinds of risk this risk category represents"""
  description: String!

  """
  The list of individual users who are responsible for managing this risk category
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this risk category"""
  teams: [TeamPreview!]!
}

"""The risk methodology used to evaluate systems"""
type RiskFramework {
  """The id of the risk framework"""
  id: ID!

  """The display name of the risk framework"""
  title: String!

  """A description of what this risk framework represents"""
  description: String!

  """
  The risk levels associated with this risk framework, sorted lowest to highest risk
  """
  riskLevels: [RiskLevel!]!

  """The risk categories associated with this risk framework"""
  riskCategories: [RiskCategory!]!

  """
  The risk matrix columns associated with this risk framework, sorted lowest to highest
  """
  riskMatrixColumns: [RiskMatrixColumn!]!

  """
  The risk matrix rows associated with this risk framework, sorted lowest to highest
  """
  riskMatrixRows: [RiskMatrixRow!]!

  """
  The risk levels that correspond to a particular risk matrix column and row combination. The first index is the risk matrix row index, and the second index is the risk matrix column index.
  """
  riskMatrix: [[RiskLevel!]!]

  """The user who created this risk framework"""
  creator: UserPreview

  """The title of the risk matrix columns in this framework"""
  riskMatrixRowTitle: String!

  """The title of the risk matrix columns in this framework"""
  riskMatrixColumnTitle: String!
}

type RiskFrameworksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskFramework"""
  nodes: [RiskFramework!]!

  """int"""
  totalCount: Int!
}

"""Inputs for filtering a list of risk frameworks"""
input RiskFrameworksFiltersInput {
  """The ids of risk frameworks"""
  ids: [ID!]

  """The titles or descriptions of risk frameworks"""
  text: String
}

"""A representation of overall risk incurred"""
type RiskLevel {
  """The id of the risk level"""
  id: ID!

  """The display name of the risk level"""
  title: String!

  """The color associated with risk level"""
  color: String!
}

type RiskLevelsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskLevel"""
  nodes: [RiskLevel!]!

  """int"""
  totalCount: Int!
}

"""Inputs for filtering a list of risk levels"""
input RiskLevelsFiltersInput {
  """The ids of risk levels"""
  ids: [ID!]

  """The titles or descriptions of risk levels"""
  text: String

  """The id of the risk framework this risk level belongs to"""
  riskFrameworkId: ID
}

"""Input for the risk logic of an assessment question"""
input RiskLogicInput {
  """
  The risk to assign to this question if the response matches the provided logic
  """
  riskAssignment: RiskAssignmentInput!

  """The operator to use when comparing the response to the operands"""
  comparisonOperator: ComparisonOperator!

  """The values to compare the response to"""
  comparisonOperands: [String!]!
}

"""A representation of how likely a risk is to occur"""
type RiskMatrixColumn {
  """The id of the risk matrix column"""
  id: ID!

  """The display name of the risk matrix column"""
  title: String!
}

"""A representation of how severe a risk would be if it were to occur"""
type RiskMatrixRow {
  """The id of the risk matrix row"""
  id: ID!

  """The display name of the risk matrix row"""
  title: String!
}

"""A role that a user can take on in another organization"""
type Role {
  """The id of the user role in the other organization"""
  id: ID!

  """The organization that the role can assume into"""
  organization: OrganizationPreview!
}

type RollbackAirgapBundlePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for rolling back to a previous airgap bundle version"""
input RollbackAirgapBundleInput {
  """Rollback modules hosted on this specific CDN"""
  cdn: AirgapCdn!

  """The version ID for the airgap core module"""
  core: String!

  """The version ID for the airgap xdi module"""
  xdi: String

  """The version ID for the airgap userscript module"""
  userscript: String

  """The version ID for the airgap explorer module"""
  explorer: String

  """The version ID for the airgap metadata module"""
  metadata: String

  """The version ID for the airgap ui module"""
  ui: String

  """The version ID for the airgap stylesheet module"""
  stylesheet: String

  """The version ID for the airgap En module"""
  En: String

  """The version ID for the airgap FrFr module"""
  FrFr: String

  """The version ID for the airgap DeDe module"""
  DeDe: String

  """The version ID for the airgap ItIt module"""
  ItIt: String

  """The version ID for the airgap PtBr module"""
  PtBr: String

  """The version ID for the airgap Es419 module"""
  Es419: String

  """The version ID for the airgap EsEs module"""
  EsEs: String

  """The version ID for the airgap CsCz module"""
  CsCz: String

  """The version ID for the airgap DaDk module"""
  DaDk: String

  """The version ID for the airgap FiFi module"""
  FiFi: String

  """The version ID for the airgap ElGr module"""
  ElGr: String

  """The version ID for the airgap LtLt module"""
  LtLt: String

  """The version ID for the airgap NbNi module"""
  NbNi: String

  """The version ID for the airgap PlPl module"""
  PlPl: String

  """The version ID for the airgap RoRo module"""
  RoRo: String

  """The version ID for the airgap RuRu module"""
  RuRu: String

  """The version ID for the airgap SrLatnRs module"""
  SrLatnRs: String

  """The version ID for the airgap SvSe module"""
  SvSe: String

  """The version ID for the airgap ArAe module"""
  ArAe: String

  """The version ID for the airgap JaJp module"""
  JaJp: String

  """The version ID for the airgap KoKr module"""
  KoKr: String

  """The version ID for the airgap ZhCn module"""
  ZhCn: String

  """The version ID for the airgap ZhHk module"""
  ZhHk: String

  """The version ID for the airgap AfZz module"""
  AfZz: String

  """The version ID for the airgap BgBg module"""
  BgBg: String

  """The version ID for the airgap HrHr module"""
  HrHr: String

  """The version ID for the airgap HuHu module"""
  HuHu: String

  """The version ID for the airgap IdId module"""
  IdId: String

  """The version ID for the airgap MsMy module"""
  MsMy: String

  """The version ID for the airgap HiIn module"""
  HiIn: String

  """The version ID for the airgap MrIn module"""
  MrIn: String

  """The version ID for the airgap TaIn module"""
  TaIn: String

  """The version ID for the airgap ThTh module"""
  ThTh: String

  """The version ID for the airgap TrTr module"""
  TrTr: String

  """The version ID for the airgap UkUa module"""
  UkUa: String

  """The version ID for the airgap ViVn module"""
  ViVn: String

  """The version ID for the airgap NlNl module"""
  NlNl: String

  """The version ID for the airgap HeIl module"""
  HeIl: String

  """The version ID for the airgap tcfUi module"""
  tcfUi: String

  """The version ID for the airgap gpp module"""
  gpp: String

  """The version ID for the airgap tcfStylesheet module"""
  tcfStylesheet: String

  """The version ID for the airgap tcfVendorsList module"""
  tcfVendorsList: String

  """The version ID for the airgap tcfEn module"""
  tcfEn: String

  """The version ID for the airgap tcfFrFr module"""
  tcfFrFr: String

  """The version ID for the airgap tcfDeDe module"""
  tcfDeDe: String

  """The version ID for the airgap tcfItIt module"""
  tcfItIt: String

  """The version ID for the airgap tcfPtBr module"""
  tcfPtBr: String

  """The version ID for the airgap tcfEs419 module"""
  tcfEs419: String

  """The version ID for the airgap tcfEsEs module"""
  tcfEsEs: String

  """The version ID for the airgap tcfCsCz module"""
  tcfCsCz: String

  """The version ID for the airgap tcfDaDk module"""
  tcfDaDk: String

  """The version ID for the airgap tcfFiFi module"""
  tcfFiFi: String

  """The version ID for the airgap tcfElGr module"""
  tcfElGr: String

  """The version ID for the airgap tcfLtLt module"""
  tcfLtLt: String

  """The version ID for the airgap tcfNbNi module"""
  tcfNbNi: String

  """The version ID for the airgap tcfPlPl module"""
  tcfPlPl: String

  """The version ID for the airgap tcfRoRo module"""
  tcfRoRo: String

  """The version ID for the airgap tcfRuRu module"""
  tcfRuRu: String

  """The version ID for the airgap tcfSrLatnRs module"""
  tcfSrLatnRs: String

  """The version ID for the airgap tcfSvSe module"""
  tcfSvSe: String

  """The version ID for the airgap tcfArAe module"""
  tcfArAe: String

  """The version ID for the airgap tcfJaJp module"""
  tcfJaJp: String

  """The version ID for the airgap tcfKoKr module"""
  tcfKoKr: String

  """The version ID for the airgap tcfZhCn module"""
  tcfZhCn: String

  """The version ID for the airgap tcfZhHk module"""
  tcfZhHk: String

  """The version ID for the airgap tcfAfZz module"""
  tcfAfZz: String

  """The version ID for the airgap tcfBgBg module"""
  tcfBgBg: String

  """The version ID for the airgap tcfHrHr module"""
  tcfHrHr: String

  """The version ID for the airgap tcfHuHu module"""
  tcfHuHu: String

  """The version ID for the airgap tcfIdId module"""
  tcfIdId: String

  """The version ID for the airgap tcfMsMy module"""
  tcfMsMy: String

  """The version ID for the airgap tcfHiIn module"""
  tcfHiIn: String

  """The version ID for the airgap tcfMrIn module"""
  tcfMrIn: String

  """The version ID for the airgap tcfTaIn module"""
  tcfTaIn: String

  """The version ID for the airgap tcfThTh module"""
  tcfThTh: String

  """The version ID for the airgap tcfTrTr module"""
  tcfTrTr: String

  """The version ID for the airgap tcfUkUa module"""
  tcfUkUa: String

  """The version ID for the airgap tcfViVn module"""
  tcfViVn: String

  """The version ID for the airgap tcfNlNl module"""
  tcfNlNl: String

  """The version ID for the airgap tcfHeIl module"""
  tcfHeIl: String

  """The version ID for the airgap nativeAppConfig module"""
  nativeAppConfig: String

  """The version ID for the airgap bridgeJs module"""
  bridgeJs: String

  """The version ID for the airgap bridgeHtml module"""
  bridgeHtml: String

  """The version ID for the sync endpoint script"""
  sync: String

  """
  Whether to rollback the "TEST" or "PRODUCTION" bundle, defaults to "PRODUCTION"
  """
  isTest: Boolean!
}

type RotateSombraRootKeysPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""The rule to evaluate in the display logic of an assessment question"""
input RuleInput {
  """The reference id of the question whose answer is compared by this rule"""
  dependsOnQuestionReferenceId: String!

  """The operator to use when comparing the question answer to the operands"""
  comparisonOperator: ComparisonOperator!

  """The values to compare the question answer to"""
  comparisonOperands: [String!]
}

type RunAuditorPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Output from running a single auditor run"""
  results: AuditorRunResponse!
}

type RunCustomFunctionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Custom function execution result"""
  result: CustomFunctionExecutionResult!
}

"""
Run a custom function with a payload. This endpoint is primarily for testing purposes when firstbuilding out and testing a Custom Function integration
"""
input RunCustomFunctionInput {
  """Custom Function ID"""
  id: ID!

  """
  Base64 stringified JSON payload with underlying type `TranscendWebhookIntegrationBasePayload`
  """
  payload: String!

  """
  If this is a testing run, and not meant to actually have legitimate informationlike CEK contexts and request Ids.
  """
  isCustomFunctionTestRun: Boolean
}

type SaaSCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SaaSCategory"""
  nodes: [SaaSCategory!]!

  """int"""
  totalCatalogs: Int!

  """int"""
  totalCount: Int!
}

"""
A classification of integration. All integrations of this class are shown together
"""
type SaaSCategory {
  """The SaaSCategory id, from the database (not contentfulId)"""
  id: ID!

  """The integration category title"""
  title: String!

  """The Catalogs that fall into the SaaSCategory"""
  catalogs: [Catalog!]!
}

"""
A classification of integration. All integrations of this class are shown together
"""
type SaaSCategoryBase {
  """The SaaSCategory id, from the database (not contentfulId)"""
  id: ID!

  """The integration category title"""
  title: String!
}

"""Inputs for determining what saaSCategories to filter"""
input SaaSCategoryFiltersInput {
  """Filter by text (title of integration)"""
  text: String

  """Filter by text at the category level (title of saas category)"""
  categoryText: String

  """Filter by category"""
  saaSCategoryIds: [ID!]

  """Filter by plugin type"""
  plugins: [PluginType!]

  """Filter by connector type"""
  connectorType: ConnectorType

  """
  Filter by whether the integration is recommended for consent manager purposes
  """
  recommendedForConsent: ConsentManagerConnectionStatus

  """
  Filter by whether the integration is recommended for privacy request purposes
  """
  recommendedForPrivacy: PrivacyRequestConnectionStatus

  """Filter by whether the integration has personal data in it"""
  hasPersonalData: HasPersonalDataStatus

  """Filter by the request action type supported"""
  requestActions: [RequestAction!]
}

type SaaSCategoryNamesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SaaSCategoryBase"""
  nodes: [SaaSCategoryBase!]!
}

"""Inputs for determining what saaSCategories to filter"""
input SaaSCategoryNamesFiltersInput {
  """Filter by text (title of integration)"""
  text: String

  """Filter by plugin type"""
  plugins: [PluginType!]

  """Filter by connector type"""
  connectorType: ConnectorType

  """
  Filter by whether the integration is recommended for consent manager purposes
  """
  recommendedForConsent: ConsentManagerConnectionStatus

  """
  Filter by whether the integration is recommended for privacy request purposes
  """
  recommendedForPrivacy: PrivacyRequestConnectionStatus

  """Filter by whether the integration has personal data in it"""
  hasPersonalData: HasPersonalDataStatus

  """Filter by the request action type supported"""
  requestActions: [RequestAction!]
}

"""The order for a SaaSCategory query"""
input SaaSCategoryOrder {
  """The field that the SaaSCategory nodes should be ordered by"""
  field: SaaSCategoryOrderField!

  """
  The direction in which to order the SaaSCategory nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of the static SaaS vendor that a vendor is tied to"""
type SaaSVendorPreview {
  """The SaaSVendor id, from the database (not contentfulId)"""
  id: ID!

  """The url for the full logo image"""
  logo: String

  """The url for the square logo image"""
  logoSquare: String!
}

"""SAML Configuration, for the employees"""
type SAMLSchema {
  """
  Identity provider entrypoint (is required to be spec-compliant when the request is signed)
  """
  entryPoint: String!

  """
  The IDP's public signing certificate used to validate the signatures of the incoming SAML Responses
  """
  cert: String!

  """Issuer string to supply to identity provider"""
  issuer: String

  """
  Expected saml response Audience (if not provided, Audience won't be verified)
  """
  audience: String

  """Allow some variability when verifying the claim expiration"""
  acceptedClockSkewMs: Int
}

"""Input for defining SAML configuration"""
input SAMLSchemaInput {
  """
  Identity provider entrypoint (is required to be spec-compliant when the request is signed)
  """
  entryPoint: String

  """
  The IDP's public signing certificate used to validate the signatures of the incoming SAML Responses
  """
  cert: String

  """Issuer string to supply to identity provider"""
  issuer: String

  """
  Expected saml response Audience (if not provided, Audience won't be verified)
  """
  audience: String

  """Allow some variability when verifying the claim expiration"""
  acceptedClockSkewMs: Int
}

type SavePaVCompletionStatusPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""The savings configuration for the org"""
type SavingsConfigurationPreview {
  """Number of external systems where staff manually action data from"""
  numManualSystems: Float!

  """
  Number of extra external systems where staff email the vendor requesting action on a subject's data not yet connected in transcend
  """
  numEmailSystems: Float!

  """Salary of Legal/Operations Manager"""
  legalSalary: Float!

  """Salary of Sales/Marketing/HR Manager"""
  salesSalary: Float!

  """Salary of Software Engineer"""
  engineerSalary: Float!
}

"""Scan metadata"""
type Scan {
  """ID of scan"""
  id: String!

  """Unix epoch representing when this scan began"""
  startEpoch: String!

  """Status of this scan."""
  status: ScanLambdaStatus!

  """Scan type"""
  type: ScanType!

  """Unix epoch in SECONDS to allow for automatic DynamoDB cleanup"""
  expiresAt: Int!

  """The ID of the plugin that contains this scan"""
  pluginId: ID!

  """Error / warning message"""
  stack: String

  """The Scan Run ID that's running at the moment"""
  currentScanRunId: String

  """The most recently successful Scan Run's ID"""
  lastSuccessfulScanRunId: String

  """The most recent Scan Run's ID"""
  lastScanRunId: String

  """Unix epoch representing when this scan run ended"""
  endEpoch: String

  """A Plugin Scan Result"""
  scanResult: ScanResult
}

"""Color results found by the sitescanner"""
type ScanColor {
  """The unique UUID of the scanned colors"""
  id: ID!

  """The unique UUID of the organization that ran the color scan"""
  organizationId: ID!

  """The colors"""
  colors: [String!]!
}

"""A result from a sitescan"""
type ScanCookiePurpose {
  """The id of the sitescan result"""
  id: ID!

  """The cookie of the SaaS tool found by the sitescan"""
  cookie: String!

  """The guess for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]!

  """The corresponding integration in our catalog"""
  catalog: Catalog
}

"""Filters that can be applied when looking up sitescan results"""
input ScanCookiePurposeFiltersInput {
  """Find any sitescan results whose name is iLike a text string"""
  text: String

  """Filter sitescan results for certain purposes"""
  purposes: [Purpose!]
}

"""The order for a ScanCookiePurpose query"""
input ScanCookiePurposeOrder {
  """The field that the ScanCookiePurpose nodes should be ordered by"""
  field: ScanCookiePurposeOrderField!

  """
  The direction in which to order the ScanCookiePurpose nodes by the specified field
  """
  direction: OrderDirection!
}

type ScanCookiePurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScanCookiePurpose"""
  nodes: [ScanCookiePurpose!]!

  """int"""
  totalCount: Int!
}

"""A result from a sitescan"""
type ScanDomainPurpose {
  """The id of the sitescan result"""
  id: ID!

  """The domain of the SaaS tool found by the sitescan"""
  domain: String!

  """The guess for the purpose of the SaaS tool"""
  purposeGuess: Purpose!

  """The corresponding integration in our catalog"""
  catalog: Catalog
}

"""Filters that can be applied when looking up sitescan results"""
input ScanDomainPurposeFiltersInput {
  """Find any sitescan results whose name is iLike a text string"""
  text: String

  """Filter sitescan results for certain purposes"""
  purpose: [Purpose!]
}

"""The order for a ScanDomainPurpose query"""
input ScanDomainPurposeOrder {
  """The field that the ScanDomainPurpose nodes should be ordered by"""
  field: ScanDomainPurposeOrderField!

  """
  The direction in which to order the ScanDomainPurpose nodes by the specified field
  """
  direction: OrderDirection!
}

type ScanDomainPurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScanDomainPurpose"""
  nodes: [ScanDomainPurpose!]!

  """int"""
  totalCount: Int!
}

"""Key used for paginating scans"""
type ScanKey {
  """ID of scan"""
  id: String!

  """Unix epoch representing when this scan began"""
  startEpoch: String!
}

"""Input for paginating scans"""
input ScanKeyInput {
  """ID of scan"""
  id: String!

  """Unix epoch representing when this scan began"""
  startEpoch: String!
}

type ScannedCatalogsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Catalog"""
  nodes: [Catalog!]!

  """int"""
  totalCount: Int!
}

type ScannedObjectFileTypesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Output for getting scanned object file types"""
  response: ScannedObjectFileTypesOutput!
}

"""Input for filtering scanned object file types"""
input ScannedObjectFileTypesFiltersInput {
  """The ID of the data silo"""
  dataSiloId: ID!
}

"""Output for getting scanned object file types"""
type ScannedObjectFileTypesOutput {
  """The unique file types"""
  uniqueFileTypes: [String!]!
}

type ScannedObjectHierarchyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScannedObjectHierarchyItem"""
  nodes: [ScannedObjectHierarchyItem!]!

  """int"""
  totalCount: Int!
}

"""Input for filtering a hierarchy of scanned objects"""
input ScannedObjectHierarchyFiltersInput {
  """The text to filter the scanned objects by"""
  text: String

  """Filter by scanned object path IDs"""
  scannedObjectPathIds: [ID!]

  """Filter by data silos the scanned objects belong to"""
  dataSiloId: ID!

  """Filter by parent scanned object path ID"""
  parentId: ID

  """Filter by the assigned owner IDs"""
  ownerIds: [ID!]

  """Filter by the assigned team IDs"""
  teamIds: [ID!]

  """
  Filter by the attribute values used to label the scanned object or scanned object path
  """
  attributeValueIds: [ID!]

  """Filter by the file types of the scanned objects"""
  fileTypes: [String!]
}

"""
A hierarchy item in the scanned object hierarchy, which can be a scanned object or a scanned object path
"""
type ScannedObjectHierarchyItem {
  """The unique ID of the scanned object or the scanned object path"""
  id: String!

  """The identifying name/key of the scanned object"""
  name: String!

  """The metadata for the object"""
  metadata: ScannedObjectHierarchyItemMetadata

  """The path to this hierarchy item"""
  path: [String!]

  """
  This hierarchy item is a scanned object, rather than a scanned object path
  """
  isScannedObject: Boolean!

  """The ID of the data silo that contains the item"""
  dataSiloId: ID

  """The description of the scanned object or the scanned object path"""
  description: String

  """The owners of the scanned object or the scanned object path"""
  owners: [ID!]

  """The teams of the scanned object or the scanned object path"""
  teams: [ID!]

  """
  The attribute values used to label this scanned object or the scanned object path
  """
  attributeValues: [AttributeValue!]!

  """The fileType for scannedObjects or null for scannedObjectPaths"""
  fileType: String

  """
  The size for a scannedObject or the scannedObjects within a scannedObjectPath
  """
  size: Float!

  """
  The guessed data subcategories for unstructured subdatapoint recommendations belonging to scannedObjects, or null for scannedObjectPaths
  """
  guessedDataSubCategories: [DataSubCategoryPreview!]!

  """
  The confirmed data subcategories for unstructured subdatapoint recommendations belonging to scannedObjects, or null for scannedObjectPaths
  """
  confirmedDataSubCategories: [DataSubCategoryPreview!]!
}

"""Metadata for a hierarchy item"""
type ScannedObjectHierarchyItemMetadata {
  """The number of rows in the object"""
  rowCount: Int!
}

type ScannedObjectHierarchyPathPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScannedObjectHierarchyItem"""
  pathSegments: [ScannedObjectHierarchyItem!]!
}

"""Input for filtering a hierarchy of scanned objects"""
input ScannedObjectHierarchyPathFiltersInput {
  """Filter by data silos the scanned objects belong to"""
  dataSiloId: ID!

  """Filter by parent scanned object level ID"""
  parentId: ID

  """Filter by the current scanned object"""
  scannedObjectId: ID
}

"""The configuration for a scan plugin"""
input ScanPluginConfigInput {
  """The type of the plugin"""
  type: PluginType!

  """Configuration for the plugin"""
  configuration: String
}

"""Result from a scan"""
type ScanResult {
  """A schema discovery plugin's scan result"""
  schemaDiscovery: SchemaDiscoveryScanResult
}

"""Scan Run Id"""
type ScanRunId {
  """Scan Id"""
  scanId: String!

  """Start epoch for the scan run"""
  startEpoch: String!
}

"""A schema discovery plugin's scan result for a datapoint"""
type SchemaDiscoveryCurrentScanProgressResult {
  """The mapped terminology for this type of datapoint"""
  displayName: DataPointTypeDisplayName!

  """The total expected progress for this scan"""
  totalExpectedProgress: Int

  """How much progress have we made so far"""
  currentProgress: Int
}

"""The configuration for schema discovery plugins"""
type SchemaDiscoveryPluginConfigurationSchema {
  """
  The scan objects (e.g., schema, database, etc) the integration supports filtering during Schema Discovery.
  """
  scanObjectsToFilter: [ScanObject!]
}

"""A schema discovery plugin's scan result"""
type SchemaDiscoveryScanResult {
  """Subdatapoints found and mapped to the appropriate terminology"""
  subDataPointResult: SchemaDiscoveryCurrentScanProgressResult!

  """Datapoints found and mapped to the appropriate terminology"""
  dataPointResult: SchemaDiscoveryCurrentScanProgressResult!

  """Datapoint levels found and mapped to the appropriate terminology"""
  dataPointLevelResults: [SchemaDiscoveryCurrentScanProgressResult!]!
}

"""A scope that exists within an organization"""
type Scope {
  """The unique id of the scope"""
  id: ID!

  """The color associated with the scope"""
  color: String!

  """The name of the scope"""
  name: ScopeName!

  """The general category the scope falls into"""
  type: ScopeType!

  """The display title of the scope"""
  title: String!

  """The description of the scope"""
  description: String!

  """The users that have been directly assigned to the scope"""
  users: [UserPreview!]!

  """All users that have the scope (direct or team)"""
  allUsers: [UserPreview!]!

  """The teams that have been assigned the scope"""
  teams: [TeamPreview!]!

  """All calculated teams that have the scope"""
  allTeams: [TeamPreview!]!

  """All api keys that have the scope (direct or team)"""
  apiKeys: [ApiKeyPreview!]!
}

"""Inputs for filtering the scopes"""
input ScopeFiltersInput {
  """Filter scopes that match a text string (name for now)"""
  text: String

  """The static type of scope"""
  types: [ScopeType!]

  """
  Filter for specific routes to see what scopes have access to that route
  """
  routeNames: [String!]

  """The product lines that the scope relates to"""
  productLines: [TranscendProduct!]

  """The IDs of the users that are directly assigned to this scope"""
  userIds: [ID!]

  """The IDs of the teams that are assigned to this scope"""
  teamIds: [ID!]

  """The IDs of the API keys that are assigned to this scope"""
  apiKeyIds: [ID!]
}

"""The order for a Scope query"""
input ScopeOrder {
  """The field that the Scope nodes should be ordered by"""
  field: ScopeOrderField!

  """The direction in which to order the Scope nodes by the specified field"""
  direction: OrderDirection!
}

"""Preview of a scope"""
type ScopePreview {
  """The unique id of the scope"""
  id: ID!

  """The color associated with the scope"""
  color: String!

  """The name of the scope"""
  name: ScopeName!

  """The general category the scope falls into"""
  type: ScopeType!

  """The display title of the scope"""
  title: String!

  """The description of the scope"""
  description: String!
}

type ScopesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Scope"""
  nodes: [Scope!]!

  """int"""
  totalCount: Int!
}

"""
A software development kit that is registered to a particular contentful catalog
"""
type Sdk {
  """The id of the SDK"""
  id: ID!

  """The catalog that the SDK is registered to"""
  catalog: SelectableCatalog!

  """The default name for the SDK"""
  name: String!

  """The default description for the SDK"""
  description: String

  """The id of the git repository for this SDK"""
  repositoryUrl: String

  """List of documentation links for the SDK"""
  documentationLinks: [String!]

  """The type of code package the SDK is for"""
  codePackageType: CodePackageType!
}

"""Input for filtering sdks"""
input SdkFiltersInput {
  """Filter sdks by their name, description"""
  text: String

  """Filter sdks by their exact name"""
  names: [String!]

  """Filter by the code package type"""
  codePackageTypes: [CodePackageType!]
}

"""The order for a Sdk query"""
input SdkOrder {
  """The field that the Sdk nodes should be ordered by"""
  field: SdkOrderField!

  """The direction in which to order the Sdk nodes by the specified field"""
  direction: OrderDirection!
}

type SdksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Sdk"""
  nodes: [Sdk!]!

  """int"""
  totalCount: Int!
}

type SearchCatalogsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Catalog"""
  catalogs: [Catalog!]!
}

"""A small set of fields required for consent catalog"""
type SelectableCatalog {
  """The Catalog id, from the database (not contentfulId)"""
  id: ID!

  """The url for the full logo image"""
  logo: String

  """The url for the square logo image"""
  logoSquare: String!

  """The identifying name of the integration"""
  integrationName: String!

  """The title of the integration"""
  title: String!

  """The description of the integration"""
  description: String!

  """
  If the integration belongs to a registered TCF Vendor, it will have a TCF Vendor ID
  """
  tcfVendorId: String
}

"""Input for selecting assessment answers within a question"""
input SelectAssessmentQuestionAnswerInput {
  """The id of the assessment question whose answers we want to select"""
  assessmentQuestionId: ID!

  """The id of the assessment answers to select"""
  assessmentAnswerIds: [ID!]

  """The values of the assessment answer to create and select"""
  assessmentAnswerValues: [AssessmentAnswerInput!]
}

type SelectAssessmentQuestionAnswersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentAnswer"""
  selectedAnswers: [AssessmentAnswer!]!
}

type SelectAssessmentQuestionAnswersTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentAnswer"""
  selectedAnswers: [AssessmentAnswer!]!
}

"""Input for selecting assessment answers within a question"""
input SelectAssessmentQuestionAnswersTokenInput {
  """The id of the assessment question whose answers we want to select"""
  assessmentQuestionId: ID!

  """The id of the assessment answers to select"""
  assessmentAnswerIds: [ID!]

  """The values of the assessment answer to create and select"""
  assessmentAnswerValues: [AssessmentAnswerInput!]

  """The token to validate"""
  token: String!
}

"""A selected answer to an assessment question."""
type SelectedAssessmentAnswerRaw implements AssessmentAnswerInterface {
  """The id of the assessment answer"""
  id: ID!

  """The index of the assessment answer"""
  index: Int!

  """The value to be displayed for this assessment answer"""
  value: String!

  """The presigned AWS url for where the document answer is stored"""
  presignedUrl: String

  """Whether the answer option was manually created by the user"""
  isUserCreated: Boolean!

  """
  Additional context necessary to display answers that were dynamically populated from the database
  """
  additionalContext: String
}

"""Input for a redaction selection"""
input SelectionInput {
  """Start of redaction (inclusive)"""
  start: Int!

  """End of redaction (exclusive)"""
  end: Int!
}

"""An option in a select form"""
type SelectOption {
  """The name of the form item value"""
  name: String!

  """The form label message"""
  label: DefinedMessage!
}

type SelfServeSignupPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The currently logged in user"""
  user: CurrentUser!
}

"""Input for onboarding user and organization via onboarding wizard"""
input SelfServeSignupInput {
  """The name of the user"""
  name: String!

  """The email of the user"""
  email: String!

  """The name of the organization"""
  organizationName: String!

  """The website of the organization"""
  companyWebsite: String!

  """The uri of the organization"""
  uri: String

  """The domain of the organization"""
  domain: String!

  """Signup code to prevent random signups"""
  code: String
}

type SendCommunicationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for sending a message to the data subject"""
input SendMessageInput {
  """The id of the request to send to"""
  requestId: ID!

  """The HTML email template to send"""
  template: String!

  """The subject of the email"""
  subject: String!

  """The id of the RequestDataSilo to send the email to"""
  requestDataSiloId: ID
}

type SendTestEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Response for sending a test email"""
  response: SendTestEmailResponse!
}

"""Send a test email through sombra"""
input SendTestEmailInput {
  """
  The unique ID for your self-hosted sombra instance (useful if there are multiple instances)
  """
  sombraId: ID

  """The email address to which to send the test email"""
  destinationAddress: String!

  """Whether or not to use a custom email domain"""
  useCustomDomain: Boolean
}

"""Response for sending a test email"""
type SendTestEmailResponse {
  """Was the email sent successfully"""
  success: Boolean!

  """The error message returned"""
  errorMessage: String

  """Where did the error occur"""
  failurePoint: TestEmailFailurePoint
}

type SendUserInviteEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for sending invitation email to a user for the organization"""
input SendUserInviteEmailInput {
  """The ID of the user to invite"""
  id: ID!
}

type SensitiveCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SensitiveCategory"""
  nodes: [SensitiveCategory!]!

  """int"""
  totalCount: Int!
}

"""Filters for sensitive categories"""
input SensitiveCategoriesFiltersInput {
  """Find sensitive categories by text"""
  text: String

  """Find sensitive categories by ids"""
  ids: [ID!]
}

"""A sensitive category of the organization"""
type SensitiveCategory {
  """The unique ID of the sensitive category"""
  id: ID!

  """The title of the sensitive category"""
  title: String!

  """The color of the sensitive category"""
  color: String!

  """The description of the sensitive category"""
  description: String!
}

type SetAirgapBundleTcfStacksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFStack"""
  nodes: [TCFStack!]!
}

"""Input for updating airgap version"""
input SetAirgapVersionInput {
  """The version of airgap.js to use"""
  version: String!
}

type SetOrgNotificationDestinationAllowListPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An AllowList of notification destinations"""
  orgNotificationDestinationAllowList: OrgNotificationDestinationAllowList!
}

"""Update notifications AllowList, slack channel ids, emails, etc"""
input AllowNotificationDestinationsInput {
  """The onboarding status of this consent manager"""
  orgNotificationDestinationAllowList: [OrgNotificationDestinationAllowListEntryInput!]!
}

type SetRequestsProcessedDisclosureStatsSettingsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type SetResourceAttributesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AttributeValue"""
  attributeValues: [AttributeValue!]!
}

"""Input for updating an attribute Value"""
input SetResourceAttributesInput {
  """The id of the resource"""
  resourceId: String

  """The ids of the resources"""
  resourceIds: [String!]

  """The resource type"""
  resourceType: AttributeSupportedResourceType!

  """The id of the attribute key"""
  attributeKeyId: ID!

  """The ids of the attribute values to associate with this resource"""
  attributeValueIds: [ID!]

  """The names of the attribute values to associate with this resource"""
  attributeValueNames: [String!]
}

"""list of custom domains hosting the sync endpoint"""
input SetSyncEndpointInput {
  """List of custom domains hosting the sync endpoint"""
  syncEndpoints: [SyncEndpointCustomDomainInput!]!
}

type SetSyncEndpointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SyncEndpointCustomDomain"""
  syncEndpoints: [SyncEndpointCustomDomain!]!
}

"""Input for adding or removing TCF Stacks to an airgap bundle"""
input SetTCFStacksInput {
  """The airgap bundle to update the stacks for"""
  airgapBundleId: ID!

  """List of TCF Stack ids to add or remove from the airgap bundle."""
  tcfStackIds: [Int!]!
}

type SetTokenSecretPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Secrets for signing JWTs"""
  tokenSecrets: TokenSecrets!
}

"""Inputs to the show/hide vendor in the TCF UI endpoint"""
input ShowTCFVendorInput {
  """
  Sets the vendor's (newly created if nonexistent) consent services showInTcfModal field
  """
  show: Boolean!

  """The id of the airgap bundle"""
  airgapBundleId: ID!

  """The ids of the TCF vendors to show/hide in the modal"""
  tcfVendors: [ID!]

  """The ids of the consent services to show/hide in the modal"""
  consentServices: [ID!]
}

type ShowTcfVendorInUiPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""The JWT containing the enriched identifier."""
input SignedIdentifierInput {
  """The name of this identifier"""
  name: String!

  """The JWT containing the enriched information"""
  jwts: [String!]!
}

"""An identifier name mapped to a JSON path for enrichment purposes"""
input SignedIdentifierPathInput {
  """The name of the identifier"""
  identifierName: String!

  """JSON paths to resolve identifier"""
  paths: [String!]!
}

"""An identifier name mapped to a JSON path for enrichment purposes"""
type SignedIdentifierPath {
  """The name of the identifier"""
  identifierName: String!

  """JSON paths to resolve identifier"""
  paths: [String!]!
}

"""Input to add signed & enriched identifiers"""
input SignedIdentifiersInput {
  """
  The RequestEnricher ID - if specified takes precedence over requestId and enricherId
  """
  requestEnricherId: ID

  """
  The request ID - can be specified in addition to enricherId as an alternative to requestEnricherId
  """
  requestId: ID

  """
  The enricher ID - can be specified in addition to enricherId as an alternative to requestEnricherId
  """
  enricherId: ID

  """The template ID to send"""
  templateId: ID

  """The template title to send"""
  templateTitle: String

  """The status of this enricher request"""
  status: AllowedEnricherTransition

  """The signed identifiers JWTs."""
  signedIdentifiers: [SignedIdentifierInput!]

  """The signed and encrypted identifiers JWTs."""
  signedEncryptedIdentifiers: [SignedIdentifierInput!]
}

"""A signup code for registering a new organization"""
type SignupCode {
  """The id of the signup code"""
  id: ID!

  """The signup code"""
  code: String!

  """The tier the token is for"""
  tier: OrganizationTier!

  """The link to the custom terms and conditions"""
  terms: String

  """
  The list of integrations that the token is being created in partnership with
  """
  integrationNames: [String!]!
}

"""Input to look up a signup code"""
input SignupCodeInput {
  """The signup code"""
  code: String!
}

"""Input for counting pending silo discovery recommendations"""
input SiloDiscoveryPendingConfirmationCountFiltersInput {
  """The data silo IDs to count pending recommendations for"""
  dataSiloIds: [ID!]

  """The plugin IDs to count pending recommendations for"""
  pluginIds: [ID!]
}

type SiloDiscoveryPendingRecommendationCountPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """int"""
  totalCount: Int!
}

"""A remote resource discovered by a data silo discovery run"""
input SiloDiscoveryRawResultInput {
  """Unique identifier"""
  resourceId: String!

  """The resource name"""
  name: String!

  """The resource title"""
  title: String

  """Host associated with the resource"""
  host: String

  """Plaintext associated with the resource"""
  plaintextContext: String

  """Type of data silo"""
  type: String

  """
  Whether or not to only classify these results using "strict" mode. This means the service classifier will only surface exact matches against our integration catalog, so you may have fewer entries classifier, but the quality of the classification may be higher.
  """
  useStrictClassifier: Boolean
}

"""A recommendation from a silo discovery plugin"""
type SiloDiscoveryRecommendation {
  """The ID of the plugin that found this recommendation"""
  pluginId: ID!

  """The plugin that found this recommendation"""
  plugin: Plugin!

  """The unique identifier for the resource"""
  resourceId: String!

  """The custom title of the data silo recommendation."""
  title: String

  """The AWS Region for data silo if applicable"""
  region: String

  """The ISO country code for the AWS Region if applicable"""
  country: String

  """The ISO country subdivision code for the AWS Region if applicable"""
  countrySubDivision: String

  """The suggested catalog for this recommendation"""
  suggestedCatalog: Catalog!

  """
  The raw inputs that were provided by the plugin as additionalContext and fed into our classifier
  """
  rawInputs: [PlaintextContext!]!

  """The plaintext that we will pass into recommendation"""
  plaintextContext: String

  """Timestamp of the plugin run that found this silo recommendation"""
  lastDiscoveredAt: Date!

  """The plugin configurations for the recommendation"""
  pluginConfigurations: DataSiloPluginConfigurations
}

"""Fields used for apollo caching for our UI"""
type SiloDiscoveryRecommendationCacheFields {
  """Silo discovery recommendations were PENDING status"""
  isPending: Boolean

  """Silo discovery recommendations were filtered by this integration name"""
  text: String

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginIds: [ID!]
}

"""Input for filtering a list of silo discovery recommendations"""
input SiloDiscoveryRecommendationFiltersInput {
  """Filter silo discovery recommendation by integration name"""
  text: String

  """Filter silo discovery recommendations by the plugin that discovered it"""
  pluginIds: [ID!]
}

type SiloDiscoveryRecommendationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SiloDiscoveryRecommendation"""
  nodes: [SiloDiscoveryRecommendation!]!

  """
  The key for a `DataSiloDiscoPluginRecommendation` document from DynamoDB
  """
  lastKey: DataSiloDiscoPluginRecommendationKey

  """Fields used for apollo caching for our UI"""
  cacheBy: SiloDiscoveryRecommendationCacheFields!
}

"""Input for listing silo discovery recommendations"""
input SiloDiscoveryRecommendationsInput {
  """
  Whether to list pending recommendations, otherwise ignored recommendations
  """
  isPending: Boolean!

  """The `LastEvaluatedKey` received from DynamoDB for the previous page"""
  lastKey: DataSiloDiscoPluginRecommendationKeyInput
}

"""Data silo that was discovered by the plugin from this data silo"""
type SilosDiscoveredPreview {
  """plugin IDs of the Data Silo"""
  pluginId: ID

  """Count of silos discovered"""
  value: String
}

"""Status of a sitescan for an organization"""
type Sitescan {
  """The status of the sitescan"""
  status: SitescanStatus!
}

"""The response for a result from the sitescanner"""
input SitescannerCookieInput {
  """The cookie found by the sitescan"""
  cookie: String!

  """The guess for the purpose of the SaaS tool"""
  purposeGuesses: [Purpose!]!

  """The name of the SaaS tool found by the sitescanner"""
  name: String
}

"""The response for a result from the sitescanner"""
input SitescannerResponseInput {
  """The domain of the SaaS tool found by the sitescan"""
  domain: String!

  """The guess for the purpose of the SaaS tool"""
  purposeGuess: Purpose!

  """The name of the SaaS tool found by the sitescanner"""
  name: String
}

type SkipRequestEnricherPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A request enrichment that needs to be responded to"""
  requestEnricher: RequestEnricher!
}

"""Metadata about a connected Slack user"""
type SlackUserMetadata {
  """The slack username"""
  username: String!

  """The user's full name"""
  fullName: String!

  """The URL of the user's profile picture"""
  profilePicture: String!
}

"""Metadata about a connected slack workspace"""
type SlackWorkspaceMetadata {
  """The team name"""
  team: String!

  """The id of the team"""
  teamId: String!

  """The channels in the workspace"""
  channels: [SlackWorkspaceMetadataChannel!]!
}

"""A channel in a slack workspace"""
type SlackWorkspaceMetadataChannel {
  """The channel id"""
  id: String!

  """The channel name"""
  name: String!
}

"""A code snippet that is shown as form item helper text"""
type SnippetConfig {
  """The code language the snippet is in"""
  language: SnippetLanguage!

  """The code snippet to show with the form item"""
  snippet: String!
}

"""
A software development kit that contains code submitted to a particular repository
"""
type SoftwareDevelopmentKit {
  """The id of the software development kit"""
  id: ID!

  """The name of the software development kit"""
  name: String!

  """The description of the software development kit"""
  description: String!

  """The type of dependency"""
  codePackageType: CodePackageType!

  """The repository URL of the software development kit"""
  repositoryUrl: String

  """The registry URL of the software development kit"""
  registryUrl: String!

  """The documentation links of the software development kit"""
  documentationLinks: [String!]!

  """The date the software development kit was created"""
  createdAt: Date!

  """The date the software development kit was last updated"""
  updatedAt: Date!

  """
  The software development kit metadata that Transcend holds on this tool
  """
  sdk: Sdk

  """The integration catalog metadata that Transcend holds on this tool"""
  catalog: SelectableCatalog

  """
  The guessed integration catalog metadata that Transcend holds on this tool
  """
  guessedCatalog: SelectableCatalog

  """The repositories where this software development kit is used"""
  repositories: [RepositoryPreview!]!

  """The code packages where this software development kit is used"""
  codePackages: [CodePackagePreview!]!

  """The users that are in charge of this software development kit"""
  owners: [UserPreview!]!

  """The teams that are in charge of this software development kit"""
  teams: [TeamPreview!]!
}

"""Inputs for filtering a list of software development kits"""
input SoftwareDevelopmentKitFiltersInput {
  """The ids of the software development kits"""
  ids: [ID!]

  """The ids of the users that created the software development kits"""
  ownerIds: [ID!]

  """The ids of the teams that created the software development kits"""
  teamIds: [ID!]

  """
  The ids of the repositories that the software development kits are found in
  """
  repositoryIds: [ID!]

  """
  The ids of the code packages that the software development kits are found in
  """
  codePackageIds: [ID!]

  """
  The names of the confirmed integrations that the software development kits relate to
  """
  confirmedIntegrationNames: [String!]

  """
  The names of the guessed integrations that the software development kits relate to
  """
  guessedIntegrationNames: [String!]

  """Filter by text (name, description, repositoryUrl)"""
  text: String

  """Filter by software development kit name"""
  name: String

  """Filter on exact software development kit names"""
  names: [String!]

  """Filter by whether or not the entry is linked to a consent SDK"""
  linkedToConsentSdk: Boolean

  """
  Filter by whether or not the entry is part of a code package that is a consent application
  """
  linkedToConsentApplication: Boolean

  """The types of code package to include"""
  codePackageTypes: [CodePackageType!]
}

"""
An instance of a software development kit that is used in a code package
"""
type SoftwareDevelopmentKitForPackage {
  """The software development kit instance"""
  softwareDevelopmentKit: SoftwareDevelopmentKitPreview!

  """The date the software development kit was last reported on"""
  lastSeenAt: Date

  """The version of the SDK in the code package"""
  version: String
}

"""The order for a SoftwareDevelopmentKit query"""
input SoftwareDevelopmentKitOrder {
  """The field that the SoftwareDevelopmentKit nodes should be ordered by"""
  field: SoftwareDevelopmentKitOrderField!

  """
  The direction in which to order the SoftwareDevelopmentKit nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a software development kit instance"""
type SoftwareDevelopmentKitPreview {
  """The id of the software development kit"""
  id: ID!

  """The name of the software development kit"""
  name: String!

  """The description of the software development kit"""
  description: String!

  """The type of dependency"""
  codePackageType: CodePackageType!

  """The repository URL of the software development kit"""
  repositoryUrl: String

  """The registry URL of the software development kit"""
  registryUrl: String!

  """The documentation links of the software development kit"""
  documentationLinks: [String!]!

  """The date the software development kit was created"""
  createdAt: Date!

  """The date the software development kit was last updated"""
  updatedAt: Date!
}

type SoftwareDevelopmentKitsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SoftwareDevelopmentKit"""
  nodes: [SoftwareDevelopmentKit!]!

  """int"""
  totalCount: Int!
}

"""The sombra configuration"""
type Sombra implements SombraInterface {
  """The id of the sombra"""
  id: ID!

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  publicKeyECDH: String

  """The url of the Sombra instance that Transcend uses (transcend-ingress)"""
  url: String!

  """
  The title of the gateway, useful for a human-readable name when there are multiple gateways in an organization
  """
  title: String

  """
  The url of the Sombra instance that the client posts to when responding to a server silo
  """
  publicUrl: String!

  """
  When true, the sombra gateway is the primary instance in the organization
  """
  isPrimarySombra: Boolean!

  """
  The url of the Sombra instance that the customer should use (customer-ingress)
  """
  customerUrl: String!

  """The ip addresses of the sombra instance"""
  ipAddresses: [String!]!

  """The Sombra instance type"""
  hostedMethod: SombraHostedMethod!

  """The most recent version of Sombra available"""
  mostRecentSombra: String!

  """The semantic version that the sombra is on"""
  version: String

  """The tenant parameters config"""
  tenantParameters: TenantParamsInputSchema

  """The sombra audience"""
  audience: String!

  """The employee authentication methods"""
  employeeAuthenticationMethods: [SombraEmployeeAuthMethod!]

  """The data subject authentication methods"""
  dataSubjectAuthenticationMethods: [SombraDataSubjectAuthMethod!]

  """If the Sombra is accessed through Transcend's Reverse Tunnel"""
  isReverseTunneledSombra: Boolean!
}

"""An API key to be used with a Sombra instance"""
type SombraApiKey {
  """Sombra API key ID"""
  id: ID!

  """The key itself"""
  key: String!

  """When the key expires"""
  expiredAt: Date
}

"""An API key belonging to a Sombra"""
type SombraApiKeyEntry {
  """Model ID"""
  id: ID!

  """The sombra gateway this key belongs to"""
  sombra: SombraPreview!

  """API key hash"""
  hash: String!

  """API key preview"""
  preview: String!

  """API key name"""
  name: String!

  """API key creation date"""
  createdAt: Date

  """API key expiration, if any"""
  expiredAt: Date
}

"""Input to filter Sombra API keys"""
input SombraApiKeysFilterInput {
  """Filter by API key name"""
  text: String

  """Filter by Sombra ID"""
  sombraId: ID
}

"""A change in the changelog"""
type SombraChangelogEntry {
  """The semantic version of the update"""
  version: String!

  """A description of the changes brought by this version"""
  description: String!

  """The sombra gateways that have this version"""
  sombras: [SombraPreview!]!
}

"""The core identifier signed by sombra"""
type SombraCoreIdentifier {
  """The value of the core identifier"""
  value: String!

  """The method that the core identifier was attested by"""
  initialAuthMethod: SombraDataSubjectAuthMethod

  """The type of data subject logged in as"""
  subjectType: String
}

type SombraDataSubjectLoginPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The profile for a logged in user on privacy center"""
  profile: SombraProfile!

  """The core identifier signed by sombra"""
  coreIdentifier: SombraCoreIdentifier!

  """
  A data subject classification that the organization will accept requests for
  """
  dataSubject: DataSubject!

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""Input for filtering sombras"""
input SombraFilterInput {
  """Filter by sombra id"""
  ids: [ID!]

  """Filter by sombra url"""
  urls: [String!]

  """Filter by text on title, url, publicUrl"""
  text: String
}

"""relevant fields to get a sombra host"""
input getSombraInput {
  """The "In-Reply-To" field of an email"""
  inReplyTo: String!
}

"""The sombra configuration interface"""
interface SombraInterface {
  """The id of the sombra"""
  id: ID!

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  publicKeyECDH: String

  """The url of the Sombra instance that Transcend uses (transcend-ingress)"""
  url: String!

  """
  The title of the gateway, useful for a human-readable name when there are multiple gateways in an organization
  """
  title: String

  """
  The url of the Sombra instance that the client posts to when responding to a server silo
  """
  publicUrl: String!

  """
  When true, the sombra gateway is the primary instance in the organization
  """
  isPrimarySombra: Boolean!

  """
  The url of the Sombra instance that the customer should use (customer-ingress)
  """
  customerUrl: String!

  """The ip addresses of the sombra instance"""
  ipAddresses: [String!]!

  """The Sombra instance type"""
  hostedMethod: SombraHostedMethod!

  """The most recent version of Sombra available"""
  mostRecentSombra: String!

  """The semantic version that the sombra is on"""
  version: String

  """The tenant parameters config"""
  tenantParameters: TenantParamsInputSchema

  """The sombra audience"""
  audience: String!

  """The employee authentication methods"""
  employeeAuthenticationMethods: [SombraEmployeeAuthMethod!]

  """The data subject authentication methods"""
  dataSubjectAuthenticationMethods: [SombraDataSubjectAuthMethod!]

  """If the Sombra is accessed through Transcend's Reverse Tunnel"""
  isReverseTunneledSombra: Boolean!
}

"""
The sombra configuration needed to make a request to external side of sombra.
This is the input to createSombraService, a function which constructs an instance capable of sending a request
to the external side of sombra.

An example usage here would be from email-receiver -> sombra.
In order to authenticate to the sombra gateway it must first ask the backend
for the sombra configuration necessary to authenticate.
"""
type SombraInternalUseOnly {
  """The id of the sombra"""
  id: ID!

  """The url of the Sombra instance that Transcend uses (transcend-ingress)"""
  url: String!

  """
  The url of the Sombra instance that the client posts to when responding to a server silo
  """
  publicUrl: String!

  """The semantic version that the sombra is on"""
  version: String

  """JWT audience for the gateway"""
  audience: String!

  """The Sombra instance type"""
  hostedMethod: SombraHostedMethod!

  """Encrypted tenant secrets, used to configure gateway when multi tenant"""
  tenantSecrets: String

  """
  JWT signed tenant parameters, used to configure gateway when multi tenant
  """
  tenantParameters: String
}

"""A Sombra key entry -- used to track key versions"""
input SombraKMSKeyEntryInput {
  """The keys source"""
  keySource: SombraKMSKeySource!

  """The canary value for the key"""
  canaryValue: String!

  """The canary key type -- JWT, hash, encrypted value, etc."""
  canaryType: SombraKMSCanaryValueType!

  """
  Indices start from zero. Represents the order of keys  during a key rotation, with zero being the current key set.
  """
  index: Int!
}

"""
A Sombra key entry output returned by the backend -- used to track key versions
"""
type SombraKMSKeyEntryOutput {
  """The keys source"""
  keySource: SombraKMSKeySource!

  """The canary value for the key"""
  canaryValue: String!

  """The canary key type -- JWT, hash, encrypted value, etc."""
  canaryType: SombraKMSCanaryValueType!

  """
  Indices start from zero. Represents the order of keys  during a key rotation, with zero being the current key set.
  """
  index: Int!

  """The key ID assigned by the backend"""
  id: String!
}

"""A Sombra key set for a key type."""
input SombraKMSKeySetInput {
  """The key type"""
  keyType: SombraKMSKeyType!

  """The canary values for the keys used in this key set"""
  canaries: [SombraKMSKeyEntryInput!]!
}

"""A Sombra key set for a key type."""
type SombraKMSKeySetOutput {
  """The key type"""
  keyType: SombraKMSKeyType!

  """
  The canary values for the keys used in this key set, along with their assigned key IDs
  """
  canaries: [SombraKMSKeyEntryOutput!]!
}

"""The metadata for the Sombra key sets"""
type SombraKMSKeysMetadata {
  """List of key sets along with their assigned Key IDs."""
  keySets: [SombraKMSKeySetOutput!]!
}

"""The order for a Sombra query"""
input SombraOrder {
  """The field that the Sombra nodes should be ordered by"""
  field: SombraOrderField!

  """
  The direction in which to order the Sombra nodes by the specified field
  """
  direction: OrderDirection!
}

"""The sombra configuration previewed"""
type SombraPreview {
  """The id of the sombra"""
  id: ID!

  """The url of the Sombra instance that Transcend uses (transcend-ingress)"""
  url: String!

  """
  The title of the gateway, useful for a human-readable name when there are multiple gateways in an organization
  """
  title: String

  """The Sombra instance type"""
  hostedMethod: SombraHostedMethod!

  """
  The Elliptic Curve Diffie-Hellman public key for encrypted communication with this Sombra instance
  """
  publicKeyECDH: String
}

"""The profile for a logged in user on privacy center"""
type SombraProfile {
  """A URL to the profile picture of the logged in user"""
  picture: String

  """The nickname of the logged in user"""
  nickname: String

  """The email of the logged in user"""
  email: String
}

"""
  The session information returned from sombra about the logged in user
This is calculated from a dhEncrypted and can only be deconstructed by the privacy center
"""
type SombraSession {
  """The profile information for that logged in user"""
  profile: SombraProfile!

  """The core identifier for the logged in user"""
  coreIdentifier: SombraCoreIdentifier!

  """The decryption context containing the wrapped long-lived session"""
  decryptionContext: DecryptionContext!
}

type SombraSingleTenantConfigSyncPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  done: Boolean!

  """The metadata for the Sombra key sets"""
  keysMetadata: SombraKMSKeysMetadata
}

"""Sombra Single-Tenant Config sync GraphQL mutation input."""
input SombraSingleTenantConfigSyncInput {
  """
  The unique ID for your self-hosted sombra instance (useful if there are multiple instances)
  """
  id: String

  """The organization URI."""
  uri: String!

  """Sombra instance configuration as a JWT."""
  configJwt: String!

  """KMS type the Sombra is using"""
  kmsProvider: String

  """Sombra KMS key entries to be used for key tracking"""
  keySets: [SombraKMSKeySetInput!]
}

"""The configuration settings for an SSO provider"""
type SsoProvider {
  """
  This is a label telling us the name of the issuer application (AKA the "Entity ID")
  """
  issuer: String!

  """The redirect URL provided by the SSO issuer"""
  entryPoint: String!

  """The public key of the SSO provider"""
  cert: String!

  """
  When user's have an email address from any domain in this list, they are authenticated against this SSO configuration
  """
  domains: [String!]!

  """When true, should auto-provision accounts for unrecognized emails"""
  shouldCreateUser: Boolean!

  """The unique id of the sso provider configuration"""
  id: ID!

  """
  The environment variables that are different between sombra and transcend db
  """
  invalidEnvs: [EnvComparison!]!

  """
  The default team that users should be added to when auto provisioning. If the user is auto provisioned to other teams using groups or attributes, that team will be assigned instead of this team.
  """
  defaultTeam: TeamPreview

  """
  The custom audience for the SSO provider to validate. If null, the default audience `transcend` is used. This is only updatable by Transcend internally.
  """
  customAudience: String
}

"""Input to create or update the SSO provider information"""
input SsoProviderInput {
  """
  This is a label telling us the name of the issuer application (AKA the "Entity ID")
  """
  issuer: String!

  """The redirect URL provided by the SSO issuer"""
  entryPoint: String!

  """The public key of the SSO provider"""
  cert: String!

  """
  When user's have an email address from any domain in this list, they are authenticated against this SSO configuration
  """
  domains: [String!]!

  """
  The default team that users should be added to when auto provisioning. If the user is auto provisioned to other teams using groups or attributes, that team will be assigned instead of this team.
  """
  defaultTeamId: ID

  """When true, should auto-provision accounts for unrecognized emails"""
  shouldCreateUser: Boolean!
}

"""A step in the lifecycle of the DSR, with sub-steps"""
type Step implements StepInterface {
  """The id of the step is the request status"""
  id: String!

  """A description of what is happening at this step"""
  description: String!

  """The title message for the step"""
  title: String!

  """The icon to to display with the step"""
  icon: String!

  """The status of the step as it relates to the ant.design component"""
  status: StepStatus

  """The time that the step occurred"""
  time: Date

  """The sub-steps of the request"""
  steps: [ChildStep!]!
}

"""A step in the lifecycle of the DSR"""
interface StepInterface {
  """The id of the step is the request status"""
  id: String!

  """A description of what is happening at this step"""
  description: String!

  """The title message for the step"""
  title: String!

  """The icon to to display with the step"""
  icon: String!

  """The status of the step as it relates to the ant.design component"""
  status: StepStatus

  """The time that the step occurred"""
  time: Date
}

type StoreColorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for storing the colors found by the sitescanner service"""
input StoreColorsInput {
  """The url that the sitescan was run on"""
  url: String!

  """The organization that initiated the sitescan"""
  organizationId: ID!

  """The hex values of the colors found by the sitescanner service"""
  colors: [String!]!
}

type StoreCookiePurposeResultsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScanCookiePurpose"""
  scanCookiePurposes: [ScanCookiePurpose!]!
}

type StoreDomainPurposeResultsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ScanDomainPurpose"""
  scanDomainPurposes: [ScanDomainPurpose!]!
}

"""
A property of a datapoint, corresponding to a single piece of personal data
"""
type SubDataPoint {
  """The ID of the subdatapoint"""
  id: ID!

  """The time the subdatapoint was first discovered"""
  createdAt: Date!

  """The name of the subdatapoint"""
  name: String!

  """The display title of the subdatapoint"""
  title: DefinedMessage

  """The slug of the sub datapoint for templating"""
  slug: String!

  """The datapoint for this subdatapoint"""
  dataPoint: DataPoint!

  """The ID of the dataSilo for this subdatapoint"""
  dataSiloId: ID!

  """The ID of the datapoint to associate with this subDataPoint"""
  dataPointId: ID!

  """A description for the subdatapoint"""
  description: String

  """
          When true, this subdatapoint should be revealed in a data access request.
  When false, this field should be redacted.
  """
  accessRequestVisibilityEnabled: Boolean!

  """
          When true, this subdatapoint should be redacted during an erasure request.
  There normally is a choice of enabling hard deletion or redaction at the
  datapoint level, but if redaction is enabled, this column can be used
  to define which fields should be redacted..
  """
  erasureRequestRedactionEnabled: Boolean!

  """The category of personal data for this subdatapoint"""
  categories: [DataSubCategory!]!

  """Guessed subcategories by our classifier that are pending review"""
  pendingCategoryGuesses: [SubDataPointDataSubCategoryGuess!]!

  """The processing purposes for this subdatapoint"""
  purposes: [PurposeSubCategory!]!

  """The attribute values used to label this subdatapoint"""
  attributeValues: [AttributeValue!]!

  """
  The list of teams who are responsible for managing the parent data silo
  """
  dataSiloTeams: [TeamPreview!]!

  """The owners of the DataPoint that is parent of this SubDataPoint"""
  dataPointOwners: [UserPreview!]!

  """The owners of the DataSilo that is parent of this SubDataPoint"""
  dataSiloOwners: [UserPreview!]!

  """The vendor of the DataSilo that is parent of this SubDataPoint"""
  dataSiloVendor: VendorPreview

  """
  The list of teams who are responsible for managing the parent data point
  """
  dataPointTeams: [TeamPreview!]!

  """The content classification status for this SubDataPoint"""
  contentClassificationStatus: ContentClassificationStatus!

  """Whether or not we can refetch the samples for this SubDataPoint"""
  canRefetchSample: Boolean!

  """The organization's controllership of the subdatapoint"""
  controllership: Controllership

  """The last time the subdatapoint's categories were classified"""
  lastClassifiedAt: Date

  """
  The last time the subdatapoint's categories were schedule to be classified
  """
  lastRunAt: Date

  """The list of data subjects that are allowed for this sub-datapoint"""
  subjects: [DataSubject!]!

  """The type of retention schedule for this subdatapoint"""
  retentionType: RetentionType!

  """
  The number of days personal data is retained (for stated period retention types)
  """
  retentionPeriod: Int

  """S3 key for retrieving encrypted samples"""
  encryptedSamplesS3Key: String

  """
  Error message if there was an error encountered while fetching samples or classifying this subdatapoint
  """
  error: String

  """The encryptions to apply to this subdatapoint"""
  encryption: ColumnEncryptionType

  """The fully qualified ID of the subdatapoint"""
  subDataPointFQId: String!

  """The set of processing activities assigned to this subdatapoint"""
  processingActivities: [ProcessingActivityPreview!]!
}

"""Classification of a subDataPoint"""
type SubDataPointClassification {
  """The type of subDataPoint"""
  type: String

  """The ID of category"""
  id: String

  """category name of the guessed subcategory"""
  name: String

  """The guessed subcategory"""
  category: String

  """The confidence value for this guess"""
  confidence: Float!

  """
  The model version of the LLM or ML classifier that generated this guess
  """
  classifierVersion: Int

  """High, Medium, or Low confidence"""
  confidenceLabel: ConfidenceLabel!

  """The classification method used to produce this guess"""
  classificationMethod: ClassificationMethod!
}

"""Cursor for paginating subdatapoints"""
input SubDataPointCursorInput {
  """
  Filter to requests after a create date. Must be an empty string if fetching the very first page.
  """
  createdAt: String

  """
  ID of the last subdatapoint in the previous page of results. This ID is not included in the next page of results
  """
  id: ID
}

"""A subcategory guess for a subdatapoint"""
type SubDataPointDataSubCategoryGuess {
  """The ID of the subcategory guess"""
  id: ID!

  """The confidence value for this guess"""
  confidence: Float!

  """The status of this guess"""
  status: SubDataPointDataSubCategoryGuessStatus!

  """The guessed subcategory"""
  category: DataSubCategory!

  """
  The model version of the LLM or ML classifier that generated this guess
  """
  classifierVersion: Int

  """The classification method used to produce this guess"""
  classificationMethod: ClassificationMethod
}

type SubDataPointErrorRollupPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SubDataPointErrorRollup"""
  nodes: [SubDataPointErrorRollup!]!

  """int"""
  totalCount: Int!
}

"""
Rollup of errors encountered while scanning or classifying a property (aka subdatapoint)
"""
type SubDataPointErrorRollup {
  """The error message"""
  errorMessage: String!

  """The count of this error message"""
  errorCount: Int!
}

"""Input for filtering subdatapoint error rollups"""
input SubDataPointErrorRollupFilterInput {
  """The ID of the data silo"""
  dataSiloId: ID!

  """The ID of the data point"""
  dataPointId: ID
}

"""Input for filtering a list of subdatapoints"""
input SubDataPointFiltersInput {
  """Filter by subdatapoint ids"""
  ids: [ID!]

  """Filter by text"""
  text: String

  """
  Filter by the datapoint name directly. Include quotes around the text to perform and exact match, otherwise it will perform a partial match search.
  """
  dataPointName: String

  """
  Filter by the subdatapoint name directly. Include quotes around the text to perform and exact match, otherwise it will perform a partial match search.
  """
  subDataPointName: String

  """Filter by datapoints the subdatapoints belong to"""
  dataPoints: [ID!]

  """Filter by data silos the subdatapoints belong to"""
  dataSilos: [ID!]

  """Filter by category of personal data"""
  category: [DataCategoryType!]

  """Filter by specific subcategory of personal data"""
  subCategoryIds: [ID!]

  """Filter by specific subcategory of personal data"""
  subCategories: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """Filter by specific subcategory of processing purpose"""
  processingPurposeSubCategoryIds: [ID!]

  """Filter by status of guess"""
  status: SubDataPointDataSubCategoryGuessStatus

  """Filter for subcategories with guesses of a minimum confidence value"""
  minConfidence: Float

  """Filter for subcategories with guesses of a maximum confidence value"""
  maxConfidence: Float

  """Filter by whether to include or exclude NOT_PERSONAL_DATA category"""
  includeNotPersonalData: IncludeNotPersonalData

  """
  The ids of the teams that should be responsible for the parent data silo
  """
  dataSiloTeams: [ID!]

  """Filter by the assigned owner of the parent DataPoint"""
  dataPointOwners: [ID!]

  """Filter by the assigned owner of the parent DataSilo"""
  dataSiloOwners: [ID!]

  """Filter by the assigned vendor of the parent DataSilo"""
  dataSiloVendorIds: [ID!]

  """
  The ids of the teams that should be responsible for the parent data point
  """
  dataPointTeams: [ID!]

  """Filter by the attribute values used to label the subdatapoint"""
  attributeValueIds: [ID!]

  """Filter by controllerships assigned to subdatapoints"""
  controllerships: [Controllership!]

  """Filter by the subjects that are allowed for this sub-datapoint"""
  subjectIds: [ID!]

  """Filter by the type of retention schedule for this subdatapoint"""
  retentionTypes: [RetentionType!]

  """
  Filter by whether this subdatapoint should be revealed in a data access request.
  """
  accessRequestVisibilityEnabled: Boolean

  """Filter to requests after a create date."""
  createdAtAfter: String

  """
  Filters by whether the subdatapoint should be redacted during an erasure request
  """
  erasureRequestRedactionEnabled: Boolean

  """
  Filter by subdatapoints whose a content classification status is in this list
  """
  contentClassificationStatus: [ContentClassificationStatus!]

  """Filter by any of the subDataPoint's ancestor dataPointLevels"""
  dataPointLevelName: String

  """Cursor to identify where to start the next page of data."""
  cursor: SubDataPointCursorInput

  """Filter by the associated processing activities"""
  processingActivityIds: [ID!]
}

"""Input for classifying an arbitrary subDataPoint"""
input SubDataPointInput {
  """The ID of the dataSilo for this subdatapoint"""
  dataSiloId: ID!

  """Fully qualified ID of the subDataPoint"""
  subDataPointFQId: String!

  """S3 key for retrieving encrypted samples"""
  encryptedSamplesS3Key: String
}

"""Input for refetching samples"""
input SubDataPointRefetchSampleInfoInput {
  """The id of the subDataPoint"""
  id: ID!

  """
  How to refetch samples for this subDataPoint (e.g., whether to filter for non-null rows or not). Defaults to "DEFAULT"
  """
  refetchMethod: RefetchSampleMethod
}

type SubDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SubDataPoint"""
  nodes: [SubDataPoint!]!

  """int"""
  totalCount: Int!
}

"""Response after unwrapping a set of sub datapoint samples"""
type SubDataPointSampleDecryptionContext {
  """The id of the sub datapoint"""
  id: ID!

  """The context needed to decrypt the sample in the browser"""
  decryptionContext: DecryptionContext
}

type SubmitAssessmentFormForReviewTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment form that can be filled out by users"""
  assessmentForm: AssessmentFormRaw!
}

"""A consent manager to sync data privacy preferences with"""
type SyncedConsentManager {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """The sync configuration for this Consent Manager."""
  configuration: SyncedConsentManagerBundleConfig!

  """The absolute URL of where the consent manager JS bundle is hosted."""
  bundleURL: String!

  """
  The absolute URL of where the test bundle of the consent manager is hosted.
  """
  testBundleURL: String!

  """
  The absolute URL of where the tcf ui bundle of the consent manager is hosted.
  """
  tcfUiBundleURL: String!
}

"""
Subset of configuration for a consent manager that pertains to syncing consent
"""
type SyncedConsentManagerBundleConfig {
  """The XDI sync endpoint for this airgap bundle"""
  syncEndpoint: String
}

"""Custom domain hosting a sync endpoint"""
type SyncEndpointCustomDomain {
  """The custom domain"""
  domain: String!

  """Whether this is the default sync endpoint"""
  isDefault: Boolean!
}

"""Custom domain hosting a sync endpoint"""
input SyncEndpointCustomDomainInput {
  """The custom domain"""
  domain: String!

  """Whether this is the default sync endpoint"""
  isDefault: Boolean
}

"""Input for creating or updating preferences for a given table"""
input TablePreferencesInput {
  """The names of columns in the order they should be shown in the table"""
  orderedColumns: [String!]

  """The names of columns to hide"""
  hiddenColumns: [String!]

  """The last time this set of preferences was selected for this table"""
  lastSelected: Date

  """
  Whether this preference is preferred for this table. ONLY set on user preferences.
  """
  isPreferred: Boolean
}

"""An interface for creating or updating preferences for a given table"""
interface TablePreferencesInterface {
  """The names of columns in the order they should be shown in the table"""
  orderedColumns: [String!]

  """The names of columns to hide"""
  hiddenColumns: [String!]

  """The last time this set of preferences was selected for this table"""
  lastSelected: Date

  """
  Whether this preference is preferred for this table. ONLY set on user preferences.
  """
  isPreferred: Boolean
}

"""Input for creating or updating preferences for all tables"""
input TablesPreferencesInput {
  """Preferences for the data silos table"""
  DATA_INVENTORY_DATA_SILOS: TablePreferencesInput

  """Preferences for the subdatapoints table"""
  DATA_INVENTORY_DATA_POINTS: TablePreferencesInput

  """Preferences for the processing activities table"""
  DATA_INVENTORY_PROCESSING_ACTIVITIES: TablePreferencesInput

  """Preferences for the vendors table"""
  DATA_INVENTORY_VENDORS: TablePreferencesInput

  """Preferences for the data subcategories table"""
  DATA_INVENTORY_DATA_CATEGORIES: TablePreferencesInput

  """Preferences for the processing purpose table"""
  DATA_INVENTORY_PURPOSES: TablePreferencesInput

  """Preferences for the business entities table"""
  DATA_INVENTORY_BUSINESS_ENTITIES: TablePreferencesInput

  """Preferences for the triage data flows table"""
  CONSENT_DATA_FLOWS_TRIAGE: TablePreferencesInput

  """Preferences for the approved data flows table"""
  CONSENT_DATA_FLOWS_APPROVED: TablePreferencesInput

  """Preferences for the junk data flows table"""
  CONSENT_DATA_FLOWS_JUNK: TablePreferencesInput

  """Preferences for the triage cookies"""
  CONSENT_COOKIES_TRIAGE: TablePreferencesInput

  """Preferences for the approved cookies"""
  CONSENT_COOKIES_APPROVED: TablePreferencesInput

  """Preferences for the junk cookies"""
  CONSENT_COOKIES_JUNK: TablePreferencesInput

  """Preferences for the preference store table"""
  CONSENT_USER_PREFERENCES: TablePreferencesInput

  """Preferences for the junk cookies"""
  RISK_INTELLIGENCE_ASSESSMENTS: [AssessmentsPreferencesInput!]

  """Preferences for incoming requests"""
  DSR_AUTOMATION_INCOMING_REQUESTS: TablePreferencesInput

  """Preferences for the sensitive categories table"""
  DATA_INVENTORY_SENSITIVE_CATEGORIES: TablePreferencesInput
}

"""Transparency & Consent Framework (TCF) data category"""
type TCFDataCategory {
  """The ID of the data category as used by TCF"""
  id: Int

  """
  The name of the data category, e.g. "Browsing and interaction data"
  """
  name: String

  """The description of the data category"""
  description: String
}

"""TCF Feature for a particular consent bundle"""
type TCFFeature {
  """The id of the TCF Feature"""
  id: ID!

  """The name of the TCF Feature"""
  name: String!

  """Whether this feature is applicable to the organization"""
  isApplicable: Boolean!

  """total number of vendors declaring this feature"""
  vendorsDeclaring: Int!
}

type TcfFeaturesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFFeature"""
  nodes: [TCFFeature!]!

  """int"""
  totalCount: Int!
}

"""Transparency & Consent Framework (TCF) Purpose"""
type TCFPurpose {
  """The ID of the purpose as used by TCF"""
  id: Int

  """
  The name of the purpose, e.g. "Select basic ads"
  """
  name: String

  """The description of the purpose"""
  description: String

  """The duration for which data is stored (days)"""
  dataRetentionPeriod: Int

  """Real-world examples of the purpose"""
  illustrations: [String!]
}

"""Airgap Purposes inferred from a TCF Purpose"""
type TCFPurposeTrackingPurposes {
  """The id of the organization's TCF purpose"""
  id: ID!

  """Whether or not this TCF purpose is applicable for the organization"""
  isApplicable: Boolean!

  """
  Whether or not this TCF purpose is allowed to be processed based on legitimate interest basis
  """
  allowLegitimateInterest: Boolean!

  """TCF Purpose"""
  tcfPurpose: TCFPurpose!

  """Airgap Purpose"""
  trackingPurposes: [TrackingPurpose!]!

  """Number of vendors that have declared this purpose"""
  vendorsDeclaring: Int!
}

"""Transparency & Consent Framework (TCF) Special Feature"""
type TCFSpecialFeature {
  """The ID of the special feature as used by TCF"""
  id: Int!

  """
  The name of the special feature, e.g. "Use precise geolocation data"
  """
  name: String!

  """The description of the special feature"""
  description: String!

  """Real-world examples of the special feature"""
  illustrations: [String!]!
}

"""TCF Special Feature for a particular consent bundle"""
type TCFSpecialFeatureTrackingPurpose {
  """The ID of the special feature as used by TCF"""
  id: ID!

  """The TCF Special Feature"""
  tcfSpecialFeature: TCFSpecialFeature!

  """Whether this feature is applicable to the organization"""
  isApplicable: Boolean!

  """total number of vendors declaring this feature"""
  vendorsDeclaring: Int!

  """A list of tracking purposes associated with this special feature"""
  purposes: [TrackingPurpose!]!
}

"""
Transparency & Consent Framework (TCF) Stack -combinations of purposes and features used to simplify understanding of consent management
"""
type TCFStack {
  """The ID of the stack as used by TCF"""
  id: Int!

  """
  The name of the stack, e.g. "Precise geolocation data, and identification through device scanning"
  """
  name: String!

  """"""
  description: String!

  """Purposes grouped together in the stack"""
  purposes: [TCFPurpose!]

  """Special Features grouped together in the stack"""
  specialFeatures: [TCFSpecialFeature!]
}

"""Input for filtering TCF Stacks endpoint by"""
input TCFStackFilterInput {
  """Filters by whether the substring is present in the GVL vendor name"""
  text: String

  """The TCF purposes associated with this stack"""
  purposeIds: [ID!]

  """The TCF special features associated with this stack"""
  specialFeatureIds: [ID!]

  """Filter to only show stacks that are shown in the TCF modal"""
  showInTcfModal: Boolean
}

"""
Transparency & Consent Framework (TCF) Vendor URLs for privacy policies in different languages
"""
type TCFUrl {
  """The language for these set of URLs"""
  langId: String

  """Link to the privacy policy for the vendor in the specified language"""
  privacy: String

  """
  Link to the legitimate interest claim for the vendor in the specified language
  """
  legIntClaim: String
}

"""
Transparency & Consent Framework (TCF) Vendor--matches output for IAB vendors list
"""
type TCFVendor {
  """The ID of the vendor as used by TCF (in postgres, its the tcfId field)"""
  id: String!

  """The Postgres ID of the vendor"""
  pgId: ID!

  """
  The name of the vendor, e.g. "Salesforce.com, Inc."
  """
  name: String!

  """Purposes declared as performed on the legal basis of consent"""
  purposes: [TCFPurpose!]

  """
  Purposes declared as performed on the legal basis of legitimate interest
  """
  legIntPurposes: [TCFPurpose!]

  """Purposes where the vendor is flexible regarding the legal basis"""
  flexiblePurposes: [TCFPurpose!]

  """
  Special Purposes declared as performed on the legal basis of a legitimate interest
  """
  specialPurposes: [TCFPurpose!]

  """
  Features the Vendor may utilize when performing some declared Purposes processing
  """
  features: [TCFPurpose!]

  """
  Special Features the Vendor may utilize when performing some declared Purposes processing
  """
  specialFeatures: [TCFPurpose!]

  """The longest potential duration for storage on a device"""
  cookieMaxAgeSeconds: Int

  """Whether the vendor uses cookie storage"""
  usesCookies: Boolean!

  """
  True indicates the vendor may refresh cookie(s). False indicates the vendor does not refresh any time the browser reloads
  """
  cookieRefresh: Boolean

  """
  Indicates the vendor's use of non-cookie storage and access to information already stored on a user's device.
  """
  usesNonCookieAccess: Boolean

  """URL to Vendor Device Storage & Operational Disclosures"""
  deviceStorageDisclosureUrl: String

  """
  Categories of data the Vendor may utilize/collect from user (e.g. precise location data)
  """
  dataDeclaration: [TCFDataCategory!]

  """How long they retain users data"""
  dataRetention: TCFVendorDataRetention

  """
  If present, vendor is considered deleted after this date/time and MUST NOT be established to users
  """
  deletedDate: Date

  """
  Vendor URLs for privacy and legitimate interests policies in different languages
  """
  urls: [TCFUrl!]

  """Vendors http GET request length limit"""
  overflow: TCFVendorOverflow
}

"""
Transparency & Consent Framework (TCF) Vendors: How long they retain users data for each declared purpose
"""
type TCFVendorDataRetention {
  """
  Retention period for data collected (days). Calculated when same period across all purposes and special purposes
  """
  stdRetention: Int

  """How long they retain users data for each declared purpose"""
  purposes: [TCFVendorDataRetentionPurpose!]

  """How long they retain users data for each declared special purpose"""
  specialPurposes: [TCFVendorDataRetentionPurpose!]
}

"""
Transparency & Consent Framework (TCF) Vendors: How long they retain users data for each declared purpose
"""
type TCFVendorDataRetentionPurpose {
  """
  Vendor purpose for which the retention period applies. If not present, the stdRetention period applies to all
  """
  purpose: Int

  """Retention period for data collected (days) for each declared purpose"""
  dataRetentionPeriod: Int
}

type TcfVendorDetailsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  Transparency & Consent Framework (TCF) Vendor--matches output for IAB vendors list
  """
  tcfVendor: TCFVendor!
}

"""Input to retrieve a vendor from the TCF Vendor Details endpoint"""
input TCFVendorDetailsInput {
  """ID of the vendor as used by TCF (in postgres, its the tcfId field)"""
  tcfVendorId: String!
}

"""Inputs to filter the TCF Vendor endpoint by"""
input TCFVendorFilterInput {
  """Filters by whether the substring is present in the GVL vendor name"""
  text: String
}

"""
Transparency & Consent Framework (TCF) Vendors http GET request length limit
"""
type TCFVendorOverflow {
  """Vendors http GET request length limit"""
  httpGetLimit: Int
}

"""A small set of fields required for previewing the TCF Vendor"""
type TcfVendorPreview {
  """The UUID, from the database (not contentfulId)"""
  id: ID!

  """The TCF Vendor ID from the IAB"""
  tcfId: Int!

  """
  The name of the vendor, e.g. "Salesforce.com, Inc."
  """
  name: String!

  """Whether the vendor uses cookie storage"""
  usesCookies: Boolean!

  """
  True indicates the vendor may refresh cookie(s). False indicates the vendor does not refresh any time the browser reloads.
  """
  cookieRefresh: Boolean

  """
  Indicates the vendor's use of non-cookie storage and access to information already stored on a user's device.
  """
  usesNonCookieAccess: Boolean

  """URL to Vendor Device Storage & Operational Disclosures"""
  deviceStorageDisclosureUrl: String
}

type TcfVendorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of TCFVendor"""
  nodes: [TCFVendor!]!

  """int"""
  totalCount: Int!
}

"""
An existing team of users.
The team can be assigned scopes and all users in that team will inherit the scopes
"""
type Team {
  """The unique ID of the team"""
  id: ID!

  """The name of the team"""
  name: String!

  """The internal description of the team"""
  description: String!

  """The static type of the team"""
  staticType: StaticTeamType

  """The organization name the team relates to"""
  organizationName: String!

  """
  The SSO titles that should be auto assigned to this team on account creation.
  """
  ssoTitle: String

  """
  The SSO departments that should be auto assigned to this team on account creation.
  """
  ssoDepartment: String

  """
  The SSO groups that should be auto assigned to this team on account creation.
  """
  ssoGroup: String

  """The users that belong to the team"""
  users: [UserPreview!]!

  """The teams that are linked to this team in other Transcend instances"""
  linkedTeams: [TeamPreview!]!

  """
  The parent team that is linked to this team in the parent Transcend instance
  """
  parentTeam: TeamPreview

  """The scopes that the team is assigned directly"""
  scopes: [ScopePreview!]!

  """
  All calculated scopes that the users in the team will get. This includes dependent scopes
  """
  allScopes: [ScopePreview!]!

  """The data silos connected to the API key"""
  dataSilos: [Resource!]!
}

"""Input for determining what teams to filter"""
input TeamFiltersInput {
  """Filter by team ids"""
  ids: [ID!]

  """Filter by text (name of team)"""
  text: String
}

"""
Input for defining a new team. A team is a group of users in the organization.
The team can be assigned scopes and all users in that team will inherit the scopes
"""
input TeamInput {
  """The name of the team"""
  name: String!

  """The internal description of the team"""
  description: String

  """
  The SSO titles that should be auto assigned to this team on account creation.
  """
  ssoTitle: String

  """
  The SSO departments that should be auto assigned to this team on account creation.
  """
  ssoDepartment: String

  """
  The SSO groups that should be auto assigned to this team on account creation.
  """
  ssoGroup: String

  """The scopes that the team should get"""
  scopes: [ScopeName!]

  """The ids of the users that should be in that team"""
  users: [ID!]

  """The emails of the users that should be in that team"""
  userEmails: [String!]

  """The ids of the data silos to assign to"""
  dataSilos: [ID!]

  """
  The id of the team in the parent organization to link to this team for auto-provisioning purposes
  """
  parentTeam: ID
}

"""The order for a Team query"""
input TeamOrder {
  """The field that the Team nodes should be ordered by"""
  field: TeamOrderField!

  """The direction in which to order the Team nodes by the specified field"""
  direction: OrderDirection!
}

"""A preview of a team, used during joins"""
type TeamPreview {
  """The unique ID of the team"""
  id: ID!

  """The name of the team"""
  name: String!

  """The internal description of the team"""
  description: String!

  """The static type of the team"""
  staticType: StaticTeamType

  """The organization name the team relates to"""
  organizationName: String!
}

type TeamsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Team"""
  nodes: [Team!]!

  """int"""
  totalCount: Int!
}

"""
An email template to send and receive communication with the data subject
"""
type Template {
  """The unique id of the template"""
  id: ID!

  """The title of the template for lookup purposes"""
  title: String!

  """The actual template contents."""
  template: Message!

  """The subject message for the email communication"""
  subject: Message!

  """Indicates if the template is in use, and thus cannot be destroyed"""
  isRequired: Boolean!

  """The title of the template for lookup purposes"""
  type: TemplateType!

  """The assessment action the template is used for"""
  assessmentActionType: AssessmentActionType
}

"""Filter the custom message templates"""
input TemplateFiltersInput {
  """Filter for text matches in the title, subject, or message template"""
  text: String

  """Filter for the product this template is used for"""
  product: TemplateProduct

  """Filter for the assessment action the template is used for"""
  assessmentActionType: AssessmentActionType
}

"""Input for creating a new message/email template"""
input TemplateInput {
  """The actual template contents."""
  template: String!

  """The title of the template for lookup purposes"""
  title: String!

  """The subject message for the email communication"""
  subject: String!

  """The title of the template for lookup purposes"""
  type: TemplateType!

  """The product this template is used for"""
  product: TemplateProduct!

  """The assessment action the template is used for"""
  assessmentActionType: AssessmentActionType
}

"""The order for a Template query"""
input TemplateOrder {
  """The field that the Template nodes should be ordered by"""
  field: TemplateOrderField!

  """
  The direction in which to order the Template nodes by the specified field
  """
  direction: OrderDirection!
}

type TemplatesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Template"""
  nodes: [Template!]!

  """int"""
  totalCount: Int!
}

"""Schema for an object of type `TenantParamsInput`"""
type TenantParamsInputSchema {
  """The tenant organization URI"""
  ORGANIZATION_URI: String!

  """Supported data subject authentication methods"""
  DATA_SUBJECT_AUTHENTICATION_METHODS: [SombraDataSubjectAuthMethod!]!

  """Supported employee authentication methods"""
  EMPLOYEE_AUTHENTICATION_METHODS: [SombraEmployeeAuthMethod!]!

  """
  Allows customer employees to generate and download the data subject's CEK
  """
  ALLOW_EMPLOYEE_CEK_ACCESS: Boolean

  """Company's data subject authentication via JWT public key"""
  JWT_AUTHENTICATION_PUBLIC_KEY: [String!]

  """SAML Configuration, for the employees"""
  SAML: SAMLSchema

  """OAuth configuration, for data subject authentication"""
  OAUTH_PARAMETERS: OAuthParametersInputSchema

  """Allows unauthenticated data subjects to update preference store."""
  ALLOW_UNAUTHENTICATED_PREFERENCE_UPDATES: Boolean
}

type TestIntegrationsSombraConnectivityPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type TestSombraEmployeeAuthenticationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type TestSombraGatewayConnectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""A data category that is classified in a set of unstructured text"""
type TextCategory {
  """Value from classification"""
  value: String!

  """Category that was matched"""
  category: String!

  """Snippet of value from text"""
  snippet: String!
}

"""A data category that is classified in a set of unstructured text"""
type TextCategoryMatch {
  """Category that was matched"""
  category: String!

  """Snippet of value from text"""
  snippet: String!
}

"""A data category preview that is classified in a set of text"""
type TextCategoryPreview {
  """Instance of the data category that was matched"""
  value: String!

  """Snippet previewing some of the text round the category"""
  snippet: String!
}

"""Input to update text styles"""
input TextStylesInput {
  """
  Font information for "fontFamilyHeader"
  """
  fontFamilyHeader: FontInput

  """
  Font information for "fontFamilyBody"
  """
  fontFamilyBody: FontInput
}

"""Toggle regional account move settings for an organisation"""
input ToggleAccountMoveSettingsInput {
  """Organisation ID to put this hex on"""
  organizationId: ID!

  """Lock out non-Transcend users"""
  lockoutNonTranscendUsers: Boolean!

  """Set the pendingMigration flag on the organization row"""
  setPendingMigration: Boolean!
}

type ToggleCommunicationReadPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A message that was sent on behalf of a data subject request"""
  communication: Communication!
}

"""Input for toggling a message as read"""
input ToggleCommunicationReadInput {
  """The id of the communication message"""
  id: ID!

  """Indicates if read or not"""
  read: Boolean!
}

type ToggleConsentManagerEnforcementPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Toggle the consent manager enforcement on/off."""
input ToggleConsentManagerEnforcementInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """Whether the consent manager should regulate requests."""
  off: Boolean!
}

type ToggleConsentPrecedencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for toggling the Consent precedence"""
input ToggleConsentPrecedenceInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """Which consent source does consent manager gives precedence to"""
  consentPrecedence: ConsentPrecedenceOption!
}

type ToggleDataPointActionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for toggling the active status of a (set of) datapoints"""
input ToggleDataPointActionsInput {
  """
  The id of the datapoint to update, or none if all non-global datapoints
  """
  id: ID

  """The id of the data silo"""
  dataSiloId: ID!

  """The action to toggle on or off"""
  action: RequestActionObjectResolver!

  """Whether to turn on the datapoint action"""
  active: Boolean!
}

type TogglePurposeActivePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input used to enable/disable a list of purposes via purpose id"""
input TogglePurposeActiveInput {
  """The ids of the purposes"""
  ids: [ID!]!

  """Whether the purpose is active for an organization"""
  isActive: Boolean
}

type ToggleSubjectPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The internal configuration for a data subject"""
  dataSubject: DataSubjectInternal!
}

"""Input for toggling a data subject on or off"""
input ToggleSubjectInput {
  """The unique id of the data subject config to toggle"""
  id: ID!

  """
  Whether to allow for data subjects of this type to submit requests on your privacy center
  """
  active: Boolean!

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type ToggleTelemetryPartitioningPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for toggling the Consent telemetry partitioning strategy"""
input ToggleTelemetryPartitionStrategyInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """How the Consent Manager should partition telemetry data"""
  strategy: TelemetryPartitionStrategy!
}

type ToggleUnknownCookiePolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Toggle the unknown cookie policy for the Consent Manager"""
input ToggleUnknownCookiePolicyInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """What the consent manager should do when it encounters unknown cookies"""
  unknownCookiePolicy: UnknownRequestPolicy!
}

type ToggleUnknownRequestPolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Toggle the Content Security Policy directive for the Consent Manager"""
input ToggleUnknownRequestPolicyInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """What the consent manager should do when it encounters unknown requests"""
  unknownRequestPolicy: UnknownRequestPolicy!
}

type ToggleUseDefaultTcfSettingsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""
Toggle whether or not this Consent Manager bundle should the default settings for TCF
"""
input ToggleUseDefaultTcfSettingsInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """Whether to use the default settings for TCF"""
  useDefaultTcfSettings: Boolean
}

"""
When using a temporary password (AKA a "token"), the is an attempted login with said token
"""
input TokenInput {
  """The token to validate"""
  token: String!
}

"""Secret for signing and verifying JWTs"""
input TokenSecretInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """
  Secret for signing and verifying JWTs. If empty and there is no existing key saved, we can auto-generate.
  """
  secret: String
}

"""Secrets for signing JWTs"""
type TokenSecrets {
  """partition associated with this JWT"""
  partition: String!

  """Secrets for signing and verifying JWTs (current and former)"""
  secrets: [String!]!
}

"""A tracking purpose"""
type TrackingPurpose {
  """The id of the tracking purpose"""
  id: ID!

  """The display name of this tracking purpose"""
  name: String!

  """Tracking purpose description (used in Consent Manager UI) """
  description: String!

  """Whether this purpose is default consented by the user."""
  defaultConsent: DefaultConsentOption!

  """The tracking purpose type associated with the site."""
  trackingType: String!

  """Whether this purpose should be configurable by the user """
  configurable: Boolean!

  """
  Is tracking purpose "essential" - i.e. consent is mandatory / equivalent to "essential" permission
  """
  essential: Boolean!

  """
  Whether this purpose should be shown in the (data-subject facing) Consent Manager UI
  """
  showInConsentManager: Boolean!

  """
  Whether this purpose should be shown in the Consent Management dashboard
  """
  isActive: Boolean!

  """
  The order in which the purpose is displayed compared to other purposes in the list
  """
  displayOrder: Int!

  """Privacy signals that should opt the user out of this tracking purpose"""
  optOutSignals: [UserPrivacySignalEnum!]!

  """When this purpose was soft deleted"""
  deletedAt: Date

  """
  The authentication level require by user to update the purpose in the preference store
  """
  authLevel: PreferenceStoreAuthLevel!

  """
  Whether this purpose should be shown in the communication preferences page of the privacy center
  """
  showInPrivacyCenter: Boolean!

  """
  The title of the tracking purpose that appears in Consent Management and Privacy Center UIs
  """
  title: String

  """The preferences associated with this purpose"""
  preferenceTopics: [PreferenceTopicPreview!]!
}

"""Filter purposes"""
input TrackingPurposeFiltersInput {
  """Filter by IDs"""
  ids: [ID!]

  """Filter by text"""
  text: String

  """Filter by names"""
  names: [String!]

  """Filter by tracking type"""
  trackingTypes: [String!]

  """Filter for purposes cannot be opted out by the end-user"""
  essential: Boolean

  """
  Filter by privacy signals that should opt the user out of this tracking purpose
  """
  optOutSignals: [UserPrivacySignalEnum!]

  """Filter by for purpose that are soft deleted"""
  isDeleted: Boolean

  """Filter for purpose that is enabled or disabled"""
  isActive: Boolean

  """Filter by auth level"""
  authLevels: [PreferenceStoreAuthLevel!]
}

"""Input for creating or updating a tracking purpose"""
input TrackingPurposeInput {
  """Include soft deleted purposes in the response"""
  includeDeleted: Boolean
}

"""Preview of purpose with subset of fields"""
type TrackingPurposePreview {
  """The id of the tracking purpose"""
  id: ID!

  """The display name of this tracking purpose"""
  name: String!

  """The tracking purpose type associated with the site."""
  trackingType: String!

  """
  Whether this purpose should be shown in the Consent Management dashboard
  """
  isActive: Boolean!

  """Tracking purpose description (used in Consent Manager UI) """
  description: String!
}

"""A cookie or data flow from the Consent Manager configuration"""
type TrackingTechnology {
  """The name of the service that the technology is used for"""
  name: String!

  """A description for the service"""
  description: String

  """A logo URL to display alongside the service"""
  logoUrl: String!

  """The list of cookies associated with the service"""
  cookies: [CookieSummary!]!

  """The list of data flows associated with the service"""
  dataFlows: [DataFlowSummary!]!
}

"""Input for filtering privacy center translation messages"""
input TranslatedMessagesFilterInput {
  """Filter by type of message"""
  type: [IntlMessageType!]
}

"""Input for fetching message translations"""
input TranslatedMessagesInput {
  """The locale to grab translations for"""
  locale: String!
}

type UnauthenticatedPreferenceUpdatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Files found during the unstructured data discovery process"""
type UnstructuredDataDiscoveryFile {
  """The unique ID of the scanned object"""
  id: ID!

  """The identifying name/key of the datapoint"""
  name: String!

  """File related metadata in JSON string format"""
  metadataAsJSONString: String

  """The file type if discovered datapoint is file"""
  fileType: String

  """The sampling status of the file"""
  samplingStatus: UnstructuredDataSamplingStatus

  """The recommendations associated with this file"""
  recommendations: [RecommendationPreview!] @deprecated(reason: "Use the categories instead")

  """The categories associated with this file"""
  categories: [DataSubCategoryPreview!]!

  """Error message if the sampling status is error"""
  error: String
}

type UnstructuredDataDiscoveryFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of UnstructuredDataDiscoveryFile"""
  nodes: [UnstructuredDataDiscoveryFile!]!

  """int"""
  totalCount: Int!
}

"""Unstructured Subdatapoint recommendations filter input"""
input UnstructuredDataDiscoveryFilesFilterInput {
  """Name of the datapoint"""
  name: String

  """Data Silo Id"""
  dataSiloId: ID

  """Scanned Object Path ID"""
  scannedObjectPathId: ID

  """Scanned Object ID"""
  scannedObjectId: ID

  """The sampling status of the file"""
  samplingStatus: [UnstructuredDataSamplingStatus!]

  """Type of the scanned object hierarchy item"""
  fileType: [String!]

  """Filter by categories of personal data"""
  dataCategories: [DataCategoryType!]

  """Filter by specific subcategories of personal data"""
  dataSubCategoryIds: [ID!]

  """The status of this recommendation"""
  status: UnstructuredSubDataPointRecommendationStatus
}

"""A data silo configured for unstructured discovery"""
type UnstructuredDiscoveryDataSilo implements DataSiloInterface {
  """The data silos that discovered this particular data silo"""
  discoveredBy: [DiscoveredByDataSiloPreview!]!

  """The link to the data silo on the admin dashboard"""
  link: String!

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeader!]!

  """The subdomain that the integration lives on, if applicable"""
  subdomain: String

  """
  The list of individual users who are responsible for managing this data silo
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this data silo"""
  teams: [TeamPreview!]!

  """The unique ID of a data silo in the datamap"""
  id: ID!

  """The internal display title"""
  title: String!

  """A brief internal description of the data silo"""
  description: String!

  """The type of data silo"""
  type: String!

  """
  The catalog name responsible for the cosmetics of the integration (name, description, logo, email fields)
  """
  outerType: String

  """The current state of the integration"""
  connectionState: DataSiloConnectionState!

  """The URL to send POST request notifications to"""
  url: String

  """Whether the data silo is live"""
  isLive: Boolean!

  """The date at which this data silo was deleted"""
  deletedAt: Date

  """The date at which this data silo was created"""
  createdAt: Date

  """The date at which this data silo was last enabled"""
  lastEnabledAt: Date

  """The date at which this data silo was last deleted"""
  lastConnectedAt: Date

  """The external ID of the data silo"""
  externalId: String!

  """The configuration for the attached catalog"""
  catalog: Catalog!

  """
  Silo discovery recommendations were filtered by the plugin that discovered it
  """
  pluginId: ID

  """The slug of the data silo for templating"""
  slug: String!

  """All plugins associated with this data silo"""
  plugins: [Plugin!]!

  """Count of files discovered by this plugin"""
  scannedObjectCount: Int!

  """Total volume of data scanned by this plugin in bytes"""
  scannedVolumeSize: String!
}

type UnstructuredDiscoverySilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of UnstructuredDiscoveryDataSilo"""
  nodes: [UnstructuredDiscoveryDataSilo!]!

  """int"""
  totalCount: Int!
}

"""Unstructured Subdatapoint recommendations raw"""
type UnstructuredSubDataPointRecommendation {
  """Recommendation id"""
  id: ID!

  """Name of the subdatapoint recommendations"""
  name: String!

  """Context Snippet"""
  contextSnippet: String

  """
  The set of data categories assigned to the sub-datapoints of this datapoint
  """
  dataSubCategory: DataSubCategoryPreview

  """The confidence score for this recommendation"""
  confidence: Float

  """The method that identified this unstructured subDataPoint entity"""
  classificationMethod: UnstructuredClassificationMethod

  """The status of this recommendation"""
  status: UnstructuredSubDataPointRecommendationStatus

  """Data Silo Id"""
  dataSiloId: ID!

  """Scanned Object Path ID"""
  scannedObjectPathId: ID

  """Scanned Object ID"""
  scannedObjectId: ID

  """Scan Run Id"""
  scanRunId: ScanRunId!

  """The version of the classifier that generated the recommendation"""
  classifierVersion: Int
}

"""The order for a UnstructuredSubDataPointRecommendation query"""
input UnstructuredSubDataPointRecommendationOrder {
  """
  The field that the UnstructuredSubDataPointRecommendation nodes should be ordered by
  """
  field: UnstructuredSubDataPointRecommendationOrderField!

  """
  The direction in which to order the UnstructuredSubDataPointRecommendation nodes by the specified field
  """
  direction: OrderDirection!
}

type UnstructuredSubDataPointRecommendationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of UnstructuredSubDataPointRecommendation"""
  nodes: [UnstructuredSubDataPointRecommendation!]!

  """int"""
  totalCount: Int!
}

"""Unstructured Subdatapoint recommendations filter input"""
input UnstructuredSubDataPointRecommendationsFilterInput {
  """Name of the subdatapoint recommendations"""
  name: String

  """Data Silo Id"""
  dataSiloId: ID

  """Scanned Object Path ID"""
  scannedObjectPathId: ID

  """Scanned Object ID"""
  scannedObjectId: ID

  """Data Sub-Category"""
  dataSubCategoryId: ID

  """The status of this recommendation"""
  status: [UnstructuredSubDataPointRecommendationStatus!]
}

type UnwrapCustomFunctionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

"""Input to unwrap a custom function"""
input UnwrapCustomFunctionInput {
  """Custom Function ID"""
  id: ID!
}

type UnwrapEmailContentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DecryptedEmailContents"""
  communications: [DecryptedEmailContents!]!
}

"""
Input for unwrapping a set of file snippets that resulted in a recommendation
"""
input UnwrapFileSnippetFiltersInput {
  """The list of recommendations to fetch file snippets for"""
  recommendationIds: [ID!]!
}

type UnwrapFileSnippetsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of FileSnippetDecryptionContext"""
  nameDecryptionContexts: [FileSnippetDecryptionContext!]!

  """A list of FileSnippetDecryptionContext"""
  contextSnippetDecryptionContexts: [FileSnippetDecryptionContext!]!
}

type UnwrapProfileIdentifierPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type UnwrapRequestIdentifierPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The items needed to decrypt data on the privacy center"""
  decryptionContext: DecryptionContext!
}

type UnwrapSubDataPointSamplesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SubDataPointSampleDecryptionContext"""
  decryptionContexts: [SubDataPointSampleDecryptionContext!]!
}

"""Input for unwrapping a set of sub datapoints"""
input UnwrapSubDataPointSamplesFiltersInput {
  """The list of sub datapoints to fetch"""
  subDataPointIds: [ID!]!
}

type UpdateActionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An action that the data subject can make on the privacy center"""
  action: ActionInternal!
}

"""Update an action configuration"""
input UpdateActionInput {
  """The unique id of the action to update"""
  id: ID!

  """The display title of the action"""
  title: String

  """The display description of the action"""
  description: String

  """The description to render on the confirmation modal"""
  secondaryDescription: String

  """Whether an email receipt should be sent"""
  sendReceiptEmail: Boolean

  """
  The different ways that regions can be detected at time of request submit
  """
  regionDetectionMethod: RegionDetectionMethod

  """
  The list of regions that should appear in the form on the privacy center for the data subjects region
  """
  regionList: [String!]

  """
  Configuration option to skip running erasures when no data is found in initial access request.
  """
  skipSecondaryIfNoFiles: Boolean

  """
  Configuration option to skip the ability to download files in an ACCESS request.
  """
  skipDownloadableStep: Boolean

  """Allow for choice in postCompile option."""
  allowPostCompileChoice: Boolean

  """
  The status to transition the request into after a successful compilation
  """
  postCompileStatus: PostCompileStatus

  """The id of the success template"""
  successTemplateId: ID

  """The id of the receipt template"""
  receiptTemplateId: ID

  """The id of the not found template"""
  notFoundTemplateId: ID

  """The id of the secondary success template"""
  secondaryTemplateId: ID

  """The number of days to wait before starting to compile requests"""
  waitingPeriod: Int

  """
  The delay time in ms between the request being verified and compilation processing beginning
  """
  delay: Int

  """Whether the action should undergo a review step"""
  requiresReview: Boolean

  """Whether the action should undergo a review step post deletion"""
  requiresSecondaryReview: Boolean

  """The custom icon image url"""
  icon: String

  """The expiry times for an action"""
  expiryTimeRegions: [ActionExpiryTimeInput!]

  """The number of days the request files are downloadable."""
  downloadAvailabilityDuration: Int

  """The confirmation messages for an action"""
  confirmations: [ActionConfirmationInput!]

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type UpdateActionItemCollectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input needed to create or update action item collections"""
input UpdateActionItemCollectionInput {
  """The title of the action item collection"""
  title: String

  """The description of the action item collection"""
  description: String

  """The hidden state of the action item collection"""
  hidden: Boolean

  """The product line that the action item collection relates to"""
  productLine: TranscendProduct

  """The list of locations where the action item collection is visible"""
  id: ID!
}

type UpdateActionItemsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for bulk updating action item attributes"""
input UpdateActionItemsAttributesInput {
  """The id of the attribute key to update"""
  attributeKeyId: ID!

  """The ids of the attribute values to update"""
  attributeValueIds: [ID!]

  """The names of the attribute values to update"""
  attributeValueNames: [String!]
}

"""Input for bulk updating one or more action items"""
input UpdateActionItemsInput {
  """The ids of the action items to update"""
  ids: [ID!]

  """The filterable field values for the rollups to update"""
  rollupFilters: [UpdateActionItemsRollupInput!]

  """The current filters used in the query"""
  queryFilters: GlobalActionItemFiltersInput

  """The priority override for this action item"""
  priorityOverride: ActionItemPriorityOverride

  """Is this action item resolved?"""
  resolved: Boolean

  """The ids of the teams assigned to this action item"""
  assigneesTeamIds: [ID!]

  """The names of the teams that should be responsible for this action item"""
  assigneesTeamNames: [String!]

  """The unique ids of the users to assign to this action item"""
  assigneesUserIds: [ID!]

  """
  The emails of the users to assign to this action item. These emails must have matching users on Transcend.
  """
  assigneesUserEmails: [String!]

  """The attributes to update"""
  attributes: [UpdateActionItemsAttributesInput!]

  """The date this action item is due"""
  dueDate: Date

  """The title of the action item"""
  title: String

  """The user specified notes about the action item"""
  notes: String

  """The user specified link for the action item"""
  link: String

  """
  The id of the customer experience action item, used for syncing of onboarding checklists
  """
  customerExperienceActionItemId: String
}

"""Input for bulk updating action item rollups"""
input UpdateActionItemsRollupInput {
  """The ids of the teams assigned to this action item"""
  assigneesTeamIds: [ID!]

  """The type of this action item"""
  type: ActionItemCode!

  """The unique ids of the users to assign to this action item"""
  assigneesUserIds: [ID!]

  """Is the action item marked as resolved"""
  resolved: Boolean
}

"""Input for updating an agent file"""
input UpdateAgentFileInput {
  """The id of the agent file"""
  id: ID!

  """The new name of the agent file"""
  name: String

  """
  The name of the initial file, when this file is a chunk of another file
  """
  initialFileName: String

  """The new description of the agent file"""
  description: String

  """Date that the file was uploaded to the remote system"""
  fileUploadedAt: Date

  """ID of the file in remote system"""
  fileId: String

  """Size of the file in bytes"""
  size: Int

  """Purpose of the file"""
  purpose: PromptFilePurpose

  """The ids of the agents that have access to the file"""
  agentIds: [ID!]

  """The names of the agents that have access to the file"""
  agentNames: [String!]

  """The remote ids of the agents that have access to the file"""
  agentRemoteIds: [String!]
}

type UpdateAgentFilesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AgentFile"""
  agentFiles: [AgentFile!]!
}

"""Input for bulk updating one or more agentFiles"""
input UpdateAgentFilesInput {
  """
  List of agent files with the properties that should be updated for each
  """
  agentFiles: [UpdateAgentFileInput!]!
}

"""Input for updating an agent function"""
input UpdateAgentFunctionInput {
  """The id of the agent function"""
  id: ID!

  """The new name of the agent function"""
  name: String

  """The new description of the agent function"""
  description: String

  """The JSON schema definition of the function parameters"""
  parameters: String

  """The ids of the agents that have access to the function"""
  agentIds: [ID!]

  """The names of the agents that have access to the function"""
  agentNames: [String!]

  """The remote ids of the agents that have access to the function"""
  agentRemoteIds: [String!]
}

type UpdateAgentFunctionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AgentFunction"""
  agentFunctions: [AgentFunction!]!
}

"""Input for bulk updating one or more agentFunctions"""
input UpdateAgentFunctionsInput {
  """
  List of agent functions with the properties that should be updated for each
  """
  agentFunctions: [UpdateAgentFunctionInput!]!
}

"""Input for updating an agent"""
input UpdateAgentInput {
  """The id of the agent. Either this or agentId must be provided"""
  id: ID

  """
  The ID of the agent in the remote system. Either this or id must be provided
  """
  agentId: String

  """The new name of the agent"""
  name: String

  """The new description of the agent"""
  description: String

  """The instructions of the agent"""
  instructions: String

  """Whether agent has code interpreter enabled"""
  codeInterpreterEnabled: Boolean

  """The ID of the prompt to use for this agent"""
  promptId: ID

  """
  The title of the prompt to use for this agent. This or promptId must be specified.
  """
  promptTitle: String

  """The ID of the large language model to use for this agent"""
  largeLanguageModelId: ID

  """The name of the large language model that the agent is based on"""
  largeLanguageModelName: String

  """The client of the large language model that the agent is based on"""
  largeLanguageModelClient: LargeLanguageModelClient

  """Whether agent has code retrieval enabled"""
  retrievalEnabled: Boolean

  """The unique ids of the users to assign as owners of this agent"""
  ownerIds: [ID!]

  """The emails of user that manage the agent"""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this agent"""
  teamIds: [ID!]

  """The names of the teams that maintain the agent"""
  teamNames: [String!]

  """The unique ids of the files to assign to this agent"""
  agentFileIds: [ID!]

  """The IDs of the files to assign to this agent"""
  fileIds: [String!]

  """The unique ids of the functions to assign to this agent"""
  agentFunctionIds: [ID!]

  """The agent function definitions for the agent"""
  agentFunctions: [AgentFunctionInput!]

  """The id of the application calling the LLM"""
  applicationId: ID

  """The name of the application calling the LLM"""
  applicationName: String

  """The id of the code package being reported on"""
  codePackageId: ID

  """The name of the code package being reported on"""
  codePackageName: String

  """The id of the repository being reported on"""
  repositoryId: ID

  """The name of the repository being reported on"""
  repositoryName: String

  """The core identifier of the application user interacting with the model"""
  applicationUserCoreIdentifier: String

  """Name of the application user being reported on"""
  applicationUserName: String

  """The name of the pathfinder calling the LLM"""
  pathfinderName: String

  """The id of the pathfinder calling the LLM"""
  pathfinderId: ID
}

type UpdateAgentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Agent"""
  agents: [Agent!]!
}

"""Input for bulk updating one or more agents"""
input UpdateAgentsInput {
  """List of agents with the properties that should be updated for each"""
  agents: [UpdateAgentInput!]!
}

"""Input for updating the prefix and suffix scripts for an airgap bundle"""
input UpdateAirgapPrefixSuffixScriptInput {
  """The ID of the airgap bundle"""
  id: ID!

  """The prefix script to use"""
  prefixScript: String

  """The suffix script to use"""
  suffixScript: String
}

type UpdateApiKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An API key that can be used to programmatically access a Transcend account
  """
  apiKey: ApiKey!
}

"""Input for updating an API key"""
input UpdateApiKeyInput {
  """The id of the API key to update"""
  id: ID!

  """The title of the API key"""
  title: String

  """The new scopes that the API key should have"""
  scopes: [ScopeName!]

  """The ids of the data silos to assign to"""
  dataSilos: [ID!]
}

"""Input for updating a application"""
input UpdateApplicationInput {
  """The id of the application"""
  id: ID!

  """The new name of the application"""
  name: String

  """The description of the application"""
  description: String

  """The IDs of owners that maintain the application"""
  teamIds: [ID!]

  """The names of team that maintain the application"""
  teamNames: [String!]

  """The IDs of owners that maintain the application"""
  ownerIds: [ID!]

  """The emails of owners that maintain the application"""
  ownerEmails: [String!]

  """The IDs of pathfinder instances that the application has access to"""
  pathfinderIds: [ID!]

  """
  The names of the pathfinder instances that the application has access to
  """
  pathfinderNames: [String!]

  """The IDs of prompts that the application is calling"""
  promptIds: [ID!]

  """The titles of prompts that the application is calling"""
  promptTitles: [String!]

  """The IDs of agents that the application has been seen interacting with"""
  agentIds: [ID!]

  """
  The names of agents that the application has been seen interacting with
  """
  agentNames: [String!]

  """
  The remote IDs of agents that the application has been seen interacting with
  """
  agentRemoteIds: [String!]
}

type UpdateApplicationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Application"""
  applications: [Application!]!
}

"""Input for bulk updating one or more applications"""
input UpdateApplicationsInput {
  """
  List of applications with the properties that should be updated for each
  """
  applications: [UpdateApplicationInput!]!
}

"""Input for updating an application user"""
input UpdateApplicationUserInput {
  """
  The id of the application user (necessary when updating coreIdentifier)
  """
  id: ID

  """The new name of the application user"""
  name: String

  """The core identifier of the application user"""
  coreIdentifier: String
}

type UpdateAssessmentEmailSetPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An assessment email set"""
  assessmentEmailSet: AssessmentEmailSet!
}

"""Input for updating an assessment email set"""
input UpdateAssessmentEmailSetInput {
  """The id of the assessment email set"""
  id: ID!

  """The title of the assessment email set"""
  title: String

  """The description of the assessment email set"""
  description: String

  """The ids of the templates to associate with the email set"""
  templateIds: [ID!]
}

type UpdateAssessmentFormPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment form that can be filled out by users"""
  assessmentForm: AssessmentFormRaw!
}

"""Input for updating assessment form comments"""
input UpdateAssessmentFormCommentInput {
  """The id of the assessment form comment"""
  id: ID!

  """The content of the assessment form comment"""
  content: String!
}

type UpdateAssessmentFormCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentFormComment"""
  assessmentFormComments: [AssessmentFormComment!]!
}

"""Input for bulk updating assessment form comments"""
input UpdateAssessmentFormCommentsInput {
  """The list of assessment form comments to update"""
  assessmentFormComments: [UpdateAssessmentFormCommentInput!]!
}

"""Input for updating an assessment form"""
input UpdateAssessmentFormInput {
  """The id of the assessment form"""
  id: ID!

  """The internal label of the assessment form"""
  title: String

  """The description of the assessment form"""
  description: String

  """The status of the assessment form"""
  status: AssessmentFormStatus

  """The IDs of the users assigned to fill out this assessmentForm"""
  assigneeIds: [ID!]

  """
  The emails of the external users assigned to review this assessmentForm
  """
  externalAssigneeEmails: [String!]

  """The IDs of the users assigned to review this assessmentForm"""
  reviewerIds: [ID!]

  """Whether the form to archive or unarchive this form"""
  isArchived: Boolean

  """The new due date for filling out the form"""
  dueDate: Date

  """Send email notification on approval/rejection"""
  sendNotification: Boolean

  """Comment to be added when updating the status"""
  comment: String

  """The ids of sections with assignees to notify when requesting changes"""
  sectionIdsToNotify: [ID!]

  """
  Whether the form title is an internal label only, and the group title should be used in communications with assignees
  """
  titleIsInternal: Boolean

  """Whether to enable the triggers copied from the parent template"""
  isTriggerEnabled: Boolean

  """
  The configurations for the form's triggers. If omitted, the triggers are not copied from the parent template!
  """
  triggerConfigurations: [AssessmentFormTriggerInput!]
}

type UpdateAssessmentFormQuestionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A question of an assessment form or template that belongs to a section.
  """
  assessmentQuestion: AssessmentQuestionRaw!
}

"""Input for updating an assessment question that belongs to a form."""
input UpdateAssessmentFormQuestionInput {
  """The ID of the assessment question to update"""
  id: ID!

  """
  The row IDs of the data inventory table that this question syncs back to.
  """
  syncRowIds: [String!]

  """
  Whether this question should override existing values in the data inventory
  """
  syncOverride: Boolean

  """The IDs of the risk categories the risk score applies to"""
  riskCategoryIds: [ID!]

  """The ID of the risk framework the risk score applies to"""
  riskFrameworkId: ID

  """Whether the question requires a risk score"""
  requireRiskEvaluation: Boolean

  """
  ID of the risk level to manually assign to this question. Must match the risk framework of the risk categories.
  """
  reviewerRiskLevelId: ID

  """Whether to completely wipe out any risk association with the question"""
  excludeRisk: Boolean
}

"""Input for updating an assessment form section"""
input UpdateAssessmentFormSectionInput {
  """The id of the assessment section to update"""
  id: ID!

  """The IDs of the users assigned to fill out this assessmentSection"""
  assigneeIds: [ID!]

  """
  The emails of the external users assigned to provide answers for this assessmentSection
  """
  externalAssigneeEmails: [String!]

  """Whether the section has been reviewed"""
  isReviewed: Boolean

  """The status of the assessment"""
  status: AssessmentFormStatus
}

type UpdateAssessmentFormSectionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentSectionRaw"""
  assessmentSections: [AssessmentSectionRaw!]!
}

"""Input for bulk updating assessment form sections"""
input updateAssessmentFormSectionsInput {
  """The id of the assessment form containing the sections"""
  assessmentFormId: ID!

  """Comment to be added to the parent form when updating the sections."""
  comment: String

  """The list of assessment form section to update"""
  assessmentSections: [UpdateAssessmentFormSectionInput!]!
}

type UpdateAssessmentFormTemplatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A template for creating assessment forms with questions and answers."""
  assessmentFormTemplate: AssessmentFormTemplateRaw!
}

"""Input for updating an assessment form template"""
input UpdateAssessmentFormTemplateInput {
  """The id of the assessment form template"""
  id: ID!

  """The title of the Assessment Form Template"""
  title: String

  """The description of the Assessment Form Template"""
  description: String

  """The status of the Assessment Form Template"""
  status: AssessmentFormTemplateStatus

  """The retention schedule for the Assessment Form Template"""
  retentionSchedule: UpdateAssessmentFormTemplateRetentionScheduleInput

  """The sections belonging to this template"""
  sections: [AssessmentSectionInput!]

  """Whether to archive or unarchive this template"""
  isArchived: Boolean

  """Whether to lock or unlock this template"""
  isLocked: Boolean

  """The email template set used for notifications"""
  assessmentEmailSetId: ID

  """The trigger configurations of the template"""
  triggers: [AssessmentTriggerInput!]
}

"""
Input for updating the retention schedule for an assessment form template
"""
input UpdateAssessmentFormTemplateRetentionScheduleInput {
  """The duration of the retention schedule in days"""
  durationDays: Int

  """The operation to perform on the retention schedule"""
  operation: RetentionScheduleOperation

  """
  Whether to also update the retention schedule for all assessment forms created from this template
  """
  updateAssessmentForms: Boolean!
}

type UpdateAssessmentGroupPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Group of assessment forms"""
  assessmentGroup: AssessmentGroup!
}

"""Input for updating an assessment group"""
input UpdateAssessmentGroupInput {
  """The id of the assessment group"""
  id: ID!

  """The title of the assessment group"""
  title: String

  """The description of the assessment group"""
  description: String

  """Whether to enable the form triggers by default"""
  isTriggerEnabled: Boolean

  """Whether the group to archive or unarchive this group"""
  isArchived: Boolean

  """The new due date for filling out the forms within this group"""
  dueDate: Date

  """
  Whether to create a new token that grants external access for creating forms under this group
  """
  createToken: Boolean

  """
  Whether to delete the tokens that grants external access for creating forms under this group
  """
  deleteAllTokens: Boolean

  """
  The IDs of the users who will be assigned to review new forms in this group
  """
  reviewerIds: [ID!]

  """The email domains accepted for external assignees"""
  externalEmailDomains: [String!]

  """
  The maximum number of forms that can be created by external users in this group
  """
  externalFormLimit: Int

  """
  Whether to allow external users assigned via a link to modify the form's label
  """
  allowExternalLabelEdit: Boolean
}

"""Input for bulk updating assessment question comments"""
input UpdateAssessmentQuestionCommentInput {
  """The id of the assessment question comment"""
  id: ID!

  """The content of the assessment question"""
  content: String!
}

type UpdateAssessmentQuestionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentQuestionComment"""
  assessmentQuestionComments: [AssessmentQuestionComment!]!
}

"""Input for bulk updating assessment section comments"""
input UpdateAssessmentSectionCommentInput {
  """The id of the assessment section comment"""
  id: ID!

  """The content of the assessment section"""
  content: String!
}

type UpdateAssessmentSectionCommentsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AssessmentSectionComment"""
  assessmentSectionComments: [AssessmentSectionComment!]!
}

type UpdateAssessmentTemplateQuestionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A question of an assessment form or template that belongs to a section.
  """
  assessmentQuestion: AssessmentQuestionRaw!
}

"""
Input for updating an assessment question in an assessment form template
"""
input UpdateAssessmentTemplateQuestionInput {
  """The ID of the assessment question to update"""
  id: ID!

  """The index of the assessment question"""
  index: Int

  """The title of the assessment question"""
  title: String

  """The type of the assessment question"""
  type: AssessmentQuestionType

  """The sub-type of the assessment question"""
  subType: AssessmentQuestionSubType

  """The possible answer options to this question"""
  answerOptions: [AssessmentAnswerOptionInput!]

  """The placeholder of the assessment question"""
  placeholder: String

  """The description of the assessment question"""
  description: String

  """Whether the assessment question is required"""
  isRequired: Boolean

  """
  The logic for determining whether this question should show in the assessment form
  """
  displayLogic: DisplayLogicInput

  """The logic for determining the risk score for the assessment question"""
  riskLogic: [RiskLogicInput!]

  """The IDs of the risk categories the risk score applies to"""
  riskCategoryIds: [ID!]

  """The ID of the risk framework the risk score applies to"""
  riskFrameworkId: ID

  """The mime types allowed for the file question"""
  allowedMimeTypes: [String!]

  """Whether the question allows selecting Other"""
  allowSelectOther: Boolean

  """The data inventory model that this assessment question syncs to"""
  syncModel: AssessmentSyncModel

  """
  The column of the data inventory that this assessment question syncs to
  """
  syncColumn: AssessmentSyncColumn

  """The ID of the attributeKey used to respond this question."""
  attributeKeyId: ID

  """
  Used to identify the question within a form or template so it can be referenced in conditional logic.
  """
  referenceId: String
}

type UpdateAssessmentTemplateSectionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Assessment section that belongs to a template or a form"""
  assessmentSection: AssessmentSectionRaw!
}

"""Input for updating an assessment template section"""
input UpdateAssessmentTemplateSectionInput {
  """The id of the assessment section to update"""
  id: ID!

  """The title of the assessment section"""
  title: String

  """The index of the assessment section"""
  index: Int

  """The questions belonging to this group"""
  questions: [AssessmentQuestionInput!]
}

type UpdateAttributeKeyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An attribute key to house attribute values"""
  attributeKey: AttributeKey!
}

"""Input for updating an attribute key"""
input UpdateAttributeKeyInput {
  """The id of the attribute key to update"""
  id: ID!

  """Name of the attributeKey"""
  name: String

  """Description of the attribute key"""
  description: String

  """The views this attribute key is enabled on"""
  enabledOn: [AttributeSupportedResourceType!]

  """The type of this attribute key"""
  type: AttributeKeyType
}

"""Input for updating an attribute Value"""
input UpdateAttributeValueInput {
  """The id of the attribute Value to update"""
  id: ID!

  """Name of the attribute value"""
  name: String!

  """The description for the attribute value"""
  description: String!

  """The attribute key the attribute value belongs to"""
  attributeKeyId: ID!

  """Color used for this attribute value"""
  color: String

  """Whether attribute value can be deleted"""
  canDelete: Boolean
}

type UpdateAttributeValuesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of AttributeValue"""
  attributeValues: [AttributeValue!]!
}

type UpdateAuditorSchedulePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A schedule for running the Web Auditor repeatedly over time on the same URL
  """
  schedule: AuditorSchedule!
}

"""Input for deleting a group of Web Auditor schedules"""
input UpdateAuditorScheduleInput {
  """The id of the assessments to delete"""
  id: ID!

  """Whether or not to use GPC for the scheduled runs"""
  useGPC: Boolean

  """What region to run the audit in"""
  region: AuditorGQLRegionEnum
}

type UpdateBusinessEntitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of BusinessEntity"""
  businessEntities: [BusinessEntity!]!
}

"""Input for bulk updating one or more business entities"""
input UpdateBusinessEntitiesInput {
  """List of data silos with the properties that should be updated for each"""
  businessEntities: [UpdateBusinessEntityInput!]!
}

"""Input for updating a business entity"""
input UpdateBusinessEntityInput {
  """The business entity ID to update"""
  id: ID!

  """The title of the business entity"""
  title: String

  """The description of the business entity"""
  description: String

  """Address of entity"""
  address: String

  """The name of the DPO"""
  dataProtectionOfficerName: String

  """The email address of the DPO"""
  dataProtectionOfficerEmail: String

  """The country code of the headquarters location of the entity"""
  headquarterCountry: IsoCountryCode

  """ISO country where business entity headquarters is located"""
  headquarterSubDivision: String

  """The attribute values used to label this business entity"""
  attributes: [AttributeInput!]

  """
  The ids of the teams that should be responsible for this business entity
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this business entity
  """
  teamNames: [String!]

  """
  The unique ids of the users to assign as owners of this business entity
  """
  ownerIds: [ID!]

  """
  The email addresses of the users to assign as owners of this business entity
  """
  ownerEmails: [String!]
}

"""Input for updating the client side sampling rate"""
input UpdateClientSideSamplingRateInput {
  """The ID of the airgap bundle to update"""
  id: ID!

  """The new client side sampling rate"""
  clientSideSamplingRate: String!
}

"""Input for updating a code package"""
input UpdateCodePackageInput {
  """The id of the code package"""
  id: ID!

  """The name of the code package"""
  name: String

  """The description of the code package"""
  description: String

  """The type of code package"""
  type: CodePackageType

  """Relative path to where the code package lives within the repository"""
  relativePath: String

  """The IDs of owners that maintain the code package"""
  ownerIds: [ID!]

  """The emails of owners that maintain the code package"""
  ownerEmails: [String!]

  """The IDs of owners that maintain the code package"""
  teamIds: [ID!]

  """The names of team that maintain the code package"""
  teamNames: [String!]

  """
  The ids of the software development kits that the code packages are related to
  """
  softwareDevelopmentKitIds: [ID!]
}

type UpdateCodePackagesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of CodePackage"""
  codePackages: [CodePackage!]!
}

"""Input for bulk updating one or more code packages"""
input UpdateCodePackagesInput {
  """
  List of code packages with the properties that should be updated for each
  """
  codePackages: [UpdateCodePackageInput!]!
}

type UpdateConsentManagerPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

type UpdateConsentManagerDomainsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating the consent manager"""
input UpdateConsentManagerInput {
  """
  The custom domain from which to load airgap modules, only compatible with Cloudflare CDN or customer-hosted CDN.
  """
  customDomain: String

  """The version of airgap.js to use"""
  version: String

  """
  Whether or not the custom sync endpoints are hosted by Transcend or on the customer's own CDN. Defaults to true.
  """
  isTranscendHosted: Boolean

  """Whether to use experience-specific modules"""
  useModules: Boolean

  """Whether to use IAB Consent Frameworks"""
  useIabFramework: Boolean

  """
  The URL to send POST request notifications to whenever a deployment occurs
  """
  webhookUrl: String

  """Custom headers to include in outbound deployment webhook"""
  headers: [CustomHeaderInput!]
}

type UpdateConsentManagerOnboardingStatusPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating a consent manager status"""
input UpdateConsentManagerOnboardingStatusInput {
  """The ID of the Consent Manager bundle to update."""
  id: ID!

  """The onboarding status of this consent manager"""
  onboardingStatus: ConsentManagerOnboardingStatus!
}

type UpdateConsentManagerPartitionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating consent partition key"""
input UpdateConsentManagerPartitionInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """The ID of the partition to use for this bundle"""
  partitionId: ID
}

type UpdateConsentManagerThemePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The UI theme configuration associated with a consent manager bundle"""
  theme: ConsentManagerTheme!
}

"""The input for updating an existing Consent Manager's theme"""
input UpdateConsentManagerThemeInput {
  """The ID of the associated Consent Manager bundle."""
  airgapBundleId: ID!

  """The button color"""
  primaryColor: String

  """The type (text) color"""
  fontColor: String

  """The privacy policy link"""
  privacyPolicy: String

  """
  The number of page views at which to prompt the default consent banner. To turn off auto-prompt, set this to 0.
  """
  prompt: Int

  """The custom styles to update"""
  styles: [ConsentManagerStyleItemInput!]
}

type UpdateConsentManagerToLatestVersionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating consent preferences"""
input UpdateConsentPreferenceInput {
  """The consent preferences to update"""
  consentPreferences: [ConsentPreferenceUpdateInput!]!

  """The unique name of the organization's data subject class"""
  subjectType: String

  """The locale to translate the request it"""
  locale: String

  """The region that the request was submitted in"""
  region: RegionInput
}

"""Response when updating consent preferences"""
type UpdateConsentPreferenceOutput {
  """Record of consent preferences"""
  data: [ConsentRecord!]!

  """
  The decryption context containing a mapping of encrypted consent identifiers to their plaintext values
  """
  decryptionContext: DecryptionContext!
}

"""Input for updating a contract"""
input UpdateContractInput {
  """The id of the contract"""
  id: ID!

  """The new name of the contract"""
  name: String

  """The new description of the contract"""
  description: String

  """The content of the contract"""
  content: String
}

type UpdateContractsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Contract"""
  contracts: [Contract!]!
}

"""Input for updating a contract scan"""
input UpdateContractScanInput {
  """The id of the contract scan"""
  id: ID!

  """The new name of the contract scan"""
  name: String
}

type UpdateContractScansPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ContractScan"""
  contractScans: [ContractScan!]!
}

"""Input for bulk updating one or more contract scans"""
input UpdateContractScansInput {
  """
  List of contract scans with the properties that should be updated for each
  """
  contractScans: [UpdateContractScanInput!]!
}

"""Input for bulk updating one or more contracts"""
input UpdateContractsInput {
  """List of contracts with the properties that should be updated for each"""
  contracts: [UpdateContractInput!]!
}

"""Input for updating the current user's attributes"""
input UpdateCurrentUserInput {
  """The name of the user"""
  name: String
}

type UpdateCustomFunctionPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Custom Function"""
  customFunction: CustomFunction!

  """boolean"""
  success: Boolean!
}

"""Update or create a custom function"""
input UpdateCustomFunctionInput {
  """Custom Function ID"""
  id: ID

  """Data Silo ID"""
  dataSiloId: ID!
}

"""Input for updating a data flow"""
input UpdateDataFlowInput {
  """The id of the data flow"""
  id: ID!

  """The value for the data flow"""
  value: String

  """The type of this data flow"""
  type: DataFlowScope

  """The tracking types that apply to this data flow"""
  trackingType: [String!]

  """The purposes that apply to this data flow"""
  purposeIds: [ID!]

  """The description for this data flow"""
  description: String

  """The unique ids of the users to assign as owners of this data flow"""
  ownerIds: [ID!]

  """The ids of the teams that should be responsible for this data flow"""
  teamIds: [ID!]

  """
  The name of the SaaS tool associated with this data flow, if undefined will clear value
  """
  service: String

  """Whether Airgap should ignore this data flow"""
  isJunk: Boolean

  """The status of this data flow"""
  status: ConsentTrackerStatus

  """
  Only relevant for LIVE data flows - Whether or not to drop matching data flows in triage if it is covered by the data flow being updated. Defaults to false.
  """
  dropMatchingDataFlowsInTriage: Boolean

  """The attribute values used to label this data flow"""
  attributes: [AttributeInput!]
}

type UpdateDataFlowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataFlow"""
  dataFlows: [DataFlow!]!
}

"""Input for bulk updating one or more data flows"""
input UpdateDataFlowsInput {
  """The airgap bundle to update the data flows for"""
  airgapBundleId: ID!

  """List of data flows with the properties that should be updated for each"""
  dataFlows: [UpdateDataFlowInput!]!

  """Invoke service classifier if integration unknown"""
  classifyService: Boolean
}

type UpdateDataPointLevelPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A sub-categorization of data with a data silo, from internal perspective
  """
  dataPointHierarchy: DataPointHierarchyItem!
}

"""Input for updating a dataPointLevel"""
input UpdateDataPointLevelInput {
  """The unique ID of datapoint level to update"""
  id: ID!

  """
  The unique ids of the users to assign as owners of this datapoint level
  """
  ownerIds: [ID!]

  """
  The unique ids of the teams to assign as owners of this datapoint level
  """
  teamIds: [ID!]

  """The description of the datapoint"""
  description: String
}

"""Input for updating a data report"""
input UpdateDataReportInput {
  """The id of the data report to update"""
  id: ID!

  """The title of the data report"""
  title: String

  """The names of the tables included in this data report"""
  tables: [DataReportExportableTables!]

  """The filters the user applied to each table in the report"""
  filters: DataReportFilterInput

  """The columns that the user hid from each table in the report"""
  hiddenColumns: DataReportHiddenColumnsInput
}

type UpdateDataReportsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataReportRaw"""
  dataReports: [DataReportRaw!]!
}

"""Input for bulk updating one or more data reports"""
input UpdateDataReportsInput {
  """
  List of data reports with the properties that should be updated for each
  """
  dataReports: [UpdateDataReportInput!]!
}

type UpdateDataRetentionSchedulePolicyPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Configurable retention policy to manage an organizations data"""
  retentionSchedule: RetentionSchedule!
}

"""Input for update a data silo as an admin"""
input UpdateDataSiloAsAdminInput {
  """The id of the data silo to update"""
  id: ID!

  """Filter by the connection state"""
  connectionState: DataSiloConnectionState
}

"""Input for updating a data silo's attributes"""
input UpdateDataSiloInput {
  """The id of the data silo to update"""
  id: ID!

  """The title of the data silo"""
  title: String

  """The description of the data silo"""
  description: String

  """The email address to notify when a prompt a person silo"""
  notifyEmailAddress: String

  """The URL of the webhook to notify on manual action"""
  notifyWebhookUrl: String

  """
  Indicates whether prompt-a-vendor emails should include a list of identifiers in addition to a link to the bulk processing UI.
  """
  promptAVendorEmailIncludeIdentifiersAttachment: Boolean

  """The id of template to use when prompting via email"""
  promptEmailTemplateId: ID

  """
  The updated type of emails to send for this data silo, i.e. send an email for each DSR, across all open DSRs, or per profile in a DSR.
  """
  promptAVendorEmailSendType: PromptAVendorEmailSendType

  """
  Indicates what kind of link to generate as part of the emails sent out for this PaV silo.
  """
  promptAVendorEmailCompletionLinkType: PromptAVendorEmailCompletionLinkType

  """
  The updated frequency with which we should be sending emails for this data silo, in milliseconds.
  """
  promptAVendorEmailSendFrequency: Int

  """
  The updated frequency with which we should retry sending emails for this data silo, in milliseconds. Needs to be a string because the number can be larger than the MAX_INT
  """
  manualWorkRetryFrequency: String

  """
  The updated time this data silo's prompt-a-vendor email should start being sent
  """
  promptAVendorEmailStartAt: Date

  """
  The updated start time when we should start retrying emails for this data silo, in ISO format.
  """
  manualWorkRetryStartAt: Date

  """The names of the identifiers that the data silo should be connected to"""
  identifiers: [String!]

  """the list of subject IDs to block list from this data silo"""
  dataSubjectBlockListIds: [ID!]

  """The URL of the server to post to if a server silo"""
  url: String

  """The default policy for visibility setting when creating subdatapoints"""
  defaultAccessRequestVisibility: Boolean

  """Whether the data silo should be live"""
  isLive: Boolean

  """The custom server headers"""
  headers: [CustomHeaderInput!]

  """
  User-defined key-value pairs that can be used to track additional metadata about your silo
  """
  attributes: [AttributeInput!]

  """
  The IDs of the data silo that this data silo depends on during a deletion request.
  """
  dependedOnDataSiloIds: [ID!]

  """
  The titles of the data silo that this data silo depends on during a deletion request.
  """
  dependedOnDataSiloTitles: [String!]

  """The unique ids of the users to assign as owners of this data silo"""
  ownerIds: [ID!]

  """The id of the existing api key to attach to"""
  apiKeyId: ID

  """The emails of the users to assign as owners of this data silo."""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this data silo"""
  teams: [ID!]

  """The vendor that the data silo is assigned to"""
  vendorId: ID

  """The names of the teams that should be responsible for this data silo"""
  teamNames: [String!]

  """The ids of the data silos that receive data from this data silo"""
  receiverDataSiloIds: [ID!]

  """The form input plaintext"""
  plaintextContext: [PlaintextContextInput!]

  """The organization's controllership of the data silo"""
  controllerships: [Controllership!]

  """Freeform notes about the data silo"""
  notes: String

  """A freeform note talking about data retention policy at high level"""
  dataRetentionNote: String

  """A link to the DPA for this data silo or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this data silo (often a third party contact)"""
  contactEmail: String

  """A link to the website of the data silo, if applicable."""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """Whether the integration is recommended for consent manager purposes"""
  recommendedForConsent: ConsentManagerConnectionStatus

  """Whether the integration is recommended for privacy request purposes"""
  recommendedForPrivacy: PrivacyRequestConnectionStatus

  """Whether the data silo has personal data in it"""
  hasPersonalData: HasPersonalDataStatus

  """Whether the data silo has been deprecated"""
  deprecationState: DataSiloDeprecationState

  """ISO country where data silo has data in"""
  country: IsoCountryCode

  """ISO country where data silo has data in"""
  countrySubDivision: String

  """
  Countries and country subdivisions to which this data silo transfers data
  """
  transferRegions: [RegionInput!]

  """The ID of the sombra to use for communication with this data silo"""
  sombraId: ID

  """The IDs of the data subcategories for this data silo"""
  dataSubCategoryIds: [ID!]

  """The IDs of the processing purpose subcategories for this data silo"""
  processingPurposeSubCategoryIds: [ID!]

  """The IDs of SaaS categories to assign to this data silo"""
  saaSCategoryIds: [ID!]

  """Update the associated business entities for the data silo"""
  businessEntityIds: [ID!]

  """Update the associated business entity titles for the data silo"""
  businessEntityTitles: [String!]

  """
  The workflow connection strategy for this data silo (e.g., webhook, custom function, ...)
  """
  customSiloConnectionStrategy: CustomSiloConnectionStrategy

  """Update the associated processing activities for the data silo"""
  processingActivityIds: [ID!]
}

type UpdateDataSiloPluginPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A plugin belonging to a data silo"""
  plugin: Plugin!
}

type UpdateDataSiloRateLimitsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Update data silo rate limits input"""
input UpdateDataSiloRateLimitsInput {
  """The data silo id"""
  id: ID!

  """Rate limit configurations"""
  rateLimitConfigs: [RateLimitConfigInput!]!
}

type UpdateDataSilosPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSilo"""
  dataSilos: [DataSilo!]!
}

"""Input for bulk updating one or more data silos"""
input UpdateDataSilosInput {
  """List of data silos with the properties that should be updated for each"""
  dataSilos: [UpdateDataSiloInput!]!
}

type UpdateDataSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of DataSubCategory"""
  dataSubCategories: [DataSubCategory!]!
}

"""Input for bulk updating one or more data subcategories"""
input UpdateDataSubCategoriesInput {
  """
  List of data subcategories with the properties that should be updated for each
  """
  dataSubCategories: [UpdateDataSubCategoryInput!]!
}

"""Input for creating a new data subcategory"""
input UpdateDataSubCategoryInput {
  """The ID of the data subcategory to update"""
  id: ID!

  """The text to use as the new description of the data subcategory"""
  description: String

  """The regex used to identify this data subcategory"""
  regex: String

  """
  The unique ids of the users to assign as owners of this data sub category
  """
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this data sub category"""
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this data sub category
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this data sub category
  """
  teamNames: [String!]

  """The attribute values used to label this data sub category"""
  attributes: [AttributeInput!]

  """The identifier that is linked to this data category"""
  identifierId: ID

  """The name of the identifier that is linked to this data category"""
  identifierName: String

  """The sensitive categories that are related to this data category"""
  sensitiveCategoryIds: [ID!]
}

type UpdateDiscoClassScanPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A discovery and classification scan"""
  discoClassScan: DiscoClassScan!
}

type UpdateDiscoClassScanConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A configuration for a disco class scan"""
  discoClassScanConfig: DiscoClassScanConfig!
}

"""Input for updating a disco class scan config"""
input UpdateDiscoClassScanConfigInput {
  """The ID of the disco class scan config to update"""
  id: ID!

  """If the scan is enabled"""
  enabled: Boolean

  """The scan type"""
  type: DiscoClassScanType

  """How frequently the scan should be run in milliseconds"""
  scheduleFrequency: Int

  """When the next scan should start (null if disabled)"""
  scheduleStartAt: Date

  """The configurations for the scan plugins"""
  scanPluginConfigs: [ScanPluginConfigInput!]
}

"""Input for updating a disco class scan"""
input UpdateDiscoClassScanInput {
  """The ID of the disco class scan config to get the latest scan"""
  discoClassScanConfigId: ID!

  """The action to take on the scan"""
  action: DiscoClassScanAction!
}

"""List of domains that the consent manager is allowed to run on"""
input UpdateDomainListInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """List of domains"""
  domains: [String!]!
}

type UpdateEmailSenderAddressPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Email addresses from which Transcend can send emails"""
  address: EmailSenderAddress!
}

"""Input to update email sender addresses"""
input UpdateEmailSenderAddressInput {
  """The address id"""
  id: ID!

  """The internal name of this email address"""
  name: String

  """The priority of this email address"""
  priority: Int

  """The customer domain name"""
  fromPrefix: String

  """The customer domain name"""
  replyTo: String

  """The customer domain name"""
  alias: String

  """The customer domain name"""
  displayName: String

  """The request attribute value ids corresponding to this email address"""
  attributeValues: [ID!]

  """The privacy centers to which this email address is assigned"""
  privacyCenters: [ID!]
}

type UpdateEnricherPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An enricher is takes in an identifier, and resolves additional identifiers keyed to the input identifier.
  """
  enricher: Enricher!
}

"""Input for updating an enricher"""
input UpdateEnricherInput {
  """The id of the enricher configuration"""
  id: ID!

  """The enricher's title"""
  title: String

  """The enricher's description"""
  description: String

  """The id of the user responsible"""
  userId: ID

  """The ID of the related data silo (i.e. looker or twilio integration"""
  dataSiloId: ID

  """The IDs of the explicit data subjects that the enricher should run for"""
  dataSubjectIds: [ID!]

  """The mapping between identifier name and JSON path for identifier"""
  signedIdentifierInputs: [SignedIdentifierPathInput!]

  """The ID of the identifier that will be the input to the enricher"""
  inputIdentifier: ID

  """Custom headers to include in outbound webhook"""
  headers: [CustomHeaderInput!]

  """
  The ids of the identifiers that can possibly be output from the enricher
  """
  identifiers: [ID!]

  """The url that the enricher should post to when a server"""
  url: String

  """A regular expression that can be used to match on for cancelation"""
  testRegex: String

  """The list of regions that should trigger the enrichment condition"""
  regionList: [String!]

  """The duration (in ms) that the enricher should take to execute."""
  expirationDuration: String

  """
  The duration (in ms) to wait between sending verification and first reminder.
  """
  reminderTemplate1Duration: String

  """
  The duration (in ms) to wait between sending first reminder and second reminder.
  """
  reminderTemplate2Duration: String

  """
  The duration (in ms) to wait between sending second reminder and third reminder.
  """
  reminderTemplate3Duration: String

  """The status that the enricher should transfer to when condition is met."""
  transitionRequestStatus: PreflightRequestStatus

  """The ID of template to use for that identifier verification"""
  templateId: ID

  """
  The ID of template to use for notifying data subject about continuing request without an identifier
  """
  continuationTemplateId: ID

  """
  The ID of template to use for notifying data subject about their request being canceled
  """
  requestVerificationFailedTemplateId: ID

  """The action types that the enricher should run for"""
  actions: [RequestAction!]

  """The twilio phone number to send from"""
  phoneNumbers: [String!]

  """Title of the looker query to run for this enricher"""
  lookerQueryTitle: String

  """Slug of the looker query to run for this enricher"""
  lookerQuerySlug: String

  """IDs of the enricher dependency"""
  enricherDependencyIds: [ID!]

  """Map of verification output keys to identifier ids"""
  verificationMap: [EnricherVerificationMapInput!]

  """
  Slug of the database name to run for this enricher. This is only needed for certain database enrichers, such as googleCloudSpanner, that require SQL statements to be scoped to a specific database.
  """
  databaseName: String
}

type UpdateEnrichersInWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating enrichers in a workflow configuration"""
input UpdateEnrichersInWorkflowConfigInput {
  """The workflow config ID"""
  workflowConfigId: ID!

  """list of enrichers to update"""
  enrichers: [UpdateEnricherInWorkflowConfigInput!]!
}

"""Input for updating an enricher in a workflow configuration"""
input UpdateEnricherInWorkflowConfigInput {
  """Enricher id"""
  id: ID!

  """
  Whether the associated enricher is being used to produce additional identifiers
  """
  isIdentifierSource: Boolean

  """Whether the enricher is disabled"""
  isDisabled: Boolean
}

type UpdateExperiencePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A set of transcend configurations for an organization defined set of regions
  """
  experience: Experience!
}

"""Input used to update an existing experience for an organization"""
input UpdateExperienceInput {
  """The id of the experience"""
  id: ID!

  """Name of the experience"""
  name: String

  """Regions to be included/not included in this experience"""
  regions: [RegionInput!]

  """Whether listed regions are excluded or included in experience"""
  operator: RegionsOperator

  """
  If data subject linked to multiple experiences, display priority for experiences. Lower number, higher priority.
  """
  displayPriority: Int

  """The view state to display on transcend.showConsentManager()"""
  viewState: InitialViewState

  """The UI module to use (overrides View State if appropriate)"""
  ui: String

  """The purposes associated with this experience"""
  purposes: [ID!]

  """
  The purposes associated with this experience that are default opted out
  """
  optedOutPurposes: [ID!]

  """A list of browser languages that this experience applies to"""
  browserLanguages: [String!]

  """A list of browser time zones that this experience applies to"""
  browserTimeZones: [String!]

  """Set of iab signals to communicate"""
  iabSignals: [IABSignal!]

  """Number of months after which consent values will expire"""
  consentExpiry: Int

  """Action taken when the user's consent has expired"""
  onConsentExpiry: OnConsentExpiry

  """Whether the regional experience is active for an organization"""
  isActive: Boolean
}

"""Input for updating a feature"""
input UpdateFeatureInput {
  """The id of the feature to update"""
  id: ID!

  """
  Whether to opt the organization into the beta feature. Not applicable to non-beta features
  """
  isBetaEnabled: Boolean
}

type UpdateFeaturesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Feature"""
  features: [Feature!]!
}

"""Input for updating an organization's feature sets"""
input UpdateFeatureSetInput {
  """The ID of the Organization to update the feature sets for"""
  organizationId: ID!

  """The tier to generate the tokens for"""
  tier: OrganizationTier

  """
  If true, an organization can pull from our private docker registry. This is useful for companies not on AWS
  """
  allowPrivateDockerRegistryAccess: Boolean

  """Whether or not the organization is a sandbox-only account"""
  isSandbox: Boolean

  """
  If true, an organization can white label the emails that are sent to the data subject during a privacy request
  """
  whiteLabelPrivacyRequestEmails: Boolean

  """
  If true, an organization can white label the emails that are sent to the data subject during a privacy request
  """
  whiteLabelPrivacyCenter: Boolean

  """
  If true, the "about transcend" page will be disabled on the Privacy Center. The "show me" side menu item will also be disabled
  """
  disabledPrivacyCenterAboutTranscend: Boolean

  """The prompts feature"""
  prompts: FeatureGate

  """The assessments feature"""
  assessments: FeatureGate

  """The privacy center feature"""
  privacyCenter: FeatureGate

  """Access to the selfHostedSombra feature"""
  selfHostedSombra: FeatureGate

  """The level of support that the customer has purchased"""
  supportTier: SupportTier

  """The monthly usage limit for auditor runs"""
  auditorMonthlyUsageLimit: Int

  """The monthly usage limit for Transcend hosted prompt manager runs"""
  transcendHostedPromptManagerMonthlyUsageLimit: Int

  """Access to the dataLineage feature"""
  dataLineage: FeatureGate

  """Access to the siloDiscovery feature"""
  siloDiscovery: FeatureGate

  """Whether to show action item onboarding checklists in the account"""
  actionItemChecklists: FeatureGate

  """Access to the structuredDataDiscovery feature"""
  structuredDataDiscovery: FeatureGate

  """Access to the unstructuredDataDiscovery feature"""
  unstructuredDataDiscovery: FeatureGate

  """Access to the discoClassScan feature"""
  discoClassScan: FeatureGate

  """Access to the dsrAutomation feature"""
  dsrAutomation: FeatureGate

  """Access to the preferenceStore feature"""
  preferenceStore: FeatureGate

  """Access to the webConsent feature"""
  webConsent: FeatureGate

  """The number of mobile consent apps allowed"""
  mobileConsentApps: Int

  """Access to the contractScanning feature"""
  contractScanning: FeatureGate

  """Access to the pathfinder feature"""
  pathfinder: FeatureGate

  """
  Access to large language model (LLM) for content classification feature
  """
  llmClassifier: FeatureGate

  """
  Access to large language model (LLM) for unstructured classification feature
  """
  llmUnstructured: FeatureGate

  """
  The version tags that are allowed for the org (e.g. 'beta', 'verizon-test')
  """
  airgapAllowedVersionTags: [String!]

  """The maximum number of sync domains allowed for the org"""
  maxSyncDomainCount: Int

  """Access to the customDomain feature"""
  customDomainUI: FeatureGate

  """Access to the consent workflows feature"""
  consentWorkflows: FeatureGate

  """Access to Workflows V2"""
  workflowsv2: Boolean
}

"""Input for bulk updating features"""
input UpdateFeaturesInput {
  """List of features with the properties that should be updated for each"""
  features: [UpdateFeatureInput!]!
}

type UpdateIdentifierPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  The internal configuration of the identifier, view from the identifier's perspective on the /settings page.
  """
  identifier: Identifier!
}

"""The input for updating an existing identifier"""
input UpdateIdentifierInput {
  """The ID of the unique identifier"""
  id: ID!

  """
  The set of options to show in the privacy center when shown as a select component.
  """
  selectOptions: [String!]

  """
  The IDs of the explicit data subjects that the identifier should display for
  """
  dataSubjectIds: [ID!]

  """
  Whether the identifier should be required in the Privacy Center/Admin Dashboard DSR form.
  """
  isRequiredInForm: Boolean

  """A regex string for testing if a value matches the identifier"""
  regex: String

  """The privacy center placeholder text"""
  placeholder: String

  """The privacy center display title"""
  displayTitle: String

  """The privacy center display description"""
  displayDescription: String

  """
  The set of actions where this identifier should be shown for on the privacy center
  """
  privacyCenterVisibility: [RequestAction!]

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean

  """
  The order index for this identifier when displaying in the Privacy Center
  """
  displayOrder: Int

  """
  The SQL priority to use when generating SQL statements. If two identifiers are found for a table/datapoint, the lookup key for the table's SQL statement will be the identifier with highest priority. If no priorities are found, then all identifiers are queried. 
  """
  sqlPriority: Int

  """
  The SQL variable to use for this identifier in SQL statements. This defaults to just the identity function, but can be overridden to provide more complex SQL transformations. For example email does a LOWER({{ column }}) transformation. 
  """
  sqlVariable: String

  """
  The SQL variable to use for this identifier in SQL statements as a lookup key. This defaults to just the identity function @<identifierName>, but can be overridden to provide more complex SQL transformations. For example email UNHEX(@<identifierName>) transformation. 
  """
  sqlLookupVariable: String

  """
  Indicates that the value of the identifier is going to be unique when used in Preference store. 
  """
  isUniqueOnPreferenceStore: Boolean
}

type UpdateIntlMessagesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Message"""
  messages: [Message!]!
}

type UpdateLegalMatterPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An individual on a legal matter"""
  legalMatter: LegalMatter!
}

"""Update a new legal matter"""
input UpdateLegalMatterInput {
  """The ID of the legal matter"""
  id: ID!

  """The title of the legal matter"""
  title: String

  """The description of the legal matter"""
  description: String
}

type UpdateLoadOptionsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating the loadOptions for an airgap bundle"""
input UpdateLoadOptionsInput {
  """The id for this consent manager bundle."""
  id: ID!

  """Backend consent sync"""
  backendSync: BackendSyncOption

  """Backend consent sync endpoint URL"""
  backendSyncEndpoint: String

  """XDI consent sync endpoint URL"""
  syncEndpoint: String

  """Key used to partition consent records"""
  partition: String

  """JSON string with airgapBundleId as key and array of domains as value"""
  syncGroups: String

  """Which consent source does consent manager gives precedence to"""
  consentPrecedence: ConsentPrecedenceOption

  """Whether the site owner has signed the IAB agreement"""
  signedIabAgreement: SignedIabAgreementOption

  """How the Consent Manager should partition telemetry data"""
  telemetryPartitioning: TelemetryPartitionStrategy

  """What the consent manager should do when it encounters unknown cookies"""
  unknownCookiePolicy: UnknownRequestPolicy

  """What the consent manager should do when it encounters unknown requests"""
  unknownRequestPolicy: UnknownRequestPolicy

  """The Content Security Policy option"""
  csp: CspOption

  """The Sampling Rate for telemetry data"""
  telemetrySampleRate: String

  """Client-side sampling rate for outgoing requests and cookie mutations"""
  reqCookieSampleRate: String
}

type UpdateLookupProcessPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A long-running process, that is used to index an API"""
  lookupProcess: LookupProcess!

  """boolean"""
  wasUpdated: Boolean!
}

"""Input to update a Lookup process"""
input UpdateLookupProcessInput {
  """Lookup Process ID"""
  id: ID!

  """New status"""
  status: String

  """New tolerance"""
  tolerance: Int

  """New error count"""
  errorCount: Int

  """Schedule scan immediately"""
  scanNow: Boolean
}

"""Update internationalized messages for the Privacy Center"""
input UpdateMessagesInput {
  """
  Updated messages. ID must be provided or a customizable targetReactIntlId
  """
  messages: [MessageInput!]!

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type UpdateOrCreateApplicationUsersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ApplicationUser"""
  applicationUsers: [ApplicationUser!]!
}

"""Input for bulk updating/creating one or more applicationUsers"""
input UpdateOrCreateApplicationUsersInput {
  """
  List of applicationUsers with the properties that should be updated for each
  """
  applicationUsers: [UpdateApplicationUserInput!]!
}

"""Input to update or create many Airgap cookies"""
input UpdateOrCreateCookieInput {
  """The name or regex matching the name of the cookie"""
  name: String!

  """The tracking purposes that apply to this cookie"""
  trackingPurposes: [String!]

  """The purposes that apply to this cookie"""
  purposeIds: [ID!]

  """The description for this cookie"""
  description: String

  """The name of the SaaS tool associated with this cookie"""
  service: String

  """
  The name of the integration associated with this cookie. Often the same as service but not always
  """
  integrationName: String

  """The unique ids of the users to assign as owners of this cookie"""
  ownerIds: [ID!]

  """The ids of the teams that should be responsible for this cookie"""
  teamIds: [ID!]

  """Whether or not Airgap should ignore this cookie"""
  isJunk: Boolean

  """The status of this cookie"""
  status: ConsentTrackerStatus

  """Whether the cookie name is a regex"""
  isRegex: Boolean

  """The attribute values used to label this cookie"""
  attributes: [AttributeInput!]

  """The source of this cookie"""
  source: ConsentTrackerSource
}

type UpdateOrCreateCookiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Cookie"""
  nodes: [Cookie!]!

  """int"""
  totalCount: Int!
}

"""Input to bulk update-or-create cookies"""
input UpdateOrCreateCookiesInput {
  """The airgap bundle for which we want to bulk upsert cookies"""
  airgapBundleId: ID!

  """The cookies to bulk upsert"""
  cookies: [UpdateOrCreateCookieInput!]!
}

type UpdateOrCreateDataPointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A sub-categorization of data with a data silo, from internal perspective
  """
  dataPoint: DataPoint!
}

"""Input for updating a datapoint"""
input UpdateOrCreateDataPointInput {
  """The id of the data silo to create the datapoint for"""
  dataSiloId: ID!

  """The id of the datapoint to update"""
  id: ID

  """The title of the datapoint"""
  title: String

  """The actions that the datapoint should connect to"""
  enabledActions: [RequestActionObjectResolver!]

  """The id of the related data collection"""
  dataCollectionId: ID

  """
  The title of the data collection to assign to the datapoint.If the collection does not exist, one will be created.
  """
  dataCollectionTag: String

  """A description for the datapoint"""
  description: String

  """Method for redacting data in an erasure request"""
  erasureRedactionMethod: ErasureRedactionMethod

  """
  Usually only relevant for database silos, where datapoints can be uniquely identified by listing out the schemas that they belong to. The list of schema names MUST appear in order e.g., ["ANALYTICS","public"] is different from ["public","ANALYTICS"]
  """
  path: [String!]

  """
  The datapoint name (used to key by). This is deprecated. Please use "fullyQualifiedName" instead.
  """
  name: String

  """The suggested SQL queries to run for a DSR"""
  querySuggestions: [DbIntegrationQuerySuggestionInput!]

  """When true, upsert subdatapoints instead of adding & deleting"""
  upsertSubDataPointsOnly: Boolean

  """The subdatapoints associated with this datapoint"""
  subDataPoints: [DataPointSubDataPointInput!]

  """user defined key-value pairs that can be used to label datapoints"""
  attributes: [AttributeInput!]

  """
  The accepted mime types for the datapoint during a DSR. Empty list implies all mime types accepted
  """
  allowedMimeTypes: [String!]

  """The export mode of the datapoint"""
  exportMode: DataPointExportMode

  """The unique ids of the users to assign as owners of this datapoint"""
  ownerIds: [ID!]

  """The unique ids of the teams to assign as owners of this datapoint"""
  teamIds: [ID!]

  """The emails of the users to assign as owners of this datapoint."""
  ownerEmails: [String!]

  """The names of the teams that should be responsible for this datapoint"""
  teamNames: [String!]

  """The description of a datapoint"""
  scannedDescription: String

  """Whether description has been manually updated by user"""
  descriptionWasManuallyUpdated: Boolean

  """The encryption type for the datapoint"""
  encryption: TableEncryptionType
}

type UpdateOrCreateWorkflowDataPointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating or creating a workflow data point"""
input UpdateOrCreateWorkflowDataPointInput {
  """The id of the data point to update"""
  dataPointId: ID!

  """The id of the workflow to update"""
  workflowId: ID!

  """The export mode of the datapoint"""
  exportMode: DataPointExportMode

  """The order of the datapoint"""
  order: Int

  """The action to toggle on or off"""
  actionId: ID

  """The workflow identifiers used in this data point"""
  selectedIdentifiers: [String!]
}

"""Input for updating an organization's domains"""
input UpdateOrganizationDomainsInput {
  """The ID of the Organization to update the feature sets for"""
  organizationId: ID!

  """The main domain to host on"""
  domain: String

  """Additional domains that are verified for that organization"""
  verifiedDomains: [String!]

  """The ID of the parent organization to update to"""
  parentOrganizationId: ID
}

type UpdateOrganizationInfoPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """An organization on transcend"""
  organization: Organization!
}

"""Input for updating the organization's info"""
input UpdateOrganizationInput {
  """The name of the organization"""
  name: String

  """The description of the organization"""
  description: String

  """The default pretty alias used for emails"""
  defaultEmailAlias: String
}

type UpdateOrgTcfPurposesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Airgap Purposes inferred from a TCF Purpose"""
  orgTcfPurposes: TCFPurposeTrackingPurposes!
}

"""
Input used to update the mapping from TCF Purposes to Airgap tracking purposes
"""
input UpdateOrgTCFPurposesInput {
  """The TCF Purpose"""
  tcfPurposeId: ID!

  """The Airgap tracking purposes associated with this TCF purpose"""
  trackingPurposeIds: [ID!]

  """Whether or not this TCF purpose is applicable for the organization"""
  isApplicable: Boolean

  """
  Should vendors be allowed to process on the basis of Legitimate Interest if they declare that basis. If set to no, vendors may still request consent for the purpose if they've declared their legal basis is flexible.
  """
  allowLegitimateInterest: Boolean
}

type UpdateOrgTcfSpecialFeaturePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """TCF Special Feature for a particular consent bundle"""
  tcfSpecialFeatureTrackingPurposes: TCFSpecialFeatureTrackingPurpose!
}

type UpdatePasswordPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating a user's password"""
input UpdatePasswordInput {
  """The new password"""
  newPassword: String!

  """The old password"""
  password: String!
}

"""Input for updating a pathfinder"""
input UpdatePathfinderInput {
  """The id of the pathfinder"""
  id: ID!

  """The new name of the pathfinder"""
  name: String

  """The URL of the pathfinder"""
  url: String

  """The IDs of the applications that interact with the pathfinder service"""
  applicationIds: [ID!]

  """
  The names of the applications that interact with the pathfinder service
  """
  applicationNames: [String!]

  """
  The IDs of the pathfinder policies that should be applied to this pathfinder instance
  """
  pathfinderPolicyIds: [ID!]

  """
  The names of the pathfinder policies that should be applied to this pathfinder instance
  """
  pathfinderPolicyNames: [String!]

  """
  The IDs of the large language models that this pathfinder instance has access to
  """
  largeLanguageModelIds: [ID!]

  """The list of large language models to upsert for this pathfinder"""
  largeLanguageModelInputs: [LargeLanguageModelInput!]

  """The IDs of the agents that should be created for this pathfinder"""
  agentIds: [ID!]

  """The names of the agents that should be created for this pathfinder"""
  agentNames: [String!]

  """
  The remote IDs of the agents that should be created for this pathfinder
  """
  agentRemoteIds: [String!]
}

type UpdatePathfinderPoliciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PathfinderPolicy"""
  pathfinderPolicies: [PathfinderPolicy!]!
}

"""Input for bulk updating one or more pathfinderPolicies"""
input UpdatePathfinderPoliciesInput {
  """
  List of pathfinder policies with the properties that should be updated for each
  """
  pathfinderPolicies: [UpdatePathfinderPolicyInput!]!
}

"""Input for updating a pathfinder policy"""
input UpdatePathfinderPolicyInput {
  """The id of the pathfinder policy"""
  id: ID!

  """The new name of the pathfinder policy"""
  name: String

  """The type of pathfinder policy"""
  type: PathfinderPolicyType

  """The description of the pathfinder policy"""
  description: String

  """The response text of the pathfinder policy"""
  response: String

  """The ids of the data sub categories that the policy applies to"""
  dataSubCategoryIds: [ID!]

  """
  The data sub categories that the policy applies to, with the id and name
  """
  dataSubCategoryInputs: [DataSubCategoryInput!]

  """The ids of the pathfinders that the policy applies to"""
  pathfinderIds: [ID!]

  """The names of the pathfinders that the policy applies to"""
  pathfinderNames: [String!]
}

type UpdatePathfindersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Pathfinder"""
  pathfinders: [Pathfinder!]!
}

"""Input for bulk updating one or more pathfinders"""
input UpdatePathfindersInput {
  """
  List of pathfinders with the properties that should be updated for each
  """
  pathfinders: [UpdatePathfinderInput!]!
}

"""Input for updating the plaintext context values for an integration"""
input UpdatePlaintextContextInput {
  """The ID of the data silo to update"""
  dataSiloId: ID!

  """The plaintext context values to update"""
  newPlaintextValues: [PlaintextContextInput!]

  """The plaintext context values to remove"""
  removePlaintextValues: [String!]
}

"""Update a data silo plugin"""
input UpdatePluginInput {
  """The data silo this plugin belongs to"""
  dataSiloId: ID!

  """The plugin to toggle"""
  pluginId: ID!

  """State to toggle plugin to"""
  enabled: Boolean

  """
  The updated frequency with which we should schedule this plugin, in milliseconds. Needs to be a string because the number can be larger than the MAX_INT
  """
  scheduleFrequency: String

  """
  The updated start time when we should start scheduling this plugin, in ISO format.
  """
  scheduleStartAt: Date

  """Whether we should schedule a run immediately after this request"""
  scheduleNow: Boolean

  """Configuration for the plugin"""
  configuration: String
}

type UpdatePoliciesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Policy"""
  policies: [Policy!]!
}

"""Make changes to the global Privacy Center configuration"""
input UpdatePoliciesInput {
  """The ID of the Privacy Center to update"""
  privacyCenterId: ID!

  """The updated policy definitions"""
  policies: [PolicyInput!]!

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type UpdatePrivacyCenterPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The Privacy Center configuration"""
  privacyCenter: PrivacyCenterStringified!
}

"""
The ids and alt text of the asset files that should be globally updated
"""
input UpdatePrivacyCenterAssetFileInput {
  """The id of the asset file"""
  id: ID!

  """The alt text for this asset file"""
  alt: String
}

"""The asset files that should be globally updated"""
input UpdatePrivacyCenterAssetsInput {
  """The asset file logo"""
  logo: UpdatePrivacyCenterAssetFileInput

  """The asset file favicon"""
  favicon: UpdatePrivacyCenterAssetFileInput

  """The asset file logoOnSolid"""
  logoOnSolid: UpdatePrivacyCenterAssetFileInput

  """The asset file hero"""
  hero: UpdatePrivacyCenterAssetFileInput

  """The asset file widgetBg"""
  widgetBg: UpdatePrivacyCenterAssetFileInput
}

"""The updated color palette colors"""
input UpdatePrivacyCenterColorPaletteInput {
  """The color customization for  primary"""
  primary: String

  """The color customization for  secondary"""
  secondary: String

  """The color customization for  bgAccent"""
  bgAccent: String

  """The color customization for  textOnBg"""
  textOnBg: String

  """The color customization for  textLightOnBg"""
  textLightOnBg: String

  """The color customization for  error"""
  error: String

  """The color customization for  heroBg"""
  heroBg: String

  """The color customization for  sidebarNavBg"""
  sidebarNavBg: String

  """The color customization for  widgetBg"""
  widgetBg: String

  """The color customization for  highlight"""
  highlight: String

  """The color customization for  tableOutline"""
  tableOutline: String

  """The color customization for  textOnPrimary"""
  textOnPrimary: String

  """The color customization for  textOnHero"""
  textOnHero: String

  """The color customization for  textOnSidebar"""
  textOnSidebar: String

  """The color customization for  accentOnSidebar"""
  accentOnSidebar: String

  """The color customization for  textOnAboutTranscend"""
  textOnAboutTranscend: String
}

"""Make changes to the global Privacy Center configuration"""
input UpdatePrivacyCenterInput {
  """The ID of the Privacy Center to update"""
  privacyCenterId: ID!

  """The updated asset files"""
  assets: UpdatePrivacyCenterAssetsInput

  """The updated color palette"""
  colorPalette: UpdatePrivacyCenterColorPaletteInput

  """CSS overrides for components on the Privacy Center"""
  componentStyles: ComponentStylesInput

  """Text overrides on the Privacy Center"""
  textStyles: TextStylesInput

  """
  When true, do not show the Privacy Center, instead show a disabled message
  """
  isDisabled: Boolean

  """The languages that the Privacy Center supports"""
  locales: [String!]

  """The default language of the Privacy Center"""
  defaultLocale: String

  """Update whether to use the browser default locale if available"""
  preferBrowserDefaultLocale: Boolean

  """The support email that should be linked to in the footer"""
  supportEmail: String

  """
  The support email that should be used when the user hits reply-to on an email
  """
  replyToEmail: String

  """
  The email prefix that should be used when sending emails to the data subject
  """
  emailPrefix: String

  """The homepage url of the Privacy Center"""
  home: String

  """Update whether tracking technologies page is shown"""
  showTrackingTechnologies: Boolean

  """Update whether "Privacy Settings" page is shown"""
  showManageYourPrivacy: Boolean

  """Update whether sale of info page is shown"""
  showSaleOfInfo: Boolean

  """Update the regions that support unauthenticated Do Not Sell requests"""
  unauthenticatedDoNotSellRegions: [RegionInput!]

  """Update whether marketing preferences page is shown"""
  showMarketingPreferences: Boolean

  """Update whether policies page is shown"""
  showPolicies: Boolean

  """Show cookies in tracking technologies table"""
  showCookies: Boolean

  """Show cookie expiration duration in tracking technologies table"""
  showCookieMaxAge: Boolean

  """
  Enable the ability to set/change consent preferences via the consent manager
  """
  showConsentManager: Boolean

  """Show data flows in tracking technologies table"""
  showDataFlows: Boolean

  """Show the Make a Privacy Request button"""
  showPrivacyRequestButton: Boolean

  """
  Indicates whether to use a no-reply email address for data subject communications
  """
  useNoReplyEmailAddress: Boolean

  """
  Whether to use the configured email domain for data subject communications
  """
  useCustomEmailDomain: Boolean

  """
  Should we attempt to transform any JSON objects as part of the ACCESS report download into CSV?
  """
  transformAccessReportJsonToCsv: Boolean

  """When true, show the partition select component in the privacy center"""
  allowPartitionChange: Boolean

  """When true, show the partition information on the privacy center"""
  showPartition: Boolean

  """
  The custom subdomain to use, instead of the default "privacy" subdomain
  """
  customSubdomain: String

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean

  """The order in which the policies should be displayed"""
  displayOrder: Int

  """
  The child organization ids that should be displayed on the multi-brand privacy center
  """
  displayedChildOrganizationIds: [ID!]
}

type UpdateProcessingActivitiesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of ProcessingActivity"""
  processingActivities: [ProcessingActivity!]!
}

"""Input for bulk updating one or more processing activities"""
input UpdateProcessingActivitiesInput {
  """
  List of processing activities with the properties that should be updated for each
  """
  processingActivities: [UpdateProcessingActivityInput!]!
}

"""Input for updating a processing activity"""
input UpdateProcessingActivityInput {
  """The processing activity ID to update"""
  id: ID!

  """The title of the processing activity"""
  title: String

  """The description of the processing activity"""
  description: String

  """Security measures related to this processing activity"""
  securityMeasureDetails: String

  """The controllership values assigned to this processingActivity"""
  controllerships: [Controllership!]

  """The storage regions associated with this processing activity"""
  storageRegions: [RegionInput!]

  """The transfer regions associated with this processing activity"""
  transferRegions: [RegionInput!]

  """The type of retention schedule"""
  retentionType: RetentionType

  """
  The number of days personal data is retained (for stated period retention types)
  """
  retentionPeriod: Int

  """A link to the DPIA for this processing activity"""
  dataProtectionImpactAssessmentLink: String

  """The status of the DPIA for this processing activity"""
  dataProtectionImpactAssessmentStatus: DataProtectionImpactAssessmentStatus

  """The attributes to associate with the processing activity"""
  attributes: [AttributeInput!]

  """The list of data silo IDs to associate with the processing activity"""
  dataSiloIds: [ID!]

  """The list of data subject IDs to associate with the processing activity"""
  dataSubjectIds: [ID!]

  """The list of team IDs to associate with the processing activity"""
  teamIds: [ID!]

  """
  The list of user IDs (owners) to associate with the processing activity
  """
  ownerIds: [ID!]

  """
  The list of processing purpose subcategory IDs to associate with the processing activity
  """
  processingPurposeSubCategoryIds: [ID!]

  """
  The list of SaaS category IDs to associate with the processing activity
  """
  saaSCategoryIds: [ID!]

  """
  The list of data subcategory IDs to associate with the processing activity
  """
  dataSubCategoryIds: [ID!]
}

type UpdateProcessingPurposeSubCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PurposeSubCategory"""
  processingPurposeSubCategories: [PurposeSubCategory!]!
}

"""
Input for bulk updating one or more  purpose of processing  subcategories
"""
input UpdateProcessingPurposeSubCategoriesInput {
  """
  List of purpose of processing subcategories with the properties that should be updated for each
  """
  processingPurposeSubCategories: [UpdateProcessingPurposeSubCategoryInput!]!
}

"""Input for updating a purpose of processing subcategory"""
input UpdateProcessingPurposeSubCategoryInput {
  """The ID of the subcategory to update"""
  id: ID!

  """The text to use as the new description of the subcategory"""
  description: String

  """
  The unique ids of the users to assign as owners of this processing purpose
  """
  ownerIds: [ID!]

  """
  The email addresses of the users to assign as owners of this processing purpose
  """
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this processing purpose
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this processing purpose
  """
  teamNames: [String!]

  """The attribute values used to label this vendor"""
  attributes: [AttributeInput!]
}

"""Input for updating a Prompt group"""
input UpdatePromptGroupInput {
  """The id of the prompt group"""
  id: ID!

  """The new title of the prompt group"""
  title: String

  """The description of the prompt group """
  description: String

  """The ids of the prompt in the group"""
  promptIds: [ID!]

  """The titles of the prompts in the group"""
  promptTitles: [String!]

  """The unique ids of the users to assign as owners of this prompt group"""
  ownerIds: [ID!]

  """
  The unique emails of the users to assign as owners of this prompt group
  """
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this prompt group"""
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this prompt group
  """
  teamNames: [String!]
}

type UpdatePromptGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptGroup"""
  promptGroups: [PromptGroup!]!
}

"""Input for bulk updating one or more prompt groups"""
input UpdatePromptGroupsInput {
  """
  List of prompt groups with the properties that should be updated for each
  """
  promptGroups: [UpdatePromptGroupInput!]!
}

"""Input for updating an Prompt"""
input UpdatePromptInput {
  """The id of the Prompt"""
  id: ID!

  """
  The expected mode in which response text is returned - commonly set to json_object to return JSON data
  """
  responseFormat: PromptResponseFormat

  """
  Amount of randomness injected into the response. Defaults to 1. Ranges from 0 to 1. Use temp closer to 0 for analytical / multiple choice, and closer to 1 for creative and generative tasks.
  """
  temperature: Float

  """
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. We generally recommend altering this or `temperature` but not both.
  """
  topP: Float

  """The maximum number of tokens to sample in the response"""
  maxTokensToSample: Int

  """The new title of the Prompt"""
  title: String

  """The new content of the Prompt"""
  content: String

  """The new status of the prompt"""
  status: PromptStatus

  """The ID of the user requesting this prompt"""
  reviewerId: ID

  """The email of the user requesting this prompt"""
  reviewerEmail: String

  """The unique ids of the users to assign as owners of this prompt"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this prompt"""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this prompt"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this prompt"""
  teamNames: [String!]

  """The ids of the large language models that work well with this prompt"""
  largeLanguageModelIds: [ID!]

  """
  The inputs of the large language models that work well with this prompt
  """
  largeLanguageModelInputs: [LargeLanguageModelInput!]

  """The ids of the prompt groups that this prompt should be a part of"""
  promptGroupIds: [ID!]

  """The titles of the prompt groups that this prompt should be a part of"""
  promptGroupTitles: [String!]
}

"""Input for updating a Prompt partial"""
input UpdatePromptPartialInput {
  """The id of the Prompt"""
  id: ID!

  """The new title of the Prompt"""
  title: String

  """The new content of the Prompt"""
  content: String

  """The unique ids of the users to assign as owners of this partial prompt"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this partial prompt"""
  ownerEmails: [String!]

  """
  The ids of the teams that should be responsible for this partial prompt
  """
  teamIds: [ID!]

  """
  The names of the teams that should be responsible for this partial prompt
  """
  teamNames: [String!]
}

type UpdatePromptPartialsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptPartial"""
  promptPartials: [PromptPartial!]!
}

"""Input for bulk updating one or more prompt partials"""
input UpdatePromptPartialsInput {
  """
  List of prompt partials with the properties that should be updated for each
  """
  promptPartials: [UpdatePromptPartialInput!]!
}

type UpdatePromptsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Prompt"""
  prompts: [Prompt!]!
}

"""Input for bulk updating one or more prompts"""
input UpdatePromptsInput {
  """List of prompts with the properties that should be updated for each"""
  prompts: [UpdatePromptInput!]!
}

"""Input for updating a Prompt thread"""
input UpdatePromptThreadInput {
  """The id of the prompt thread. Either this or threadId must be provided."""
  id: ID

  """
  The ID of the thread in the remote system. Either this or id must be provided.
  """
  threadId: String

  """The ts of the slack message is the thread is a slack conversation"""
  slackMessageTs: String

  """The ID of the slack team if the thread is a slack conversation"""
  slackTeamId: String

  """The ID of the slack channel if the thread is a slack conversation"""
  slackChannelId: String

  """The name of the slack channel if the thread is a slack conversation"""
  slackChannelName: String
}

type UpdatePromptThreadsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PromptThread"""
  promptThreads: [PromptThread!]!
}

"""Input for bulk updating one or more prompt threads"""
input UpdatePromptThreadsInput {
  """
  List of prompt threads with the properties that should be updated for each
  """
  promptThreads: [UpdatePromptThreadInput!]!
}

"""Input for updating a pull request"""
input UpdatePullRequestInput {
  """The id of the pull request"""
  id: ID!

  """The title of the pull request"""
  title: String

  """The description of the pull request"""
  description: String

  """The URL of the pull request"""
  url: String

  """The IDs of users that made the pull request"""
  userIds: [ID!]

  """The emails of users that made the pull request"""
  userEmails: [String!]
}

type UpdatePullRequestsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of PullRequest"""
  pullRequests: [PullRequest!]!
}

"""Input for bulk updating one or more pull requests"""
input UpdatePullRequestsInput {
  """
  List of pull requests with the properties that should be updated for each
  """
  pullRequests: [UpdatePullRequestInput!]!
}

type UpdatePurposePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A tracking purpose"""
  purpose: TrackingPurpose!
}

"""Input used to update an existing consent purpose for an organization"""
input UpdatePurposeInput {
  """The id of the purpose"""
  id: ID!

  """The name of this purpose"""
  name: String

  """Tracking purpose description (used in Consent Manager UI) """
  description: String

  """Privacy signals that should opt the user out of this tracking purpose"""
  optOutSignals: [UserPrivacySignalEnum!]

  """
  The display name of the purpose that appears in Consent Management and Privacy Center UIs
  """
  title: String

  """Whether this purpose should be shown in the Consent Manager UI"""
  showInConsentManager: Boolean

  """Whether this purpose should be configurable by the user """
  configurable: Boolean

  """
  The order in which the purpose is displayed compared to other purposes in the list
  """
  displayOrder: Int

  """Whether the purpose is active for an organization"""
  isActive: Boolean

  """
  The authentication level require by user to update the marketing purpose
  """
  authLevel: PreferenceStoreAuthLevel

  """
  Whether this purpose should be shown in the communication preferences page of the privacy center
  """
  showInPrivacyCenter: Boolean
}

type UpdateRepositoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Repository"""
  repositories: [Repository!]!
}

"""Input for bulk updating one or more repositories"""
input UpdateRepositoriesInput {
  """
  List of repositories with the properties that should be updated for each
  """
  repositories: [UpdateRepositoryInput!]!
}

"""Input for updating a repository"""
input UpdateRepositoryInput {
  """The id of the repository"""
  id: ID!

  """The new name of the repository"""
  name: String

  """The description of the repository"""
  description: String

  """The URL of the repository"""
  url: String

  """The unique ids of the users to assign as owners of this repository"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this repository."""
  ownerEmails: [String!]

  """The ids of the teams that should be responsible for this repository"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this repository"""
  teamNames: [String!]
}

type UpdateRequestPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Represents a data subject request"""
  request: Request!
}

type UpdateRequestDataSiloDetailsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating a request data silo details"""
input UpdateRequestDataSiloDetailsInput {
  """ID of RequestDataSilo to update details for"""
  id: ID!

  """The token to validate (required if not logged in)"""
  token: String

  """The request details to update"""
  details: String!
}

"""SR configuration settings for an organization"""
input UpdateRequestDataSiloStatusesInput {
  """The ID of the request to update"""
  requestId: ID!

  """The IDs of the data silos to update"""
  dataSiloIds: [ID!]!

  """The desired status to update to"""
  status: UpdateRequestDataSiloStatus!
}

"""SR configuration settings for an organization"""
input UpdateRequestDataSiloStatusInput {
  """The ID of the request data silo to update"""
  id: ID!

  """The desired status to update to"""
  status: UpdateRequestDataSiloStatus!
}

type UpdateRequestFileStatusPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A download file viewed from the administrator perspective"""
  requestFile: RequestFile!
}

"""Input to update the Request File status."""
input UpdateRequestFileStatusInput {
  """Request File Id"""
  id: ID!

  """Request File status"""
  status: RequestFileStatus!
}

"""Input to update existing DSRs"""
input UpdateRequestInput {
  """The id of the request"""
  id: ID!

  """Whether to make the request a test request"""
  isTest: Boolean

  """Whether to make the request a silent request"""
  isSilent: Boolean

  """What to set the details of the request to"""
  details: String

  """The unique ids of the users to assign as owners of this request"""
  ownerIds: [ID!]

  """The ids of the teams that should be responsible for this request"""
  teamIds: [ID!]
}

"""Update a retention schedule policy"""
input UpdateRetentionScheduleInput {
  """The id of the retention schedule to update"""
  id: ID!

  """The duration of the retention schedule in days"""
  durationDays: Int

  """The operation to perform on the retention schedule"""
  operation: RetentionScheduleOperation

  """The type of the retention schedule"""
  type: RetentionScheduleType
}

type UpdateRiskCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskCategory"""
  riskCategories: [RiskCategory!]!
}

"""Input for updating risk categories"""
input UpdateRiskCategoriesInput {
  """The list of risk categories to update"""
  riskCategories: [UpdateRiskCategoryInput!]!
}

"""Input for updating a risk category"""
input UpdateRiskCategoryInput {
  """The id of the risk category"""
  id: ID!

  """The display name of the risk category"""
  title: String

  """A description of what kinds of risk this risk category represents"""
  description: String

  """
  The list of individual users who are responsible for managing this risk category
  """
  ownerIds: [ID!]

  """The list of teams who are responsible for managing this risk category"""
  teamIds: [ID!]
}

"""
Input for updating a risk category within the context of a risk framework
"""
input UpdateRiskCategoryWithinFrameworkInput {
  """The id of the risk category"""
  id: ID

  """The display name of the risk category"""
  title: String!

  """A description of what kinds of risk this risk category represents"""
  description: String
}

"""Input for updating a risk framework"""
input UpdateRiskFrameworkInput {
  """The id of the risk framework"""
  id: ID!

  """The display name of the risk framework"""
  title: String

  """A description of what this risk framework represents"""
  description: String

  """
  The risk levels associated with this risk framework, sorted lowest to highest risk
  """
  riskLevels: [UpdateRiskLevelWithinFrameworkInput!]

  """The risk categories associated with this risk framework"""
  riskCategories: [UpdateRiskCategoryWithinFrameworkInput!]

  """
  The risk matrix columns associated with this risk framework, sorted lowest to highest
  """
  riskMatrixColumns: [UpdateRiskMatrixColumnWithinFrameworkInput!]

  """
  The risk matrix rows associated with this risk framework, sorted lowest to highest
  """
  riskMatrixRows: [UpdateRiskMatrixRowWithinFrameworkInput!]

  """
  The titles of risk levels that correspond to a particular risk matrix column and row combinationThe first index is the risk matrix row index, and the second index is the risk matrix column index.
  """
  riskMatrix: [[String!]!]

  """The title of the risk matrix columns in this framework"""
  riskMatrixRowTitle: String

  """The title of the risk matrix columns in this framework"""
  riskMatrixColumnTitle: String
}

type UpdateRiskFrameworksPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of RiskFramework"""
  riskFrameworks: [RiskFramework!]!
}

"""Input for updating multiple risk frameworks"""
input UpdateRiskFrameworksInput {
  """The risk frameworks to update"""
  riskFrameworks: [UpdateRiskFrameworkInput!]!
}

"""Input for updating a risk level within the context of a risk framework"""
input UpdateRiskLevelWithinFrameworkInput {
  """The id of the risk level"""
  id: ID

  """The display name of the risk level"""
  title: String!

  """The color associated with risk level"""
  color: String!
}

"""
Input for updating a risk matrix column within the context of a risk framework
"""
input UpdateRiskMatrixColumnWithinFrameworkInput {
  """The id of the risk matrix column"""
  id: ID

  """The display name of the risk matrix column"""
  title: String!
}

"""
Input for updating a risk matrix row within the context of a risk framework
"""
input UpdateRiskMatrixRowWithinFrameworkInput {
  """The id of the risk matrix row"""
  id: ID

  """The display name of the risk matrix row"""
  title: String!
}

type UpdateSavingsConfigurationPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The savings configuration for the org"""
  updatedConfiguration: SavingsConfigurationPreview!
}

"""Input for updating the savings configuration for the org"""
input UpdateSavingsConfigurationInput {
  """Number of external systems where staff manually action data from"""
  numManualSystems: Float!

  """
  Number of extra external systems where staff email the vendor requesting action on a subject's data not yet connected in transcend
  """
  numEmailSystems: Float!

  """Salary of Legal/Operations Manager"""
  legalSalary: Float!

  """Salary of Sales/Marketing/HR Manager"""
  salesSalary: Float!

  """Salary of Software Engineer"""
  engineerSalary: Float!
}

type UpdateScopePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A scope that exists within an organization"""
  scope: Scope!
}

"""Input for updating access to a scope"""
input UpdateScopeInput {
  """The unique ID of the scope"""
  id: ID!

  """The IDs of the users that should have direct access to the scope"""
  users: [ID!]

  """The IDs of the teams that should have the scope"""
  teams: [ID!]

  """The IDs of the API keys that should have the scope"""
  apiKeys: [ID!]
}

type UpdateSensitiveCategoriesPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SensitiveCategory"""
  sensitiveCategories: [SensitiveCategory!]!
}

"""Input for bulk updating one or more sensitive categories"""
input UpdateSensitiveCategoriesInput {
  """
  List of sensitive categories with the properties that should be updated for each
  """
  sensitiveCategories: [UpdateSensitiveCategoryInput!]!
}

"""Input for updating a sensitive category"""
input UpdateSensitiveCategoryInput {
  """The sensitive category ID to update"""
  id: ID!

  """The title of the sensitive category"""
  title: String

  """The description of the sensitive category"""
  description: String

  """The color of the sensitive category"""
  color: String
}

type UpdateSitescanPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Status of a sitescan for an organization"""
  sitescan: Sitescan!
}

"""Update the status of a sitescan for an organization"""
input UpdateSitescanInput {
  """The status of the sitescan"""
  status: SitescanStatus!

  """The organization ID whose sitescan status we want to report"""
  organizationId: ID!
}

"""Input for updating a software development kit"""
input UpdateSoftwareDevelopmentKitInput {
  """The id of the software development kit"""
  id: ID!

  """The name of the software development kit"""
  name: String

  """The description of the software development kit"""
  description: String

  """The URL of the software development kit"""
  repositoryUrl: String

  """
  The name of the integration in the catalog that the software development kit relates to
  """
  catalogIntegrationName: String

  """The documentation links of the software development kit"""
  documentationLinks: [String!]

  """
  The IDs of the code packages that the software development kit is used on
  """
  codePackageIds: [ID!]

  """
  The names of the code packages that the software development kit is used on
  """
  codePackageNames: [String!]

  """The IDs of users that manage the software development kit"""
  ownerIds: [ID!]

  """The emails of users that manage the software development kit"""
  ownerEmails: [String!]

  """The IDs of teams that manage the software development kit"""
  teamIds: [ID!]

  """The names of teams that manage the software development kit"""
  teamNames: [String!]
}

type UpdateSoftwareDevelopmentKitsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SoftwareDevelopmentKit"""
  softwareDevelopmentKits: [SoftwareDevelopmentKit!]!
}

"""Input for bulk updating one or more software development kits"""
input UpdateSoftwareDevelopmentKitsInput {
  """
  List of software development kits with the properties that should be updated for each
  """
  softwareDevelopmentKits: [UpdateSoftwareDevelopmentKitInput!]!
}

type UpdateSombraPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The sombra configuration with associated models"""
  sombra: ConfiguredSombra!
}

"""Input for updating a sombra gateway"""
input UpdateSombraInput {
  """The customer ingress domain"""
  customerIngress: String

  """The title of the sombra gateway"""
  title: String

  """The data silos to associate with the sombra gateway"""
  dataSiloIds: [ID!]
}

type UpdateSombraJwtConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input to update the JWT authentication public key"""
input UpdateSombraJWTConfigInput {
  """The public key used to verify the data subject's JWT auth token."""
  publicKey: String!
}

type UpdateSombraOAuthConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input to update the OAuth config parameters"""
input UpdateSombraOAuthConfigInput {
  """The Client ID of the privacy center's OAuth 2 application"""
  clientId: String!

  """
  The token URL for the OAuth API to exchange an authorization code to an access token
  """
  getTokenUrl: String!

  """The redirect URL for the OAuth application"""
  getTokenBodyRedirectUri: String!

  """The OAuth token grant type"""
  getTokenBodyGrantType: String

  """The HTTP method for fetching the OAuth token from the OAuth API"""
  getTokenMethod: HttpMethod

  """The keys of the headers to include when fetching the OAuth token"""
  getTokenHeadersKeys: [String!]

  """The values of the headers to include when fetching the OAuth token"""
  getTokenHeadersValues: [String!]

  """
  The API endpoint that returns a user ID or other similar core identifier
  """
  getCoreIdUrl: String!

  """The data subject type that the oauth config corresponds to"""
  getCoreIdDataSubjectType: String!

  """The path to extract the core identifier from the JSON response body"""
  getCoreIdPath: String!

  """The API endpoint that returns a user email"""
  getEmailUrl: String!

  """The path to extract the email from the JSON response body"""
  getEmailPath: String!

  """
  Whether all OAuth emails are already verified by default, attested by the organization
  """
  getEmailIsVerified: Boolean

  """
  The path to extract whether the email is verified for the OAuth profile
  """
  getEmailIsVerifiedPath: String

  """An endpoint to retrieve a profile picture for the data subject"""
  getProfilePictureUrl: String

  """The path to extract the profile picture from the JSON response body"""
  getProfilePicturePath: String
}

type UpdateSombraTenantConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type UpdateSsoProviderPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration settings for an SSO provider"""
  ssoProvider: SsoProvider!
}

"""Input for updating a single subdatapoint"""
input UpdateSubDataPointInput {
  """The ID of the subdatapoint to update with the included fields."""
  id: ID!

  """The name of the subdatapoint"""
  name: String

  """
          When true, this subdatapoint should be revealed in a data access request.
  When false, this field should be redacted
  """
  accessRequestVisibilityEnabled: Boolean

  """
          When true, this subdatapoint should be redacted during an erasure request.
  There normally is a choice of enabling hard deletion or redaction at the
  datapoint level, but if redaction is enabled, this column can be used
  to define which fields should be redacted.
  """
  erasureRequestRedactionEnabled: Boolean

  """A description for the subdatapoint"""
  description: String

  """The IDs of the subcategories to associate with this subdatapoint"""
  dataSubCategories: [ID!]

  """The IDs of any rejected subcategory guesses for this subdatapoint"""
  rejectedGuesses: [ID!]

  """The IDs of the sub-purposes to associate with this subdatapoint"""
  processingPurposeSubCategories: [ID!]

  """The attribute values used to label this subdatapoint"""
  attributes: [AttributeInput!]

  """The IDs of the users to assign as owners of the parent datapoint"""
  dataPointOwnerIds: [ID!]

  """The IDs of the teams to assign as owners of the parent datapoint"""
  dataPointTeamIds: [ID!]

  """The organization's controllership of the subdatapoint"""
  controllership: Controllership

  """The list of subject IDs to allow for this sub-datapoint"""
  subjectIds: [ID!]

  """The type of retention schedule for this sub-datapoint"""
  retentionType: RetentionType

  """
  The number of days data for this sub-datapoint is retained (for stated period retention types)
  """
  retentionPeriod: Int

  """Whether or not to reject all outstanding guesses for this subdatapoint"""
  rejectOutstandingGuesses: Boolean

  """Whether or not to reclassify guessed categories for the subdatapoint."""
  reclassify: Boolean

  """The encryptions to apply to this subdatapoint"""
  encryption: ColumnEncryptionType

  """
  The set of processing activities that should be assigned to this subdatapoint
  """
  processingActivityIds: [ID!]
}

type UpdateSubDataPointsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of SubDataPoint"""
  subDataPoints: [SubDataPoint!]!
}

"""Input for bulk updating subdatapoints"""
input UpdateSubDataPointsInput {
  """
  List of subdatapoints with the properties that should be updated for each
  """
  subDataPoints: [UpdateSubDataPointInput!]!
}

type UpdateSubjectPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The internal configuration for a data subject"""
  subject: DataSubjectInternal!
}

"""Input for updating a data subject"""
input UpdateSubjectInput {
  """The unique id of the data subject to update"""
  id: ID!

  """The display message used on the privacy center"""
  title: String

  """The actions to allow for this data subject"""
  actions: [RequestAction!]

  """
  The instructions that should be shown in the modal as the data subject attempts to login
  """
  loginInstructions: String

  """
  The instructions that should be shown in the modal to instruct the data subject to make the request another way
  """
  disabledInstructions: String

  """
  The admin dashboard form for this data subject should result all requests in silent mode when true. This is useful for admin-only workflows.
  """
  adminDashboardDefaultSilentMode: Boolean

  """The URL where the data subject can login"""
  redirectUrl: String

  """The organization's oauthClientId associated with subjects of this type"""
  oauthClientId: String

  """The oauthScope used to get context for data subjects of this type."""
  oauthScope: String

  """
  The unique ids of the users to assign as owners of this data subject and requests made to this data subject.
  """
  ownerIds: [ID!]

  """
  The ids of the teams that should be responsible for this data subject and requests made to this data subject.
  """
  teamIds: [ID!]

  """Should we skip publishing the module to the CDN?"""
  skipPublish: Boolean
}

type UpdateSyncEndpointPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating the airgap XDI consent sync endpoint URL"""
input UpdateSyncEndpointInput {
  """The ID of this consent manager bundle."""
  id: ID!

  """XDI consent sync endpoint URL"""
  syncEndpoint: String!
}

type UpdateSyncGroupsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration and metadata for the consent manager (aka Airgap)."""
  consentManager: ConsentManager!
}

"""Input for updating sync groups"""
input UpdateSyncGroupsInput {
  """The ID of this Consent Manager bundle."""
  id: ID!

  """JSON string with airgapBundleId as key and array of domains as value"""
  syncGroups: String
}

"""
Input used to update the mapping from TCF Special Features to Airgap tracking purposes
"""
input UpdateTCFSpecialFeatureTrackingPurposesInput {
  """The TCF Special Feature"""
  tcfSpecialFeatureId: ID!

  """The Airgap tracking purposes associated with this TCF special feature"""
  trackingPurposeIds: [ID!]

  """
  Whether or not this TCF special feature is applicable for the organization
  """
  isApplicable: Boolean
}

type UpdateTeamPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An existing team of users.
  The team can be assigned scopes and all users in that team will inherit the scopes
  """
  team: Team!
}

"""Input for updating a team"""
input UpdateTeamInput {
  """The id of the team to update"""
  id: ID!

  """The new name of the team"""
  name: String

  """The internal description of the team"""
  description: String

  """
  The SSO titles that should be auto assigned to this team on account creation.
  """
  ssoTitle: String

  """
  The SSO departments that should be auto assigned to this team on account creation.
  """
  ssoDepartment: String

  """
  The SSO groups that should be auto assigned to this team on account creation.
  """
  ssoGroup: String

  """The ids of the users in the organization the team should contain"""
  users: [ID!]

  """The emails of the users that should be in that team"""
  userEmails: [String!]

  """The scopes the team should have"""
  scopes: [ScopeName!]

  """The ids of the data silos to assign to"""
  dataSilos: [ID!]

  """
  The id of the team in the parent organization to link to this team for auto-provisioning purposes
  """
  parentTeam: ID
}

type UpdateTemplatePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  An email template to send and receive communication with the data subject
  """
  template: Template!
}

"""Input for updating an existing message template"""
input UpdateTemplateInput {
  """The id of the template to update"""
  id: ID!

  """The actual template contents."""
  template: String

  """The title of the template for lookup purposes"""
  title: String

  """The subject message for the email communication"""
  subject: String

  """The actual template contents."""
  type: TemplateType
}

"""
The validated or corrected recommendation for an unstructured subdatapoint
"""
input UpdateUnstructuredSubDataPointRecommendationInput {
  """
  The ID of the recommendation being corrected or validated (if corrected, the existing recommendation will be rejected and a new one generated)
  """
  unstructuredSubDataPointRecommendationId: ID!

  """The ID of the subcategory to associate with this subdatapoint"""
  dataSubCategory: ID
}

type UpdateUnstructuredSubDataPointRecommendationsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of UnstructuredSubDataPointRecommendation"""
  unstructuredSubDataPointRecommendations: [UnstructuredSubDataPointRecommendation!]!
}

"""Input for bulk updating scanned objects"""
input UpdateScannedObjectsInput {
  """List of recommendations to validate or correct"""
  unstructuredSubDataPointRecommendations: [UpdateUnstructuredSubDataPointRecommendationInput!]!
}

type UpdateUserPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """Another user in the organization."""
  user: User!
}

"""Input for updating a user as an admin"""
input UpdateUserAsAdminInput {
  """The id of the user to update"""
  id: ID!

  """The method by which that user logs in"""
  loginMethod: UserLoginMethod

  """The ID of the parent user role to update to"""
  parentRoleId: ID

  """The email to update the user to"""
  email: String

  """The name to update the user to"""
  name: String
}

"""Input for updating the current user's attributes"""
input UpdateUserInput {
  """The id of the user to update"""
  id: ID!

  """The name of the user"""
  name: String

  """Whether the user should be an administrator"""
  isAdmin: Boolean

  """The teams in the organization the user should have"""
  teams: [ID!]

  """The scopes the user should have"""
  scopes: [ScopeName!]

  """The dataSilos in the organization the user should have"""
  dataSilos: [ID!]
}

type UpdateUserProfilePayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The currently logged in user"""
  user: CurrentUser!
}

"""Input for updating a vendor"""
input UpdateVendorInput {
  """The vendor ID to update"""
  id: ID!

  """The title of the vendor"""
  title: String

  """The description of the vendor"""
  description: String

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """A phone number for the vendor"""
  contactPhone: String

  """The address of the vendor"""
  address: String

  """The unique ids of the users to assign as owners of this vendor"""
  ownerIds: [ID!]

  """The emails of the users to assign as owners of this vendor"""
  ownerEmails: [String!]

  """The business entity that the vendor is assigned to"""
  businessEntityId: ID

  """The business entity that the vendor is assigned to"""
  businessEntityTitle: String

  """The ids of the teams that should be responsible for this vendor"""
  teamIds: [ID!]

  """The names of the teams that should be responsible for this vendor"""
  teamNames: [String!]

  """The attribute values used to label this vendor"""
  attributes: [AttributeInput!]
}

type UpdateVendorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Vendor"""
  vendors: [Vendor!]!
}

"""Input for bulk updating one or more vendors"""
input UpdateVendorsInput {
  """List of vendors with the properties that should be updated for each"""
  vendors: [UpdateVendorInput!]!
}

type UpdateWorkflowCommunicationSettingsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating a workflows communication settings"""
input UpdateWorkflowCommunicationSettingsInput {
  """The unique ID of the workflow configs communication settings"""
  id: ID!

  """The ID of the associated template"""
  templateId: ID

  """The description of the communication"""
  description: String

  """Whether the communication is enabled"""
  enabled: Boolean
}

type UpdateWorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""Input for updating a workflow config"""
input UpdateWorkflowConfigInput {
  """
  Id of the initial workflow config being updated even though the end config might be a new version
  """
  workflowConfigId: ID!

  """DSR action type for this workflow config, will create new version"""
  actionType: RequestAction

  """
  New plaintext title for the workflow config, will not create new version
  """
  title: String

  """New subtitle for the workflow config, will not create new version"""
  subtitle: String

  """New description for the workflow config, will not create new version"""
  description: String

  """Data subjects for the workflow"""
  subjectId: ID

  """The input identifiers for the workflow"""
  inputIdentifierIds: [ID!]

  """Whether the workflow should be shown in the Privacy Center"""
  showInPrivacyCenter: Boolean

  """The region collection method"""
  collectDataSubjectRegions: CollectDataSubjectRegions

  """The status of the workflow"""
  status: WorkflowConfigStatus

  """Completion state for steps, mapping of step ID to enum"""
  completedSteps: [WorkflowCompletedStepInput!]

  """The list of regions"""
  regionList: [String!]
}

"""Metadata about an uploaded module"""
type UploadedModuleMetadata {
  """The URL for this module"""
  url: String!

  """The name of the module"""
  moduleName: String!
}

"""Input for creating or updating a single consent service"""
input UpsertConsentServiceInput {
  """
  ID of the consent service -- if not specified, we will create a new entry
  """
  id: ID

  """Unique name for this service"""
  name: String

  """The integration name of the catalog entry for this consent service"""
  catalogIntegrationName: String

  """Description of this service"""
  description: String

  """
  Status of this service -- only live and not-junk services are included in the live airgap bundle
  """
  status: ConsentTrackerStatus

  """
  Whether or not this consent service should be included in the live airgap bundle
  """
  isJunk: Boolean

  """Whether or not to show this consent service in the TCF UI modal"""
  showInTcfModal: Boolean
}

"""Another user in the organization."""
type User implements UserInterface {
  """The unique ID of the user"""
  id: ID!

  """The email address of the user"""
  email: String!

  """The name of the user"""
  name: String!

  """The time the user was created"""
  createdAt: Date!

  """The method by which that user logs in"""
  loginMethod: UserLoginMethod!

  """The profile picture of the user"""
  profilePicture: String!

  """Indicates if user can reveal multi tenant sombra secret"""
  canRevealMultiTenantSombraSecret: Boolean!

  """Indicates if the user has been successfully onboarded"""
  onboarded: Boolean!

  """Indicates if the user is an admin of the organization"""
  isAdmin: Boolean!

  """Indicates if the user has an outstanding invitation"""
  isInvited: Boolean!

  """Has the invitation email been sent?"""
  isInviteSent: Boolean!

  """The teams the user is associated with"""
  teams: [TeamPreview!]!

  """
  The direct scopes the user has. The user also takes on team scopes and/or admin privileges.
  """
  scopes: [ScopePreview!]!

  """The derived set of all scopes that the user has"""
  allScopes: [ScopePreview!]!

  """The data silos connected to the user"""
  dataSilos: [Resource!]!
}

"""Inputs for filtering the list of users"""
input UserFiltersInput {
  """Filter by a list of user ids"""
  ids: [ID!]

  """Miscellaneous text (lookup by name)"""
  text: String

  """Filter by admin only"""
  isAdmin: Boolean

  """Filter by users that can reveal multi tenant sombra secrets"""
  canRevealMultiTenantSombraSecret: Boolean

  """Filter by whether the user is invited or not"""
  isInvited: Boolean
}

"""An interface for a user"""
interface UserInterface {
  """The unique ID of the user"""
  id: ID!

  """The email address of the user"""
  email: String!

  """The name of the user"""
  name: String!

  """The time the user was created"""
  createdAt: Date!

  """The method by which that user logs in"""
  loginMethod: UserLoginMethod!

  """The profile picture of the user"""
  profilePicture: String!

  """Indicates if user can reveal multi tenant sombra secret"""
  canRevealMultiTenantSombraSecret: Boolean!
}

"""The order for a User query"""
input UserOrder {
  """The field that the User nodes should be ordered by"""
  field: UserOrderField!

  """The direction in which to order the User nodes by the specified field"""
  direction: OrderDirection!
}

"""A preview of a user, used during joins"""
type UserPreview implements UserInterface {
  """The unique ID of the user"""
  id: ID!

  """The email address of the user"""
  email: String!

  """The name of the user"""
  name: String!

  """The time the user was created"""
  createdAt: Date!

  """The method by which that user logs in"""
  loginMethod: UserLoginMethod!

  """The profile picture of the user"""
  profilePicture: String!

  """Indicates if user can reveal multi tenant sombra secret"""
  canRevealMultiTenantSombraSecret: Boolean!
}

type UsersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of User"""
  nodes: [User!]!

  """int"""
  totalCount: Int!
}

"""A vendor of the organization"""
type Vendor implements VendorInterface {
  """The unique ID of the vendor"""
  id: ID!

  """The time the vendor was created"""
  createdAt: Date!

  """The title of the vendor"""
  title: String!

  """The slug of the vendor for templating"""
  slug: String!

  """The description of the vendor"""
  description: String!

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """Phone number for the vendor"""
  contactPhone: String

  """Address for the vendor"""
  address: String

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The business entity that the vendor is for"""
  businessEntity: BusinessEntityPreview

  """
  The static SaaS vendor that this vendor is tied to, used to update metadata
  """
  saaSVendor: SaaSVendorPreview

  """The data silos related to the vendor"""
  dataSilos: [DiscoveredByDataSiloPreview!]!

  """The business entities that are inherited from the data silos"""
  dataSiloBusinessEntities: [BusinessEntityPreview!]

  """The number of sub-datapoints related to the vendor"""
  subDataPointCount: Int!

  """
  The set of data categories assigned to the sub-datapoints of this vendor
  """
  dataSubCategories: [DataInventoryCategory!]!

  """
  The set of processing purposes assigned to the sub-datapoints of this vendor
  """
  processingPurposeSubCategories: [PurposeSubCategoryPreview!]!

  """The attribute values used to label this vendor"""
  attributeValues: [AttributeValue!]!

  """
  The list of individual users who are responsible for managing this vendor
  """
  owners: [UserPreview!]!

  """The list of teams who are responsible for managing this vendor"""
  teams: [TeamPreview!]!

  """
  The controllership values assigned to the sub-datapoints of this vendor
  """
  controllerships: [Controllership!]!

  """The hosted regions assigned this vendor's data silos"""
  dataSiloRegions: [String!]!

  """
  The pre-labeled recipient categories for catalogs associated with the vendor's data silos
  """
  catalogRecipients: [SaaSCategoryBase!]!
}

type VendorCommunicationsMetadataPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of CommunicationMetadata"""
  nodes: [CommunicationMetadata!]!

  """int"""
  totalCount: Int!
}

"""Inputs for fetching the reduced list of communications for a data silo"""
input VendorCommunicationsMetadataInput {
  """data silo id"""
  dataSiloId: String

  """data silo token"""
  token: String
}

"""An interface for a vendor"""
interface VendorInterface {
  """The unique ID of the vendor"""
  id: ID!

  """The time the vendor was created"""
  createdAt: Date!

  """The title of the vendor"""
  title: String!

  """The slug of the vendor for templating"""
  slug: String!

  """The description of the vendor"""
  description: String!

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """Phone number for the vendor"""
  contactPhone: String

  """Address for the vendor"""
  address: String

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The business entity that the vendor is for"""
  businessEntity: BusinessEntityPreview

  """
  The static SaaS vendor that this vendor is tied to, used to update metadata
  """
  saaSVendor: SaaSVendorPreview
}

"""The order for a Vendor query"""
input VendorOrder {
  """The field that the Vendor nodes should be ordered by"""
  field: VendorOrderField!

  """
  The direction in which to order the Vendor nodes by the specified field
  """
  direction: OrderDirection!
}

"""A preview of a vendor"""
type VendorPreview implements VendorInterface {
  """The unique ID of the vendor"""
  id: ID!

  """The time the vendor was created"""
  createdAt: Date!

  """The title of the vendor"""
  title: String!

  """The slug of the vendor for templating"""
  slug: String!

  """The description of the vendor"""
  description: String!

  """A link to the DPA for this vendor or a note about the status"""
  dataProcessingAgreementLink: String

  """Contact name of person related to email"""
  contactName: String

  """Contact email to use for this vendor (often a third party contact)"""
  contactEmail: String

  """Phone number for the vendor"""
  contactPhone: String

  """Address for the vendor"""
  address: String

  """The ISO country where the vendor is headquartered"""
  headquarterCountry: IsoCountryCode

  """The ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: String

  """The website URL of the vendor, if applicable"""
  websiteUrl: String

  """The status of a DPA with that vendor"""
  dataProcessingAgreementStatus: DataProcessingAgreementStatus

  """The business entity that the vendor is for"""
  businessEntity: BusinessEntityPreview

  """
  The static SaaS vendor that this vendor is tied to, used to update metadata
  """
  saaSVendor: SaaSVendorPreview
}

type VendorsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of Vendor"""
  nodes: [Vendor!]!

  """int"""
  totalCount: Int!
}

"""Filters for vendors"""
input VendorsFiltersInput {
  """Find any vendors are iLike a text string"""
  text: String

  """The ids of the vendors"""
  ids: [ID!]

  """Filter by ISO country where the vendor is headquartered"""
  headquarterCountry: [IsoCountryCode!]

  """Filter by ISO country subdivision where the vendor is headquartered"""
  headquarterSubDivision: [String!]

  """
  Filter by ISO country where any of this vendors's data silos are hosted
  """
  dataSiloCountry: [IsoCountryCode!]

  """
  Filter by ISO country subdivision where any of this vendors's data silos are hosted
  """
  dataSiloCountrySubDivision: [String!]

  """The ids of the teams that own the vendors"""
  teamIds: [ID!]

  """The ids of the users that own the Vendor"""
  ownerIds: [ID!]

  """The attribute values used to label the vendors"""
  attributeValueIds: [ID!]

  """The vendors this business entity uses"""
  businessEntityIds: [ID!]

  """Filter by categories of personal data"""
  dataCategories: [DataCategoryType!]

  """Filter by specific subcategories of personal data"""
  dataSubCategoryIds: [ID!]

  """Filter by purpose of processing"""
  purposes: [ProcessingPurpose!]

  """Filter by specific subcategory of processing purpose"""
  processingPurposeSubCategoryIds: [ID!]

  """
  Filter by controllerships assigned to subdatapoints of this vendor's data silos
  """
  controllerships: [Controllership!]

  """
  Filter by IDs of recipient categories associated with the catalogs of silos belonging to this vendor
  """
  saaSCategoryIds: [ID!]

  """Filter by data silos belonging to this vendor"""
  dataSiloIds: [ID!]

  """Filter by the status of a DPA"""
  dataProcessingAgreementStatus: [DataProcessingAgreementStatus!]
}

type VerifyPrivacyCenterLoginEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """
  A data subject classification that the organization will accept requests for
  """
  dataSubject: DataSubject!

  """string"""
  jwtSession: String!

  """A list of ChildSessionEmailToken"""
  childSessions: [ChildSessionEmailToken!]!
}

type VerifyRequestTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

"""
  For the edges between data silo and identifier, this can be used to list out all
potential identifiers and whether they are connected to the data silo
"""
type WiredIdentifier implements IdentifierInterface {
  """The unique id of the identifier & data silo combination"""
  id: String!

  """The name of the identifier"""
  name: String!

  """The regex string for testing if a value matches the identifier"""
  regex: String!

  """
  Whether the identifier should be required in the Privacy Center/Admin Dashboard DSR form.
  """
  isRequiredInForm: Boolean!

  """The privacy center display title"""
  displayTitle: DefinedMessage

  """The privacy center display description"""
  displayDescription: DefinedMessage

  """The privacy center placeholder text"""
  placeholder: String!

  """
  Indicates if the model can be used to communicate with the data subject
  """
  isCommunicationModel: Boolean!

  """The type of identifier"""
  type: IdentifierType!

  """The logo icon to display with the identifier"""
  logo: String!

  """
  For multi select components, the set of options that should be exposed to the user
  """
  selectOptions: [String!]!

  """Indicates if the identifier has been connected to the data silo"""
  isConnected: Boolean!
}

"""The communication configuration for a workflow"""
type WorkflowCommunicationSettings {
  """The unique ID of the workflow configs communication settings"""
  id: ID!

  """The ID of the associated template"""
  templateId: ID

  """The description of the communication"""
  description: String

  """The type of communication"""
  type: WorkflowCommunicationMethod!

  """Whether the communication is enabled"""
  enabled: Boolean!

  """The type of template"""
  templateType: WorkflowCommunicationTemplateType!
}

type WorkflowCommunicationsSettingsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of WorkflowCommunicationSettings"""
  nodes: [WorkflowCommunicationSettings!]!

  """int"""
  totalCount: Int!
}

"""The completion state for a step in a workflow"""
type WorkflowCompletedStep implements WorkflowCompletedStepInterface {
  """The step ID"""
  step: String!

  """The value to set the step to"""
  value: WorkflowStepCompletionState!
}

"""Input for updating workflow step completion state"""
input WorkflowCompletedStepInput {
  """The step ID"""
  step: String!

  """The value to set the step to"""
  value: WorkflowStepCompletionState!
}

"""The completion state for a step in a workflow"""
interface WorkflowCompletedStepInterface {
  """The step ID"""
  step: String!

  """The value to set the step to"""
  value: WorkflowStepCompletionState!
}

type WorkflowConfigPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """The configuration of a workflow - WIP"""
  workflowConfig: WorkflowConfig!
}

"""The configuration of a workflow - WIP"""
type WorkflowConfig {
  """The unique ID of the workflow config"""
  id: ID!

  """The title of the workflow"""
  title: LocalizedMessage!

  """The subtitle of the workflow"""
  subtitle: LocalizedMessage

  """The description of the workflow"""
  description: LocalizedMessage

  """The action"""
  action: Action!

  """The status of the workflow"""
  status: WorkflowConfigStatus!

  """The last run of the workflow"""
  lastRun: Date

  """The region collection method"""
  collectDataSubjectRegions: CollectDataSubjectRegions!

  """Whether the workflow should be shown in the Privacy Center"""
  showInPrivacyCenter: Boolean!

  """The data subject this workflow is related to"""
  subjectId: ID

  """The related identifiers for the workflow config"""
  WorkflowConfigIdentifiers: [WorkflowConfigIdentifier!]

  """The data subject for this workflow"""
  subject: DataSubject

  """Completion state for steps, mapping of step ID to enum"""
  completedSteps: [WorkflowCompletedStep!]

  """The list of regions"""
  regionList: [String!]
}

"""The identifier for a workflow config"""
type WorkflowConfigIdentifier {
  """The UUID for the workflow config identifier"""
  id: String!

  """The workflow config ID"""
  workflowConfigId: ID!

  """The identifier ID"""
  identifierId: ID!

  """The identifier for the WorkflowConfigIdentifier"""
  identifier: Identifier!
}

"""Input getting workflow data with a workflowConfigId"""
input WorkflowConfigIdInput {
  """The workflow config ID"""
  workflowConfigId: ID!
}

"""Input for getting the latest workflow config"""
input WorkflowConfigInput {
  """The workflow config ID"""
  id: ID!
}

"""A workflow data point"""
type WorkflowDataPoint {
  """The export mode of the datapoint"""
  exportMode: DataPointExportMode

  """The order of the datapoint"""
  order: Int

  """The action to toggle on or off"""
  action: WorkflowDataPointAction

  """The workflow identifiers used in this data point"""
  selectedIdentifiers: [WorkflowDataPointIdentifier!]
}

"""The action being taken on a given WorkflowConfigDataPoint"""
type WorkflowDataPointAction {
  """The display title of the request action"""
  title: DefinedMessage!

  """The display description of the request action"""
  description: DefinedMessage!

  """A custom icon for the action"""
  icon: String

  """The unique id of the action"""
  id: ID!

  """The type of action"""
  type: RequestAction!
}

"""A workflow identifier for a datapoint"""
type WorkflowDataPointIdentifier {
  """The identifier of the datapoint"""
  identifier: String!

  """Whether the identifier is selected"""
  selected: Boolean!
}

"""Input for data silos and workflows"""
input WorkflowDataSiloInput {
  """Id of the workflow config"""
  workflowConfigId: ID!

  """The data silo"""
  dataSiloIds: [ID!]!
}

"""An enricher associated with a specific workflow"""
type WorkflowEnricher {
  """Identifier plaintext name"""
  title: String!

  """enricher id"""
  id: ID!

  """Enricher icon name (called logo in enricher resolver)"""
  logo: String!

  """Identifier that feeds into this enricher"""
  inputIdentifier: WorkflowIdentifierBase!

  """The identifiers produced by this enricher"""
  outputIdentifiers: [WorkflowIdentifierBase!]!

  """The sources for this identifier"""
  identifierSources: [IdentifierSourceEnricher!]!

  """Whether the enricher is disabled"""
  isDisabled: Boolean!
}

type WorkflowEnrichersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of WorkflowEnricher"""
  nodes: [WorkflowEnricher!]!

  """int"""
  totalCount: Int!
}

"""
Input for getting specific enrichers related or not related to a workflow
"""
input WorkflowEnrichersInput {
  """The workflow config ID"""
  workflowConfigId: ID!

  """Whether to fetch those associated or not associated"""
  notAssociatedWithWorkflowConfig: Boolean

  """An optional set of allowed enricher types"""
  allowedEnricherTypes: [EnricherType!]

  """An optional set of enricher types to exclude"""
  excludedEnricherTypes: [EnricherType!]

  """An optional set of output identifier types to filter by"""
  outputIdentifierTypes: [IdentifierType!]
}

"""Input for filtering workflows"""
input WorkflowFilterInput {
  """Filter to requests for these subjects"""
  subjectIds: [ID!]

  """Filter only certain request types"""
  action: [RequestAction!]
}

"""An identifier for a specific workflow"""
type WorkflowIdentifier implements WorkflowIdentifierBaseInterface {
  """Identifier plaintext name"""
  name: String!

  """Identifier type"""
  type: IdentifierType!

  """Identifier id"""
  id: ID!

  """Identifier icon name (called logo in identifier resolver)"""
  logo: String!

  """
  Source enricher, if present, associated with workflow that provides this identifier
  """
  sourceEnrichers: [IdentifierSourceEnricher!]!

  """The data silos that require this identifier for processing"""
  destinationDataSilos: [IdentifierDestinationDataSilo!]!

  """The behavior to perform if an identifier is missing from the request"""
  missingIdBehavior: MissingIdBehavior!
}

"""Base attributes for a workflowIdentifier"""
type WorkflowIdentifierBase implements WorkflowIdentifierBaseInterface {
  """Identifier plaintext name"""
  name: String!

  """Identifier type"""
  type: IdentifierType!

  """Identifier id"""
  id: ID!

  """Identifier icon name (called logo in identifier resolver)"""
  logo: String!
}

"""Base attributes for a workflowIdentifier"""
interface WorkflowIdentifierBaseInterface {
  """Identifier plaintext name"""
  name: String!

  """Identifier type"""
  type: IdentifierType!

  """Identifier id"""
  id: ID!

  """Identifier icon name (called logo in identifier resolver)"""
  logo: String!
}

type WorkflowIdentifiersPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of WorkflowIdentifier"""
  nodes: [WorkflowIdentifier!]!

  """int"""
  totalCount: Int!
}

"""The instance of a workflow"""
type WorkflowInstance {
  """The unique ID of the workflow instance"""
  id: ID!

  """The organization ID"""
  organizationId: ID!

  """The workflow config ID"""
  workflowConfigId: ID

  """The request ID"""
  requestId: ID!

  """The status of the workflow"""
  status: WorkflowInstanceStatus!

  """The phase of the workflow"""
  phase: WorkflowPhase!

  """The trigger for the workflow"""
  triggeredBy: WorkflowTrigger!

  """The scheduled time for the workflow"""
  scheduledAt: Date!
}

type WorkflowsPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """A list of WorkflowConfig"""
  nodes: [WorkflowConfig!]!

  """int"""
  totalCount: Int!
}

type WrongLoginEmailPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}

type WrongRequestTokenPayload {
  """
  The optional clientMutationId in the input type is returned if it was provided
  """
  clientMutationId: String

  """boolean"""
  success: Boolean!
}